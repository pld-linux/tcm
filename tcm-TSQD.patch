diff -urN tcm-2.20/bin/linkx tcm-2.20+TSQD.orig/bin/linkx
--- tcm-2.20/bin/linkx	2003-01-09 16:29:24.000000000 +0100
+++ tcm-2.20+TSQD.orig/bin/linkx	2004-07-21 20:04:40.000000000 +0200
@@ -4,7 +4,7 @@
 }
 cd $TCM_HOME/bin
 
-DFILES="tgd terd tesd tcrd tssd tucd tatd tstd trpg tpsd tdfd tefd tsnd tgtt tfrt tcpd tdpd tcbd tscd"
+DFILES="tgd terd tesd tcrd tssd tsqd tucd tatd tstd trpg tpsd tdfd tefd tsnd tgtt tfrt tcpd tdpd tcbd tscd"
 TFILES="tgt ttut ttdt tfet"
 
 # remove TCM tool executables and make softlinks
diff -urN tcm-2.20/bin/linky tcm-2.20+TSQD.orig/bin/linky
--- tcm-2.20/bin/linky	2003-01-10 11:17:01.000000000 +0100
+++ tcm-2.20+TSQD.orig/bin/linky	2004-07-21 20:04:58.000000000 +0200
@@ -5,7 +5,7 @@
 cd $TCM_HOME/bin
 
 GDFILES="tgd"
-DVFILES="terd tesd tcrd tssd tucd tcbd"
+DVFILES="terd tesd tcrd tssd tucd tcbd tsqd"
 BVFILES="tatd tstd trpg tpsd tscd"
 FVFILES="tdfd tefd tsnd"
 TRILES="tgtt tfrt"
diff -urN tcm-2.20/doc/developersguide/TechDoc.html tcm-2.20+TSQD.orig/doc/developersguide/TechDoc.html
--- tcm-2.20/doc/developersguide/TechDoc.html	2003-01-07 16:27:55.000000000 +0100
+++ tcm-2.20+TSQD.orig/doc/developersguide/TechDoc.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,158 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
-originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
-* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
-* with significant contributions from:
-  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
-<HTML>
-<HEAD>
-<TITLE>Toolkit for Conceptual Modeling (TCM) Design and Implementation for version 2.01</TITLE>
-<META NAME="description" CONTENT="Toolkit for Conceptual Modeling (TCM) Design and Implementation for version 2.01">
-<META NAME="keywords" CONTENT="TechDoc">
-<META NAME="resource-type" CONTENT="document">
-<META NAME="distribution" CONTENT="global">
-<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
-<LINK REL="STYLESHEET" HREF="TechDoc.css">
-<LINK REL="next" HREF="developersguidenode1.html">
-</HEAD>
-<BODY >
-<!--Navigation Panel-->
-<A NAME="tex2html194"
- HREF="developersguidenode1.html">
-<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
-<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif_gr.gif"> 
-<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif_gr.gif"> 
-<A NAME="tex2html193"
- HREF="developersguidenode1.html">
-<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A>  
-<BR>
-<B> Next:</B> <A NAME="tex2html195"
- HREF="developersguidenode1.html">Contents</A>
-<BR>
-<BR>
-<!--End of Navigation Panel-->
-
-<H1 ALIGN="CENTER">
-<!-- MATH: $\includegraphics{p/Teapot2a.ps}$ -->
-<IMG
- WIDTH="145" HEIGHT="93" ALIGN="BOTTOM" BORDER="0"
- SRC="developersguideimg1.gif"
- ALT="\includegraphics{p/Teapot2a.ps}">
-<BR>
-Toolkit for Conceptual Modeling (TCM) <BR>
-Design and Implementation <BR>
-<FONT SIZE="-1">for version 2.01</FONT></H1>
-<P ALIGN="CENTER"><STRONG><TABLE CELLPADDING=3>
-<TR><TD ALIGN="CENTER">Frank Dehne</TD><TD ALIGN="CENTER">Henk R. van de Zandschulp</TD>
-</TR>
-<TR><TD ALIGN="CENTER"><FONT SIZE="-1">Division of Mathematics and Computer Science </FONT></TD><TD ALIGN="CENTER"><FONT SIZE="-1">Department of Computer Science </FONT></TD>
-</TR>
-<TR><TD ALIGN="CENTER"><FONT SIZE="-1">Faculty of Sciences, Vrije Universiteit </FONT></TD><TD ALIGN="CENTER"><FONT SIZE="-1">University of Twente </FONT></TD>
-</TR>
-<TR><TD ALIGN="CENTER"><FONT SIZE="-1">De Boelelaan 1081a, 1081 HV Amsterdam </FONT></TD><TD ALIGN="CENTER"><FONT SIZE="-1">P.O. Box 217, 7500 AE Enschede </FONT></TD>
-</TR>
-<TR><TD ALIGN="CENTER"><FONT SIZE="-1">The Netherlands </FONT></TD><TD ALIGN="CENTER"><FONT SIZE="-1">The Netherlands </FONT></TD>
-</TR>
-<TR><TD ALIGN="CENTER"><FONT SIZE="-1">frank@cs.vu.nl </FONT></TD><TD ALIGN="CENTER"><FONT SIZE="-1">henkz@cs.utwente.nl
-</FONT></TD>
-</TR>
-</TABLE></STRONG></P>
-<P ALIGN="CENTER"><STRONG>February 12, 2001</STRONG></P>
-<P ALIGN="LEFT"></P>
-
-<P>
-<BR><HR>
-<!--Table of Child-Links-->
-<A NAME="CHILD_LINKS">&#160;</A>
-<UL>
-<LI><A NAME="tex2html196"
- HREF="developersguidenode1.html">Contents</A>
-<LI><A NAME="tex2html197"
- HREF="developersguidenode2.html">1. Introduction</A>
-<LI><A NAME="tex2html198"
- HREF="developersguidenode3.html">2. System Architecture</A>
-<LI><A NAME="tex2html199"
- HREF="developersguidenode4.html">3. Source Code Organization</A>
-<UL>
-<LI><A NAME="tex2html200"
- HREF="developersguidenode4.html#SECTION00410000000000000000">3.1 Source code versus design criteria</A>
-<LI><A NAME="tex2html201"
- HREF="developersguidenode4.html#SECTION00420000000000000000">3.2 Individual files and directories</A>
-<LI><A NAME="tex2html202"
- HREF="developersguidenode4.html#SECTION00430000000000000000">3.3 Object libraries</A>
-</UL>
-<LI><A NAME="tex2html203"
- HREF="developersguidenode5.html">4. TCM User Interface</A>
-<UL>
-<LI><A NAME="tex2html204"
- HREF="developersguidenode5.html#SECTION00510000000000000000">4.1 X/Motif user interface</A>
-<LI><A NAME="tex2html205"
- HREF="developersguidenode5.html#SECTION00520000000000000000">4.2 User interface implementation</A>
-<UL>
-<LI><A NAME="tex2html206"
- HREF="developersguidenode5.html#SECTION00521000000000000000">4.2.1 Overview</A>
-<LI><A NAME="tex2html207"
- HREF="developersguidenode5.html#SECTION00522000000000000000">4.2.2 Application startup</A>
-<LI><A NAME="tex2html208"
- HREF="developersguidenode5.html#SECTION00523000000000000000">4.2.3 Main window structure</A>
-<LI><A NAME="tex2html209"
- HREF="developersguidenode5.html#SECTION00524000000000000000">4.2.4 Calling functions from the user interface</A>
-</UL>
-<LI><A NAME="tex2html210"
- HREF="developersguidenode5.html#SECTION00530000000000000000">4.3 Xlib drawing</A>
-</UL>
-<LI><A NAME="tex2html211"
- HREF="developersguidenode6.html">5. TCM Class Hierarchy</A>
-<LI><A NAME="tex2html212"
- HREF="developersguidenode7.html">6. Output Files</A>
-<UL>
-<LI><A NAME="tex2html213"
- HREF="developersguidenode7.html#SECTION00710000000000000000">6.1 PostScript output</A>
-<UL>
-<LI><A NAME="tex2html214"
- HREF="developersguidenode7.html#SECTION00711000000000000000">6.1.1 Plain PostScript</A>
-<UL>
-<LI><A NAME="tex2html215"
- HREF="developersguidenode7.html#SECTION00711100000000000000">6.1.1.1 Header</A>
-<LI><A NAME="tex2html216"
- HREF="developersguidenode7.html#SECTION00711200000000000000">6.1.1.2 Pages</A>
-</UL>
-<LI><A NAME="tex2html217"
- HREF="developersguidenode7.html#SECTION00712000000000000000">6.1.2 Encapsulated PostScript</A>
-<LI><A NAME="tex2html218"
- HREF="developersguidenode7.html#SECTION00713000000000000000">6.1.3 PSGrafport</A>
-</UL>
-<LI><A NAME="tex2html219"
- HREF="developersguidenode7.html#SECTION00720000000000000000">6.2 TCM file format</A>
-</UL>
-<LI><A NAME="tex2html220"
- HREF="developersguidenode8.html">7. Compiling and Porting TCM</A>
-<UL>
-<LI><A NAME="tex2html221"
- HREF="developersguidenode8.html#SECTION00810000000000000000">7.1 Compiling TCM</A>
-<UL>
-<LI><A NAME="tex2html222"
- HREF="developersguidenode8.html#SECTION00811000000000000000">7.1.1 Compilation configuration files</A>
-<LI><A NAME="tex2html223"
- HREF="developersguidenode8.html#SECTION00812000000000000000">7.1.2 Makefiles</A>
-</UL>
-<LI><A NAME="tex2html224"
- HREF="developersguidenode8.html#SECTION00820000000000000000">7.2 Porting TCM</A>
-<LI><A NAME="tex2html225"
- HREF="developersguidenode8.html#SECTION00830000000000000000">7.3 G++ specific problems</A>
-</UL>
-<LI><A NAME="tex2html226"
- HREF="developersguidenode9.html">8. Wish List and Future Plans</A>
-<LI><A NAME="tex2html227"
- HREF="developersguidenode10.html">Bibliography</A>
-<LI><A NAME="tex2html228"
- HREF="developersguidenode11.html">About this document ... </A>
-</UL>
-<!--End of Table of Child-Links-->
-<BR><HR>
-<ADDRESS>
-<I>Henk van de Zandschulp</I>
-<BR><I>2003-01-07</I>
-</ADDRESS>
-</BODY>
-</HTML>
diff -urN tcm-2.20/FILEMAP tcm-2.20+TSQD.orig/FILEMAP
--- tcm-2.20/FILEMAP	2003-01-09 16:11:33.000000000 +0100
+++ tcm-2.20+TSQD.orig/FILEMAP	2004-07-21 20:01:26.000000000 +0200
@@ -15,7 +15,7 @@
 
 TCM_BIN (e.g. bin/)
         tcm     (TCM startup program).
- 
+
         tatd    (Tool for UML Activity Diagrams).
         tcbd    (Tool for UML Collaboration Diagrams).
         tcpd    (Tool for UML Component Diagrams).
@@ -35,11 +35,12 @@
         tscd    (Tool for UML Statechart Diagrams).
         tsnd    (Tool for System Network Diagrams).
         tssd    (Tool for UML Static Structure Diagrams).
+	tsqd    (Tool for UML Sequence Diagrams).
         tstd    (Tool for State Transition Diagrams).
         ttdt    (Tool for Transaction Decomposition Tables).
         ttut    (Tool for Transaction Use Tables).
         tucd    (Tool for UML Use-Case Diagrams).
- 
+
         psf     (PostScript filter script in Perl).
         text2ps (program that converts ASCII to PostScript).
 
diff -urN tcm-2.20/lib/TCM tcm-2.20+TSQD.orig/lib/TCM
--- tcm-2.20/lib/TCM	2003-01-10 11:13:14.000000000 +0100
+++ tcm-2.20+TSQD.orig/lib/TCM	2004-07-21 20:10:06.000000000 +0200
@@ -60,7 +60,7 @@
 TCM*StartupWindow*TATD.Background:	light blue
 TCM*StartupWindow*TSCD.Background: 	light blue
 TCM*StartupWindow*TCBD.Background:	light blue
-TCM*StartupWindow*TSQD.Background:	light gray
+TCM*StartupWindow*TSQD.Background:	light blue
 TCM*StartupWindow*TCPD.Background:	light blue
 TCM*StartupWindow*TDPD.Background:	light blue
 TCM*StartupWindow*TESD.Background:	light yellow
@@ -91,7 +91,7 @@
 
 #else
 
-!! Monchrome resource. This is used when you have a black 
+!! Monchrome resource. This is used when you have a black
 !! and white display.
 TCM*Background:				white
 #endif
@@ -107,7 +107,7 @@
 TCM*DocumentType.fontList:  	-*-helvetica-bold-r-*--12-*
 TCM*StatusText.fontList: 	-*-helvetica-medium-r-*--11-*
 
-!! Fonts used for TCM startup_window program. 
+!! Fonts used for TCM startup_window program.
 TCM*StartupWindow*fontList: -*-helvetica-bold-r-*--12-*
 TCM*StartupWindow*statusBar.fontList: -*-helvetica-medium-r-*--10-*
 
diff -urN tcm-2.20/src/bitmaps/FOCBox.xbm tcm-2.20+TSQD.orig/src/bitmaps/FOCBox.xbm
--- tcm-2.20/src/bitmaps/FOCBox.xbm	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/bitmaps/FOCBox.xbm	2002-02-28 11:56:35.000000000 +0100
@@ -0,0 +1,12 @@
+#define FOCBox_width 32
+#define FOCBox_height 32
+static unsigned char FOCBox_bits[] = {
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,
+ 0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0xe0,0x0f,0x00,0x00,0x20,
+ 0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,
+ 0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,
+ 0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,
+ 0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,
+ 0x08,0x00,0x00,0x20,0x08,0x00,0x00,0x20,0x08,0x00,0x00,0xe0,0x0f,0x00,0x00,
+ 0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,
+ 0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00};
diff -urN tcm-2.20/src/dg/anchorpoint.c tcm-2.20+TSQD.orig/src/dg/anchorpoint.c
--- tcm-2.20/src/dg/anchorpoint.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/anchorpoint.c	2001-08-03 09:23:49.000000000 +0200
@@ -0,0 +1,61 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl)
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+#include "anchorpoint.h"
+#include "lstring.h"
+
+void AnchorPoint::Type2String(AnchorType t, string *s) {
+	if (t == START_FOC)
+		*s = "StartFOC";
+	else if (t == END_FOC)
+		*s = "End_FOC";
+	else if (t == START_ANCHOR)
+		*s = "StartAnchor";
+	else if (t == END_ANCHOR)
+		*s = "EndAnchor";
+	else if (t == MULTI_ANCHOR)
+		*s = "MultiAnchor";
+	else if (t == NON_DESTR_END)
+		*s = "NonDestructiveEnd";
+	else if (t == DESTR_END)
+		*s = "DestructiveEnd";
+	else 
+		*s = "None";
+}
+ 
+AnchorPoint::AnchorType AnchorPoint::String2Type(const string *s) {
+	if (*s %= "StartFOC")
+		return START_FOC;
+	if (*s %= "End_FOC")
+		return END_FOC;
+	if (*s %= "StartAnchor")
+		return START_ANCHOR;
+	if (*s %= "EndAnchor")
+		return END_ANCHOR;
+	if (*s %= "MultiAnchor")
+		return MULTI_ANCHOR;
+	if (*s %= "NonDestructiveEnd")
+		return NON_DESTR_END;
+	if (*s %= "DestructiveEnd")
+		return DESTR_END;
+	else 
+		return NONE;
+}
diff -urN tcm-2.20/src/dg/anchorpoint.h tcm-2.20+TSQD.orig/src/dg/anchorpoint.h
--- tcm-2.20/src/dg/anchorpoint.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/anchorpoint.h	2001-08-03 16:25:45.000000000 +0200
@@ -0,0 +1,65 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl)
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version. 
+// 
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _ANCHORPOINT_H
+#define _ANCHORPOINT_H
+
+#include "lstring.h"
+
+/// anchorpoint to attach to 
+class AnchorPoint {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	enum AnchorType { NONE, START_FOC, END_FOC, 
+			START_ANCHOR, END_ANCHOR, MULTI_ANCHOR, NON_DESTR_END, DESTR_END};
+
+	/// Construct and initialize message.
+	AnchorPoint(int o, AnchorType a = NONE) {
+			offset = o; anchorType = a; }
+
+	/// Construct and initialize message.
+	AnchorPoint(int o) {
+			offset = o; anchorType = NONE; }
+
+	/// set offset 
+	void SetOffset(int o) {offset = o;} 
+	///
+	int GetOffset() const {return offset;}
+
+	/// set anchor type
+	void SetAnchorType(AnchorType t) {anchorType = t;} 
+	///
+	AnchorPoint::AnchorType GetAnchorType() const {return anchorType;}
+
+	/// e.g. convert "NonDestructiveEnd" to NON_DESTR_END.
+	static AnchorPoint::AnchorType String2Type(const string *s);
+
+	/// e.g. convert DESTR_END to "DestructiveEnd".
+	static void Type2String(AnchorType t, string *s);
+
+private:
+	///
+	int offset;
+	///
+	AnchorType anchorType;
+};
+#endif
diff -urN tcm-2.20/src/dg/anchorpointnode.c tcm-2.20+TSQD.orig/src/dg/anchorpointnode.c
--- tcm-2.20/src/dg/anchorpointnode.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/anchorpointnode.c	2004-03-25 14:13:50.000000000 +0100
@@ -0,0 +1,117 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl)
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+#include "inputfile.h"
+#include "outputfile.h"
+#include "lstring.h"
+#include "node.h"
+#include "anchorpointnode.h"
+#include "anchorpoint.h"
+
+AnchorPointNode::AnchorPointNode(Graph *g): Node(g) {
+	anchors = new List<AnchorPoint *>;
+}
+
+AnchorPointNode::AnchorPointNode(const AnchorPointNode &s): Node(s) {
+	anchors = new List<AnchorPoint *>;
+	for (s.anchors->first(); !s.anchors->done(); 
+			s.anchors->next()) {
+		AnchorPoint *a = s.anchors->cur();
+		anchors->add(new AnchorPoint(*a));
+	}
+}
+
+AnchorPointNode::~AnchorPointNode() {
+	anchors->clear();
+	delete anchors;
+}
+
+bool AnchorPointNode::HasAnchor(const AnchorPoint *p) {
+	for (anchors->first(); !anchors->done(); anchors->next()) {
+                if (anchors->cur()->GetOffset() == p->GetOffset())
+                        return True;
+        }
+        return False;
+}
+
+AnchorPointNode::AnchorErrorType AnchorPointNode::SetAnchor(
+                const AnchorPoint *p, unsigned n, bool update) {
+//HZ	StringList::Insert(anchors, p, n, update);
+        return AnchorPointNode::ANCHOR_OK;
+}
+
+bool AnchorPointNode::ReadMembers(InputFile *ifile, double format) {
+	if (!Node::ReadMembers(ifile, format))
+		return False;
+	string val;
+	if (!ifile->ReadAttribute("anchors", &val))
+		return False;
+	int numItems = val.toint();
+	for (int i=0; i<numItems; i++) {
+
+		// read position of the textShape1 text shape.
+		string val1, val2;
+		if (!ifile->ReadAttribute2("anchor", &val1, &val2))
+			return False;
+
+		int x = val1.toint();
+		AnchorPoint::AnchorType at = AnchorPoint::String2Type(&val2);
+
+		AnchorPoint ap = AnchorPoint(x, at);
+		AnchorPoint *pap = new AnchorPoint(x, at);
+
+		anchors->add(&ap);
+		anchors->add(pap);
+
+	}
+
+
+std::cout << "AnchorPoints {" << numItems << "} are : " << std::endl << std::flush;
+	string x;
+	for (int i=0; i<(int) numItems; i++) {
+
+
+		AnchorPoint::Type2String((*anchors)[i]->GetAnchorType(), &x);
+std::cout << "\t Anchor " << i <<
+	"\t Offset = " << (int) (*anchors)[i]->GetOffset() << 
+	"\t Type   = " << (int) (*anchors)[i]->GetAnchorType() << 
+	"\t SType  = " << x <<
+
+std::endl << std::flush;
+	}
+
+
+	return True;
+}
+
+void AnchorPointNode::WriteMembers(OutputFile *ofile) {
+	Node::WriteMembers(ofile);
+	int numItems = anchors->count();
+	(*ofile) << "\t{ anchors " << numItems << " }\n";
+	for (int i=0; i<numItems; i++) {
+		(*ofile) << "\t{ anchor " << (int) (*anchors)[i]->GetOffset() << 
+			" " << (int) (*anchors)[i]->GetAnchorType() << " }\n";
+	}
+}
+
+
+
+
diff -urN tcm-2.20/src/dg/anchorpointnode.h tcm-2.20+TSQD.orig/src/dg/anchorpointnode.h
--- tcm-2.20/src/dg/anchorpointnode.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/anchorpointnode.h	2001-08-03 16:31:50.000000000 +0200
@@ -0,0 +1,66 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl)
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _ANCHORPOINTNODE_H
+#define _ANCHORPOINTNODE_H
+
+#include "node.h"
+#include "anchorpoint.h"
+
+/// A node that has an extra list of anchorpoints.
+class AnchorPointNode: public Node {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	AnchorPointNode(Graph *g);
+	///
+	AnchorPointNode(const AnchorPointNode &a);
+	///
+	virtual ~AnchorPointNode();
+	///
+	Subject *Clone() {return new AnchorPointNode(*this);}
+	///
+	Subject::NameErrType SetName(const string *name);
+	///
+	enum AnchorErrorType {
+		ANCHOR_OK, ANCHOR_SYNTAX_ERROR, ANCHOR_ALREADY_EXISTS};
+	///
+	virtual AnchorPointNode::AnchorErrorType SetAnchor(
+		const AnchorPoint *p, unsigned n, bool update); 
+	///
+	const AnchorPoint *GetAnchor(unsigned n) 
+		{return ((n < anchors->count()) ? (*anchors)[n] : 0);}
+	///
+	unsigned NrAnchors() {return anchors->count();}
+	///
+	bool HasAnchor(const AnchorPoint *p);
+	///
+	void WriteMembers(OutputFile *f);
+	///
+	bool ReadMembers(InputFile *f, double format);
+protected:
+	///
+	List<AnchorPoint *> *GetAnchors() {return anchors;}
+private:
+	///
+	List<AnchorPoint *> *anchors;
+};
+#endif
diff -urN tcm-2.20/src/dg/createedgecmd.h tcm-2.20+TSQD.orig/src/dg/createedgecmd.h
--- tcm-2.20/src/dg/createedgecmd.h	2003-01-09 15:52:42.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/createedgecmd.h	2004-07-21 20:22:43.000000000 +0200
@@ -57,6 +57,12 @@
 	void AddPoint(Point *pt) {points->add(new Point(pt->x, pt->y));}
 	///
 	void EraseLines();
+	/// for TSQD
+	GShape *GetFromShape() const {return fromShape;}
+	/// for TSQD
+	GShape *GetToShape() const {return toShape;}
+	/// for TSQD
+	List<Point *> *GetPoints() {return points;}
 private:
 	///
 	Diagram *diagram;
diff -urN tcm-2.20/src/dg/diagram.c tcm-2.20+TSQD.orig/src/dg/diagram.c
--- tcm-2.20/src/dg/diagram.c	2003-01-09 15:52:42.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/diagram.c	2004-07-23 15:46:27.000000000 +0200
@@ -221,21 +221,7 @@
 			}
 		}
 		// update order-count of straight redirected line.
-		if (line->NrPoints() == 2) {
-			view->MultipleLines(line);
-			view->MultipleLinesPosUpdate(line);
-			// update order+count of remaining straight lines 
-			// between end1 and end2.
-			List<GShape *> lines;
-			view->CompleteShapes(&lines, end1, end2);
-			if (lines.first()) {
-				Line *line2 = (Line *)lines.cur();
-				if (line2->NrPoints() == 2) {
-					view->MultipleLines(line2);
-					view->MultipleLinesPosUpdate(line2);
-				}
-			}
-		}
+
 		return True;
 	}
 	return False;
@@ -425,7 +411,7 @@
 			else {
 				deleteShapes.add(shape);
 				error("%s: shape %ld can not be read\n", 
-					ipf->GetFileName()->getstr(), 
+					ipf->GetFileName()->getstr(),
 					assoc->original);
 			}
 		}
diff -urN tcm-2.20/src/dg/diagramviewer.h tcm-2.20+TSQD.orig/src/dg/diagramviewer.h
--- tcm-2.20/src/dg/diagramviewer.h	2002-05-28 10:31:53.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/dg/diagramviewer.h	2004-07-21 20:27:05.000000000 +0200
@@ -110,9 +110,9 @@
                 defaultLineEnd2 = t; }
                 
 	/// forwarding to grid object.
-	int Snap(int i) const {return grid->Snap(i);}
+	virtual int Snap(int i) const {return grid->Snap(i);}
 	///
-	void Snap(Point *p) {grid->Snap(p);}
+	virtual void Snap(Point *p) {grid->Snap(p);}
 
 	///
 	void SetStatus(const char *msg) {GetMainWindow()->SetStatus(msg);}
diff -urN tcm-2.20/src/dg/dragshapecmd.c tcm-2.20+TSQD.orig/src/dg/dragshapecmd.c
--- tcm-2.20/src/dg/dragshapecmd.c	2001-10-06 23:11:00.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/dg/dragshapecmd.c	2004-07-21 20:28:21.000000000 +0200
@@ -71,7 +71,7 @@
 }
 
 void DragShapeCmd::Execute() {
-	Point p = oldPosition - delta;
+	Point p = oldPosition + delta;
 	view->GetViewer()->Snap(&p);
 	p = p - oldPosition;
 	if (p == Point::ZERO) {
diff -urN tcm-2.20/src/dg/dragshapescmd.c tcm-2.20+TSQD.orig/src/dg/dragshapescmd.c
--- tcm-2.20/src/dg/dragshapescmd.c	2002-05-28 10:31:55.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/dg/dragshapescmd.c	2004-07-21 20:28:42.000000000 +0200
@@ -83,7 +83,7 @@
 
 void DragShapesCmd::Execute() {
 	Point oldPosition = *(*oldPositions)[0];
-	Point p = oldPosition - delta;
+	Point p = oldPosition + delta;
 	view->GetViewer()->Snap(&p);
 	p = p - oldPosition;
 	if (p == Point::ZERO) {
diff -urN tcm-2.20/src/dg/line.h tcm-2.20+TSQD.orig/src/dg/line.h
--- tcm-2.20/src/dg/line.h	2003-01-09 15:52:43.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/line.h	2004-07-23 15:29:26.000000000 +0200
@@ -217,7 +217,9 @@
 
 	/// just recalculate the position of the name text shape.
 	Point RecalcPositionName(bool useReadDirection);
-
+//Begin SQD Integration
+	virtual void SetAnchors() {;}
+//End SQD Integration
 protected:
 	/// draws a line.
 	void DrawShape();
diff -urN tcm-2.20/src/dg/Makefile tcm-2.20+TSQD.orig/src/dg/Makefile
--- tcm-2.20/src/dg/Makefile	2003-01-22 15:16:39.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/Makefile	2004-07-23 15:38:45.000000000 +0200
@@ -1,7 +1,10 @@
+
 include ../Config.tmpl
 
 OBJECTS=addhandlecmd.o\
 	alignnodeshapescmd.o\
+	anchorpoint.o\
+	anchorpointnode.o\
 	arrowtextbox.o\
 	blackdot.o\
 	box.o\
diff -urN tcm-2.20/src/dg/nodeshape.h tcm-2.20+TSQD.orig/src/dg/nodeshape.h
--- tcm-2.20/src/dg/nodeshape.h	2002-05-28 10:32:07.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/dg/nodeshape.h	2004-07-21 20:33:39.000000000 +0200
@@ -94,7 +94,7 @@
 	/* virtual */ void DrawShape();
 
 	/// draws the outline with a specific size.
-	void DrawOutLine(double x, double y, double w, double h);
+	virtual void DrawOutLine(double x, double y, double w, double h);
 	///
 	/* virtual */ void DrawOutLine(const Point *centre);
 	///
diff -urN tcm-2.20/src/dg/pullshapecmd.c tcm-2.20+TSQD.orig/src/dg/pullshapecmd.c
--- tcm-2.20/src/dg/pullshapecmd.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/pullshapecmd.c	2004-03-25 14:26:39.000000000 +0100
@@ -0,0 +1,129 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1995, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+//#include "grafport.h"
+#include "nodeshape.h"
+#include "shapeview.h"
+#include "diagram.h"
+#include "diagramviewer.h"
+//#include "drawwindow.h"
+#include "pullshapecmd.h"
+
+// dir = handle nr + 1
+
+PullShapeCmd::PullShapeCmd(GShape *s, int dir)
+	:Command(s->GetView()->GetViewer()->GetDiagram(), 
+		s->GetView()->GetViewer()),
+	fixpoint(*s->GetPosition()),
+	centre(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0),
+	corner(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
+{
+	if ( ! (shape = dynamic_cast<NodeShape *>(s)) )
+		error("Illegal use of size shape command");
+	constrainX = False;
+	constrainY = False;
+	switch ( dir ) {
+	case 5:
+	case 6:
+		constrainX = True; // only change height
+		break;
+	case 7:
+	case 8:
+		constrainY = True; // only change width
+		break;
+	}
+	direction = 5;
+}
+
+
+void PullShapeCmd::TrackMouse(TrackType aPhase, Point * /* anchorPoint */,
+	Point * /* previousPoint */, Point *nextPoint)
+{
+	switch(aPhase) {
+		case TRACK_PRESS:
+			GetMainWindow()->SetSizeCursor(direction);
+			CalcEndPoint(nextPoint);
+			Draw();
+			break;
+		case TRACK_DRAG:
+			Undraw();
+			CalcEndPoint(nextPoint);
+			Draw();
+			break;
+		case TRACK_RELEASE:
+			Undraw();
+			GetMainWindow()->SetCursor(MouseCursor::LEFT_PTR);
+			break;
+		default:
+			error("unknown track type\n");
+			break;
+	}
+}
+
+
+void PullShapeCmd::CalcEndPoint(const Point *p) {
+
+
+std::cout << " void PullShapeCmd::CalcEndPoint(" << *p << ") GCt=" <<
+		shape->GetSubject()->GetClassType()  << std::endl << std::flush; 
+
+	LifeLine *l = (LifeLine *) shape;
+	int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT CalcEndPoint[" << *p << "] @end:" << yy << std::endl << std::flush; 
+	l->SetEndPositionY(*p->y);
+	l->SetPositionHandles();
+}
+
+
+void PullShapeCmd::Draw() {
+	shape->DrawOutLine(shape->GetPosition());
+}
+
+
+void PullShapeCmd::Execute() {
+	Command::Execute();
+	Point pt(newEndPosition);
+	shape->SetEndPositionY(pt.y);
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);
+//	GetMainWindow()->FitDocument();
+}
+
+
+void PullShapeCmd::UnExecute() {
+	Command::UnExecute();
+	Point pt(oldEndPosition);
+
+
+	LifeLine *l = (LifeLine *) shape;
+	int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT LifeLine End? w=" << w << " @end:" << yy << std::endl << std::flush; 
+	Undraw();
+	l->SetEndPositionY(yy+50);
+	l->SetPositionHandles();
+	Draw();
+
+
+
+
+	shape->SetEndPositionY(pt.y);
+//	shape->UpdateSize(int(0.5 + oldWidth), int(0.5 + oldHeight));
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);	
+}
diff -urN tcm-2.20/src/dg/pullshapecmd.h tcm-2.20+TSQD.orig/src/dg/pullshapecmd.h
--- tcm-2.20/src/dg/pullshapecmd.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/dg/pullshapecmd.h	2002-08-01 12:43:11.000000000 +0200
@@ -0,0 +1,72 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1995, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _PULLSHAPECMD_H
+#define _PULLSHAPECMD_H
+
+#include "command.h"
+#include "polypoint.h"
+#include "dpoint.h"
+class NodeShape;
+class GShape;
+
+/// abstract command class for pulling a shape's tail.
+class PullShapeCmd: public Command {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	PullShapeCmd(GShape *shape, int direction);
+	///
+	void TrackMouse(TrackType aPhase, Point *anchorPoint,
+		Point *previousPoint, Point *nextPoint);
+	///
+	void Execute();
+	///
+	void UnExecute();
+protected:
+	///
+	NodeShape *shape;
+	/// coordinates of the fix point of the figure.
+	DPoint fixpoint;
+	/// coordinates of the position of the shape.
+	PolyPoint centre;
+	/// coordinates of the moving corner of the shape.
+	PolyPoint corner;
+	///
+	DPoint newEndPosition;
+	///
+	DPoint oldEndPosition;
+	///
+	int direction;
+	///
+	bool constrainX;
+	///
+	bool constrainY;
+	///
+	void CalcSize(const Point *p);
+	///
+	void Draw();
+	///
+	void Undraw() {
+		Draw();
+	}
+};
+#endif
diff -urN tcm-2.20/src/dg/shapeview.c tcm-2.20+TSQD.orig/src/dg/shapeview.c
--- tcm-2.20/src/dg/shapeview.c	2002-05-28 10:32:10.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/dg/shapeview.c	2004-07-23 15:55:54.000000000 +0200
@@ -382,7 +382,10 @@
 		shape->Draw();
 	if (shape->IsSelected())
 		SelectShape(shape);
-	if (shape->IsLine()) {
+//SQD-B4	if (shape->IsLine()) {
+//SQD-0
+	if (shape->IsLine() ) {
+//SQD-1
 		Line *line = (Line *)shape;
 		MultipleLines(line);
 	}
@@ -394,7 +397,10 @@
 	if (!check(shape))
 		return;
 	AddShapeRaw(shape);
-	if (shape->IsLine()) {
+//SQD-B4	if (shape->IsLine()) {
+//SQD-0
+	if (shape->IsLine() ) {
+//SQD-1
 		Line *line = (Line *)shape;
 		if (line->NrPoints() == 2)
 			MultipleLinesPosUpdate(line);
@@ -424,7 +430,12 @@
 	DeselectShape(shape);
 	if (shape->IsVisible())
 		shape->Undraw();
-	if (shape->IsLine()) {
+
+
+//SQD-B4	if (shape->IsLine()) {
+//SQD-0
+	if (shape->IsLine() ) {
+//SQD-1
 		Line *line = (Line *)shape;
 		MultipleLines(line);
 	}
@@ -435,7 +446,10 @@
 	if (!check(shape))
 		return;
 	RemoveShapeRaw(shape);
-	if (shape->IsLine()) {
+//SQD-B4	if (shape->IsLine()) {
+//SQD-0
+	if (shape->IsLine() ) {
+//SQD-1
 		Line *line = (Line *)shape;
 		if (line->NrPoints() == 2)
 			MultipleLinesPosUpdate(line);
diff -urN tcm-2.20/src/gl/instances.h tcm-2.20+TSQD.orig/src/gl/instances.h
--- tcm-2.20/src/gl/instances.h	2003-01-21 17:15:56.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/gl/instances.h	2004-07-23 16:33:17.000000000 +0200
@@ -1,95 +0,0 @@
-//------------------------------------------------------------------------------
-// 
-// This file is part of Toolkit for Conceptual Modeling (TCM).
-// (c) copyright 1997, Vrije Universiteit Amsterdam.
-// Author: Frank Dehne (frank@cs.vu.nl).
-//
-// TCM is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version. 
-// 
-// TCM is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with TCM; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-// 02111-1307, USA.
-//-----------------------------------------------------------------------------
-#ifndef __EDINSTANCES_H
-#define __EDINSTANCES_H
-
-#ifdef __GNUC__
-
-//GNU g++ does not implement a separate pass to instantiate template
-//functions and classes at this point; for this reason, it will not work,
-//for the most part, to declare your template functions in one file and
-//define them in another. The compiler will need to see the entire
-//definition of the function, and will generate a static copy of the
-//function in each file in which it is used.
-// 
-//g++ does not automatically instantiate templates defined in other
-//files. Because of this, code written for cfront will often produce
-//undefined symbol errors when compiled with g++. You need to tell g++
-//the file where they are defined.
-
-#include "assoclist.h"
-#include "lstring.h"
-#include "point.h"
-#include "dpoint.h"
-#include "textalign.h"
-#include "linestyle.h"
-#include "fillstyle.h"
-#include "xfont.h"
-#include "color.h"
-#include "readdirection.h"
-#include "mainwindow.h"
-#include <Xm/Xm.h>
-
-template <> void List<int>::clear() { empty(); }
-template <> void List<unsigned>::clear() { empty(); }
-template <> void List<long>::clear() { empty(); }
-template <> void List<unsigned long>::clear() { empty(); }
-template <> void List<char>::clear() { empty(); }
-template <> void List<float>::clear() { empty(); }
-template <> void List<double>::clear() { empty(); }
-template <> void List<bool>::clear() { empty(); }
-template <> void List<string>::clear() { empty(); }
-template <> void List<Point>::clear() { empty(); }
-template <> void List<Widget>::clear() { empty(); }
-template <> void List<TextAlign::Type>::clear() { empty(); }
-template <> void List<LineStyle::Type>::clear() { empty(); }
-template <> void List<FillStyle::Type>::clear() { empty(); }
-template <> void List<ReadDirection::Type>::clear() { empty(); }
-template <> void List<XFont *>::clear() { empty(); }
-
-template class List<int>;
-template class List<int *>;
-template class List<unsigned>;
-template class List<long>;
-template class List<unsigned long>;
-template class List<char>;
-template class List<float>;
-template class List<double>;
-template class List<bool>;
-template class List<Assoc *>;
-template class List<Point>;
-template class List<Point *>;
-template class List<DPoint *>;
-template class List<string *>;
-template class List<string>;
-template class List<Widget>;
-template class List<XFont *>;
-template class List<Color *>;
-template class List<MainWindow *>;
-template class List<List<string *> *>;
-template class List<List<Widget> *>;
-template class List<TextAlign::Type>;
-template class List<LineStyle::Type>;
-template class List<FillStyle::Type>;
-template class List<ReadDirection::Type>;
-#endif
-#endif
diff -urN tcm-2.20/src/gl/toolkit.c tcm-2.20+TSQD.orig/src/gl/toolkit.c
--- tcm-2.20/src/gl/toolkit.c	2003-01-09 15:52:46.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/gl/toolkit.c	2004-07-23 15:36:51.000000000 +0200
@@ -1,4 +1,4 @@
-///////////////////////////////////////////////////////////////////////////////
+	///////////////////////////////////////////////////////////////////////////////
 //
 // This file is part of Toolkit for Conceptual Modeling (TCM).
 // (c) copyright 1995, Vrije Universiteit Amsterdam.
@@ -53,7 +53,7 @@
 	"Tool for Activity Diagrams",
 	"Tool for Entity Relationship Diagrams",
 	0};
- 
+
 const char Toolkit::STARTUP_TOOL_NAME[] = "TCM";
 
 const char *Toolkit::TOOL_NAMES[] = {
@@ -213,15 +213,15 @@
 	"COLOR-X Event Diagram",
 	"This tool is for UML static structure diagrams (SSDs)",
 	"Tool for UML Collaboration Diagrams.", // TCBD
-	"Not yet implemented.",		// TSQD
+	"Tool for UML Sequence Diagrams",		// TSQD
 	"Tool for UML Component Diagrams.", // TCPD
 	"Tool for UML Deployment Diagrams.",		// TDPD
 	"This tool is for UML use-case diagrams.",	// TUCD
-	"This tool is for UML (and Statemate) state charts.",		// TSCD
+	"This tool is for UML (and Stat	emate) state charts.",		// TSCD
 	"This tool is for UML activity diagrams.",	// TATD
 	"This tool is for entity relationship diagrams (ERDs)", // TESD
 	0};
- 
+
 
 bool Toolkit::TableEditor(int tool) {
 	return (tool == GT || tool == FET || tool == TDT || tool == TUT);
@@ -266,5 +266,3 @@
 bool Toolkit::EditorWithModelChecker(int tool) {
         return STD == tool || SCD == tool || ATD == tool ;
 }
-
-
diff -urN tcm-2.20/src/gl/toolkit.h tcm-2.20+TSQD.orig/src/gl/toolkit.h
--- tcm-2.20/src/gl/toolkit.h	2001-10-06 23:11:01.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/gl/toolkit.h	2004-07-23 15:36:42.000000000 +0200
@@ -30,7 +30,7 @@
 public:
 	/// The application (toolkit) name.
 	static const char TOOLKIT_NAME[];
- 
+
 	// Note: the order of the values is important for the lists of titles,
 	// document types and sufixes !!!
 	/// Definitions of the different editors (tools) that are implemented.
@@ -52,7 +52,7 @@
 	// EFD = Data and Event Flow Diagram (was Data and Control F.D. resp. DEFD).
 		EFD,
 	// SND = System Network Diagram (JSD).
-		SND, 
+		SND,
 	// GT = Generic Tables
 		GT,
 	// TDT = Transaction decomposition table.
@@ -62,7 +62,7 @@
 	// FET = Function entity-type table.
 		FET, 
 	// GTT = Generic Textual Trees
-		GTT, 
+		GTT,
 	// FDT = Function Refinement Tree (was Function Decomposition Tree).
 		FDT,
 	// T = Text
@@ -117,31 +117,31 @@
 	/// tool is diagram editor in which edges can connect to edges
 	static bool EditorWithInterEdgeConnections(int tool);
 
-	/// tool is diagram editor with model checking facilities   
-        static bool EditorWithModelChecker(int tool); 
+	/// tool is diagram editor with model checking facilities
+        static bool EditorWithModelChecker(int tool);
 
 	/// The name (in upper case) of the startup tool.
 	static const char STARTUP_TOOL_NAME[];
 
 	/// Window titles for the different tools.
-	static const char* TOOL_TITLES[]; 
- 
+	static const char* TOOL_TITLES[];
+
 	/// Short names (in upper case) of the editing tools.
-	static const char* TOOL_NAMES[]; 
+	static const char* TOOL_NAMES[];
 
 	/// Names of the tool executables.
-	static const char* EXECUTABLE_NAMES[]; 
+	static const char* EXECUTABLE_NAMES[];
 
 	/// The full names of the document types.
-	static const char* DOCUMENT_TYPES[]; 
- 
-	/// Document name suffixes. 
-	static const char* DOCUMENT_SUFFIXES[]; 
+	static const char* DOCUMENT_TYPES[];
+
+	/// Document name suffixes.
+	static const char* DOCUMENT_SUFFIXES[];
 
 	/// Default document name.
-	static const char DOCUMENT_DEFAULT[]; 
+	static const char DOCUMENT_DEFAULT[];
 
 	/// The help info of the document types.
-	static const char* DOCUMENT_TYPES_INFO[]; 
+	static const char* DOCUMENT_TYPES_INFO[];
 };
 #endif
diff -urN tcm-2.20/src/sd/bv/adsedgelabel.c tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.c
--- tcm-2.20/src/sd/bv/adsedgelabel.c	2003-01-21 17:14:08.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1804 +0,0 @@
-#define yy_create_buffer adsedgelabel_create_buffer
-#define yy_delete_buffer adsedgelabel_delete_buffer
-#define yy_scan_buffer adsedgelabel_scan_buffer
-#define yy_scan_string adsedgelabel_scan_string
-#define yy_scan_bytes adsedgelabel_scan_bytes
-#define yy_flex_debug adsedgelabel_flex_debug
-#define yy_init_buffer adsedgelabel_init_buffer
-#define yy_flush_buffer adsedgelabel_flush_buffer
-#define yy_load_buffer_state adsedgelabel_load_buffer_state
-#define yy_switch_to_buffer adsedgelabel_switch_to_buffer
-#define yyin adsedgelabelin
-#define yyleng adsedgelabelleng
-#define yylex adsedgelabellex
-#define yyout adsedgelabelout
-#define yyrestart adsedgelabelrestart
-#define yytext adsedgelabeltext
-
-#line 19 "adsedgelabel.c"
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header$
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-
-#define yywrap() 1
-#define YY_SKIP_YYWRAP
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 40
-#define YY_END_OF_BUFFER 41
-static yyconst short int yy_accept[82] =
-    {   0,
-        0,    0,   41,   40,   39,   21,   19,   40,   16,    3,
-        4,   14,   12,   13,   15,   36,   20,   10,    7,   11,
-       37,   37,    1,    2,   37,   28,   37,   22,   24,   26,
-       37,   37,   17,   18,   39,    8,    0,   36,    5,    9,
-        6,    0,   37,   30,   37,   37,   37,   37,   37,   37,
-       37,   37,   37,   38,   37,   37,   37,   37,   37,   37,
-       37,   37,   37,   37,   29,   32,   37,   37,   37,   35,
-       31,   34,   33,   23,   37,   37,   37,   37,   25,   27,
-        0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    5,    6,    1,    1,    1,    7,    1,    8,
-        9,   10,   11,    1,   12,    1,   13,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,   15,    1,   16,
-       17,   18,    1,    1,   19,   19,   19,   19,   19,   19,
-       19,   19,   20,   19,   19,   19,   19,   21,   19,   19,
-       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
-       22,    1,   23,    1,   24,    1,   25,   19,   26,   27,
-
-       28,   29,   19,   30,   31,   19,   19,   32,   33,   34,
-       35,   19,   19,   36,   37,   38,   39,   19,   40,   19,
-       41,   19,    1,   42,    1,   43,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[44] =
-    {   0,
-        1,    1,    2,    3,    1,    1,    1,    2,    2,    1,
-        1,    1,    1,    3,    1,    1,    1,    1,    3,    3,
-        3,    1,    1,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    2,    1
-    } ;
-
-static yyconst short int yy_base[84] =
-    {   0,
-        0,    0,  106,  219,   42,  219,   87,    0,  219,  219,
-      219,  219,  219,   43,  219,   88,  219,   31,  219,   83,
-       46,   47,  219,  219,   48,   49,   52,   54,   55,   57,
-       56,   58,  219,  219,   63,  219,   63,   52,  219,  219,
-      219,   59,   86,   87,   89,   90,   91,   93,   92,   94,
-       97,   95,  101,   58,  118,   99,  120,  129,  131,  133,
-      134,  135,  137,  136,  143,  145,  150,  152,  160,  162,
-      169,  171,  173,  174,  175,  177,  176,  178,  181,  184,
-      219,  215,   54
-    } ;
-
-static yyconst short int yy_def[84] =
-    {   0,
-       81,    1,   81,   81,   81,   81,   81,   82,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       83,   83,   81,   81,   83,   83,   83,   83,   83,   83,
-       83,   83,   81,   81,   81,   81,   82,   81,   81,   81,
-       81,   83,   83,   83,   83,   83,   83,   83,   83,   83,
-       83,   83,   83,   82,   83,   83,   83,   83,   83,   83,
-       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
-       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
-        0,   81,   81
-    } ;
-
-static yyconst short int yy_nxt[263] =
-    {   0,
-        4,    5,    6,    5,    7,    8,    9,   10,   11,   12,
-       13,   14,   15,   16,   17,   18,   19,   20,   21,   22,
-       21,   23,   24,    4,   25,   21,   26,   27,   21,   28,
-       21,   21,   29,   21,   21,   21,   30,   31,   21,   32,
-       21,   33,   34,   35,   35,   35,   35,   39,   40,   42,
-       42,   42,   42,   35,   35,   42,   43,   42,   42,   42,
-       42,   42,   81,   54,   35,   38,   35,   44,   54,   42,
-       42,   42,   42,   46,   35,   42,   45,   42,   42,   42,
-       42,   42,   81,   47,   50,   49,   51,   53,   48,   42,
-       42,   52,   42,   42,   42,   42,   42,   42,   42,   41,
-
-       42,   38,   42,   36,   42,   81,   81,   81,   81,   42,
-       42,   81,   42,   42,   42,   42,   42,   42,   42,   60,
-       42,   42,   42,   42,   42,   59,   55,   57,   63,   61,
-       56,   58,   42,   62,   42,   65,   42,   42,   42,   42,
-       42,   42,   81,   42,   81,   64,   42,   66,   42,   81,
-       81,   81,   42,   42,   42,   42,   42,   42,   42,   42,
-       42,   70,   71,   42,   67,   42,   42,   69,   42,   68,
-       72,   73,   42,   42,   42,   42,   42,   42,   42,   42,
-       42,   42,   81,   42,   42,   42,   74,   42,   81,   75,
-       81,   81,   42,   76,   42,   81,   42,   42,   42,   42,
-
-       42,   42,   77,   78,   42,   81,   81,   42,   81,   81,
-       81,   81,   79,   81,   80,   37,   81,   37,    3,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81
-    } ;
-
-static yyconst short int yy_chk[263] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    5,   14,    5,   14,   18,   18,   21,
-       22,   25,   26,    5,   14,   27,   83,   28,   29,   31,
-       30,   32,   42,   54,   35,   38,   35,   22,   37,   21,
-       22,   25,   26,   26,   35,   27,   25,   28,   29,   31,
-       30,   32,   42,   27,   30,   29,   31,   32,   28,   43,
-       44,   31,   45,   46,   47,   49,   48,   50,   52,   20,
-
-       51,   16,   56,    7,   53,    3,    0,    0,    0,   43,
-       44,    0,   45,   46,   47,   49,   48,   50,   52,   50,
-       51,   55,   56,   57,   53,   49,   45,   47,   53,   51,
-       46,   48,   58,   52,   59,   56,   60,   61,   62,   64,
-       63,   55,    0,   57,    0,   55,   65,   57,   66,    0,
-        0,    0,   58,   67,   59,   68,   60,   61,   62,   64,
-       63,   61,   62,   69,   58,   70,   65,   60,   66,   59,
-       63,   64,   71,   67,   72,   68,   73,   74,   75,   77,
-       76,   78,    0,   69,   79,   70,   67,   80,    0,   68,
-        0,    0,   71,   69,   72,    0,   73,   74,   75,   77,
-
-       76,   78,   75,   76,   79,    0,    0,   80,    0,    0,
-        0,    0,   77,    0,   78,   82,    0,   82,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
-       81,   81
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "adsedgelabel.l"
-#define INITIAL 0
-#line 2 "adsedgelabel.l"
-#include <stdio.h>
-#include <string.h>
-#include "adsedgelabel.tab.h"
-#include "adsedgelabelparse.h"
-
-char adsedgelabel_errormsg[1024] = "";
-char adsedgelabel_constraint[1024] = "";
-#line 476 "adsedgelabel.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 16 "adsedgelabel.l"
-
-#line 629 "adsedgelabel.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 82 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 219 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 17 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "[");return(OPENB);}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 18 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "]");return(CLOSEB);}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 19 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "(");return(OPEN);}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 20 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, ")");return(CLOSE);}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 21 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "<=");return(LEQ);}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 22 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, ">=");return(GEQ);}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 23 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "=");return(EQ);}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 24 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "!=");return(NEQ);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 25 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "<>");return(NEQ);}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 26 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "<");return(LT);}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 27 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, ">");return(GT);}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 28 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "+");return(PLUS);}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 29 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "-");return(MINUS);}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 30 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "*");return(TIMES);}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 31 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "/");return(DIV);}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 32 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "&");return(AND);}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 33 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "|");return(OR);}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 34 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "~");return(NOT);}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 35 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "~");return(NOT);}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 36 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, ":");return(COLON);}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 37 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "\n");return NL;}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 38 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "h");return HOURS;}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 39 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "h");return HOURS;}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 40 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "m");return MINUTES;}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 41 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "m");return MINUTES;}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 42 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "s");return SECONDS;}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 43 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "s");return SECONDS;}
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 44 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "d");return DAYS;}
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 45 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "d");return DAYS;}
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 46 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "IN");return IN;}
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 47 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "true");return(TRUE);}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 48 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "else");return(ELSE);}
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 49 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "after");return(AFTERTOKEN);}
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 50 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "when");return(WHENTOKEN);}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 51 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, "time");return(TIME);}
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 52 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, adsedgelabeltext); return INTEGER;}
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 53 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, adsedgelabeltext); return IDENTIFIER;}
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 54 "adsedgelabel.l"
-{adsedgelabellval.str_ptr=adsedgelabeltext;strcat(adsedgelabel_constraint, adsedgelabeltext);return(QUOTE);}
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 55 "adsedgelabel.l"
-{}
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 57 "adsedgelabel.l"
-ECHO;
-	YY_BREAK
-#line 912 "adsedgelabel.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 82 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 82 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 81);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 57 "adsedgelabel.l"
-
-
-
-int adsedgelabelwrap() {
-	return(1);
-}
-
-int adsedgelabelerror(char *s) {
-        strcpy(adsedgelabel_errormsg, s);
-        return 0;
-}
-
diff -urN tcm-2.20/src/sd/bv/adsedgelabelevaluation.c tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.c
--- tcm-2.20/src/sd/bv/adsedgelabelevaluation.c	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1688 +0,0 @@
-#define yy_create_buffer adsedgelabelevaluation_create_buffer
-#define yy_delete_buffer adsedgelabelevaluation_delete_buffer
-#define yy_scan_buffer adsedgelabelevaluation_scan_buffer
-#define yy_scan_string adsedgelabelevaluation_scan_string
-#define yy_scan_bytes adsedgelabelevaluation_scan_bytes
-#define yy_flex_debug adsedgelabelevaluation_flex_debug
-#define yy_init_buffer adsedgelabelevaluation_init_buffer
-#define yy_flush_buffer adsedgelabelevaluation_flush_buffer
-#define yy_load_buffer_state adsedgelabelevaluation_load_buffer_state
-#define yy_switch_to_buffer adsedgelabelevaluation_switch_to_buffer
-#define yyin adsedgelabelevaluationin
-#define yyleng adsedgelabelevaluationleng
-#define yylex adsedgelabelevaluationlex
-#define yyout adsedgelabelevaluationout
-#define yyrestart adsedgelabelevaluationrestart
-#define yytext adsedgelabelevaluationtext
-#define yywrap adsedgelabelevaluationwrap
-
-#line 20 "adsedgelabelevaluation.c"
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header$
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 27
-#define YY_END_OF_BUFFER 28
-static yyconst short int yy_accept[42] =
-    {   0,
-        0,    0,   28,   27,   26,   20,   19,   27,   16,    3,
-        4,   14,   12,   13,   15,   23,   10,    7,   11,   24,
-       24,    1,    2,   24,   17,   18,   26,    8,    0,   23,
-        5,    9,    6,    0,   24,   21,   24,   25,   24,   22,
-        0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    5,    6,    1,    1,    1,    7,    1,    8,
-        9,   10,   11,    1,   12,    1,   13,   14,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,    1,    1,   15,
-       16,   17,    1,    1,   18,   18,   18,   18,   18,   18,
-       18,   18,   19,   18,   18,   18,   18,   20,   18,   18,
-       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
-       21,    1,   22,    1,   23,    1,   18,   18,   18,   18,
-
-       24,   18,   18,   18,   18,   18,   18,   18,   18,   18,
-       18,   18,   18,   25,   18,   26,   27,   18,   18,   18,
-       18,   18,    1,   28,    1,   29,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[30] =
-    {   0,
-        1,    1,    2,    3,    1,    1,    1,    2,    2,    1,
-        1,    1,    1,    3,    1,    1,    1,    3,    3,    3,
-        1,    1,    3,    3,    3,    3,    3,    2,    1
-    } ;
-
-static yyconst short int yy_base[44] =
-    {   0,
-        0,    0,   61,   62,   28,   62,   43,    0,   62,   62,
-       62,   62,   62,   62,   62,   42,   17,   62,   39,   27,
-       31,   62,   62,   16,   62,   62,   35,   62,   47,   38,
-       62,   62,   62,   34,   29,   28,   20,   39,   22,   24,
-       62,   57,   40
-    } ;
-
-static yyconst short int yy_def[44] =
-    {   0,
-       41,    1,   41,   41,   41,   41,   41,   42,   41,   41,
-       41,   41,   41,   41,   41,   41,   41,   41,   41,   43,
-       43,   41,   41,   21,   41,   41,   41,   41,   42,   41,
-       41,   41,   41,   43,   21,   21,   21,   42,   21,   21,
-        0,   41,   41
-    } ;
-
-static yyconst short int yy_nxt[92] =
-    {   0,
-        4,    5,    6,    5,    7,    8,    9,   10,   11,   12,
-       13,   14,   15,   16,   17,   18,   19,   20,   21,   20,
-       22,   23,    4,   20,   20,   24,   20,   25,   26,   27,
-       34,   27,   31,   32,   34,   35,   27,   41,   27,   35,
-       37,   35,   35,   35,   38,   40,   39,   35,   35,   34,
-       36,   30,   38,   34,   33,   30,   41,   29,   28,   29,
-       41,    3,   41,   41,   41,   41,   41,   41,   41,   41,
-       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
-       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
-       41
-
-    } ;
-
-static yyconst short int yy_chk[92] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    5,
-       20,    5,   17,   17,   21,   24,   27,   34,   27,   37,
-       24,   39,   43,   40,   38,   39,   37,   36,   35,   20,
-       21,   30,   29,   21,   19,   16,   34,   42,    7,   42,
-        3,   41,   41,   41,   41,   41,   41,   41,   41,   41,
-       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
-       41,   41,   41,   41,   41,   41,   41,   41,   41,   41,
-       41
-
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "adsedgelabelevaluation.l"
-#define INITIAL 0
-#line 2 "adsedgelabelevaluation.l"
-#include <stdio.h>
-#include <string.h>
-#include "adsedgelabelevaluation.tab.h"
-#include "adsedgelabelevaluationparse.h"
-
-char adsedgelabelevaluation_errormsg[1024] = "";
-char adsedgelabelevaluation_constraint[1024] = "";
-
-#line 425 "adsedgelabelevaluation.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 17 "adsedgelabelevaluation.l"
-
-#line 578 "adsedgelabelevaluation.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 42 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 62 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 18 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(OPENB);}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 19 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(CLOSEB);}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 20 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(OPEN);}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 21 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(CLOSE);}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 22 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(LEQ);}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 23 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(GEQ);}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 24 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(EQ);}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 25 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(NEQ);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 26 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(NEQ);}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 27 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(LT);}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 28 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(GT);}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 29 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(PLUS);}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 30 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(MINUS);}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 31 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(TIMES);}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 32 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(DIV);}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 33 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(AND);}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 34 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(OR);}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 35 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(NOT);}
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 36 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(NOT);}
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 37 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return NL;}
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 38 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return IN;}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 39 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(TRUE);}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 40 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext; return INTEGER;}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 41 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return IDENTIFIER;}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 42 "adsedgelabelevaluation.l"
-{adsedgelabelevaluationlval.str=adsedgelabelevaluationtext;return(QUOTE);}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 43 "adsedgelabelevaluation.l"
-{}
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 45 "adsedgelabelevaluation.l"
-ECHO;
-	YY_BREAK
-#line 796 "adsedgelabelevaluation.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 42 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 42 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 41);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 45 "adsedgelabelevaluation.l"
-
-
-
-int adsedgelabelevaluationwrap() {
-	return(1);
-}
-
-int adsedgelabelevaluationerror(char *s) {
-        strcpy(adsedgelabelevaluation_errormsg, s);
-        return 0;
-}
-
diff -urN tcm-2.20/src/sd/bv/adsedgelabelevaluation.tab.c tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.tab.c
--- tcm-2.20/src/sd/bv/adsedgelabelevaluation.tab.c	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.tab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1160 +0,0 @@
-
-/*  A Bison parser, made from adsedgelabelevaluation.y
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse adsedgelabelevaluationparse
-#define yylex adsedgelabelevaluationlex
-#define yyerror adsedgelabelevaluationerror
-#define yylval adsedgelabelevaluationlval
-#define yychar adsedgelabelevaluationchar
-#define yydebug adsedgelabelevaluationdebug
-#define yynerrs adsedgelabelevaluationnerrs
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	OPENB	260
-#define	CLOSEB	261
-#define	NL	262
-#define	INTEGER	263
-#define	IDENTIFIER	264
-#define	TRUE	265
-#define	LEQ	266
-#define	GEQ	267
-#define	EQ	268
-#define	NEQ	269
-#define	GT	270
-#define	LT	271
-#define	MINUS	272
-#define	PLUS	273
-#define	OR	274
-#define	TIMES	275
-#define	DIV	276
-#define	AND	277
-#define	NEG	278
-#define	NOT	279
-#define	IN	280
-
-#line 1 "adsedgelabelevaluation.y"
-
-#include "adsedgelabelevaluationparse.h"
-#include <math.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#define YYERROR_VERBOSE 
-
-  int proptype[200];  /* should be initialised by caller */
-  char *propname[200];/* should be initialised by caller */
-  int boollist[200];/* should be initialised by caller */
-  int count;/* should be initialised by caller */
-  int isin; /* true if IN predicate is part of label */
-
-  int outcome; /* result */
-
-
-int isintexp,isstrexp;
-
-char temp[100];
-
-int GetBool(char *s, int t){
-  int i=0;
-  while (i<count){
-    if ((!strcmp(propname[i],s))&& (proptype[i]==t)) return boollist[i];
-    i++;
-  }
-  return -1;
-}
-
-
-
-#line 34 "adsedgelabelevaluation.y"
-typedef union{
-  int i;
-  char *str;
-} YYSTYPE;
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		44
-#define	YYFLAG		-32768
-#define	YYNTBASE	28
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 280 ? yytranslate[x] : 42)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,    27,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     6,     7,     9,    10,    14,    16,    18,    22,
-    24,    28,    30,    33,    37,    42,    44,    45,    49,    50,
-    53,    56,    58,    60,    62,    64,    66,    68,    70,    72,
-    73
-};
-
-static const short yyrhs[] = {    29,
-     0,    30,    31,    41,     0,     0,    10,     0,     0,     6,
-    32,     7,     0,    33,     0,    34,     0,    33,    20,    34,
-     0,    35,     0,    34,    23,    35,     0,    36,     0,    25,
-    35,     0,     4,    32,     5,     0,    26,     4,    10,     5,
-     0,    11,     0,     0,    10,    37,    38,     0,     0,    39,
-     9,     0,    40,     3,     0,    14,     0,    15,     0,    16,
-     0,    17,     0,    13,     0,    12,     0,    14,     0,    15,
-     0,     0,    22,    10,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    49,    52,    58,    59,    71,    72,    76,    87,    88,    96,
-    97,   105,   106,   107,   108,   111,   112,   116,   142,   143,
-   145,   149,   150,   151,   152,   153,   154,   159,   160,   166,
-   167
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","QUOTE",
-"OPEN","CLOSE","OPENB","CLOSEB","NL","INTEGER","IDENTIFIER","TRUE","LEQ","GEQ",
-"EQ","NEQ","GT","LT","MINUS","PLUS","OR","TIMES","DIV","AND","NEG","NOT","IN",
-"'^'","input","line","event","guard","pexp","orexp","andexp","literal","atomic",
-"@1","isexp","irel","srel","action", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    28,    29,    30,    30,    31,    31,    32,    33,    33,    34,
-    34,    35,    35,    35,    35,    36,    37,    36,    38,    38,
-    38,    39,    39,    39,    39,    39,    39,    40,    40,    41,
-    41
-};
-
-static const short yyr2[] = {     0,
-     1,     3,     0,     1,     0,     3,     1,     1,     3,     1,
-     3,     1,     2,     3,     4,     1,     0,     3,     0,     2,
-     2,     1,     1,     1,     1,     1,     1,     1,     1,     0,
-     2
-};
-
-static const short yydefact[] = {     3,
-     4,     1,     5,     0,    30,     0,    17,    16,     0,     0,
-     0,     7,     8,    10,    12,     0,     2,     0,    19,    13,
-     0,     6,     0,     0,    31,    14,    27,    26,    22,    23,
-    24,    25,    18,     0,     0,     0,     9,    11,    20,    21,
-    15,     0,     0,     0
-};
-
-static const short yydefgoto[] = {    42,
-     2,     3,     5,    11,    12,    13,    14,    15,    19,    33,
-    34,    35,    17
-};
-
-static const short yypact[] = {    -7,
--32768,-32768,    -2,    -4,   -20,    -4,-32768,-32768,    -4,     1,
-     8,   -12,    -6,-32768,-32768,     9,-32768,    13,    -3,-32768,
-    10,-32768,    -4,    -4,-32768,-32768,-32768,-32768,    20,    21,
--32768,-32768,-32768,    16,    23,    22,    -6,-32768,-32768,-32768,
--32768,    28,    29,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,    24,-32768,    11,    -8,-32768,-32768,-32768,
--32768,-32768,-32768
-};
-
-
-#define	YYLAST		34
-
-
-static const short yytable[] = {     6,
-    20,    16,     1,     4,    21,     7,     8,    23,    27,    28,
-    29,    30,    31,    32,    22,    38,    24,    26,    25,    36,
-     9,    10,   -28,   -29,    39,    40,    41,    43,    44,    18,
-     0,     0,     0,    37
-};
-
-static const short yycheck[] = {     4,
-     9,    22,    10,     6,     4,    10,    11,    20,    12,    13,
-    14,    15,    16,    17,     7,    24,    23,     5,    10,    10,
-    25,    26,     3,     3,     9,     3,     5,     0,     0,     6,
-    -1,    -1,    -1,    23
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/usr/lib/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 2:
-#line 52 "adsedgelabelevaluation.y"
-{if (yyvsp[-2].i>=0 && yyvsp[-1].i>=0) outcome= (yyvsp[-2].i) && (yyvsp[-1].i); else outcome=0;  ;
-    break;}
-case 3:
-#line 58 "adsedgelabelevaluation.y"
-{yyval.i=1;;
-    break;}
-case 4:
-#line 59 "adsedgelabelevaluation.y"
-{     
-                       int b;
-		       b=GetBool(yyvsp[0].str,EVENT);
-		       if (b>=0) yyval.i=b; 
-		       else {
-			 b=GetBool(yyvsp[0].str,SENDEVENT);
-			 if (b>=0) yyval.i=b; else yyval.i=-1;		      
-		       }
-                ;
-    break;}
-case 5:
-#line 71 "adsedgelabelevaluation.y"
-{yyval.i=1;;
-    break;}
-case 6:
-#line 72 "adsedgelabelevaluation.y"
-{if (yyvsp[-1].i >=0) yyval.i=yyvsp[-1].i;else yyval.i=1;;
-    break;}
-case 7:
-#line 76 "adsedgelabelevaluation.y"
-{yyval.i=yyvsp[0].i;;
-    break;}
-case 8:
-#line 87 "adsedgelabelevaluation.y"
-{yyval.i=yyvsp[0].i;;
-    break;}
-case 9:
-#line 89 "adsedgelabelevaluation.y"
-{ if ((yyvsp[0].i >= 0) && (yyvsp[-2].i>=0)) yyval.i=(yyvsp[0].i || yyvsp[-2].i);
-                           if ((yyvsp[0].i < 0)  && (yyvsp[-2].i>=0)) yyval.i=(yyvsp[-2].i);
-                           if ((yyvsp[0].i >= 0) && (yyvsp[-2].i < 0)) yyval.i=(yyvsp[0].i);
-                           if ((yyvsp[0].i < 0)   && (yyvsp[-2].i < 0)) yyval.i=-1;
-			 ;
-    break;}
-case 10:
-#line 96 "adsedgelabelevaluation.y"
-{yyval.i=yyvsp[0].i;;
-    break;}
-case 11:
-#line 98 "adsedgelabelevaluation.y"
-{ if ((yyvsp[0].i >= 0) && (yyvsp[-2].i>=0)) yyval.i=(yyvsp[0].i && yyvsp[-2].i);
-                           if ((yyvsp[0].i < 0)  && (yyvsp[-2].i>=0)) yyval.i=(yyvsp[-2].i);
-                           if ((yyvsp[0].i >= 0) && (yyvsp[-2].i < 0)) yyval.i=(yyvsp[0].i);
-                           if ((yyvsp[0].i < 0)   && (yyvsp[-2].i < 0)) yyval.i=-1;
-			 ;
-    break;}
-case 12:
-#line 105 "adsedgelabelevaluation.y"
-{if (yyvsp[0].i>=0) yyval.i=yyvsp[0].i;else yyval.i=-1;;
-    break;}
-case 13:
-#line 106 "adsedgelabelevaluation.y"
-{if (yyvsp[0].i>=0) yyval.i=(!yyvsp[0].i);else yyval.i=-1;if (isin) yyval.i=1;;
-    break;}
-case 14:
-#line 107 "adsedgelabelevaluation.y"
-{yyval.i=yyvsp[-1].i;;
-    break;}
-case 15:
-#line 108 "adsedgelabelevaluation.y"
-{yyval.i=1;isin=1; /* IN clause checked elsewhere */;
-    break;}
-case 16:
-#line 111 "adsedgelabelevaluation.y"
-{yyval.i=1;;
-    break;}
-case 17:
-#line 112 "adsedgelabelevaluation.y"
-{  
-			  strcpy(temp,yyvsp[0].str);
-                        ;
-    break;}
-case 18:
-#line 116 "adsedgelabelevaluation.y"
-{ 
-                           if (isintexp) {
-			     int b;
-			     strcpy(temp,yyvsp[-2].str);
-			     b=GetBool(temp,INT);
-			     if (b==-1) b=GetBool(temp,INTERNAL_INT);
-		             if (b>=0) yyval.i=b; else yyval.i=-1;
-			   }
-			   else if (isstrexp){
-			        int b;
-			        strcpy(temp,yyvsp[-2].str);
-				b=GetBool(temp,STRING);
-				if (b==-1) b=GetBool(temp,INTERNAL_STRING);
-		         	if (b>=0) yyval.i=b; else yyval.i=-1;		 
-			   }
-			   else{
-			     int b;
-			     b = GetBool(temp,PROP);
-			     if (b==-1) b=GetBool(temp,INTERNAL_PROP);
-			     if (b>=0) yyval.i=b; else {yyval.i=-1;}
-			   }
-
-;
-    break;}
-case 19:
-#line 142 "adsedgelabelevaluation.y"
-{isintexp=0;isstrexp=0;;
-    break;}
-case 20:
-#line 143 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[-1].str);
-			       isintexp =1;isstrexp=0;;
-    break;}
-case 21:
-#line 145 "adsedgelabelevaluation.y"
-{ strcpy(yyval.str,yyvsp[-1].str);
-                              isintexp=0;isstrexp=1;;
-    break;}
-case 22:
-#line 149 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 23:
-#line 150 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 24:
-#line 151 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 25:
-#line 152 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 26:
-#line 153 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 27:
-#line 154 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 28:
-#line 159 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 29:
-#line 160 "adsedgelabelevaluation.y"
-{strcpy(yyval.str,yyvsp[0].str);;
-    break;}
-case 30:
-#line 166 "adsedgelabelevaluation.y"
-{yyval.i=1;;
-    break;}
-case 31:
-#line 167 "adsedgelabelevaluation.y"
-{yyval.i=1;;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 169 "adsedgelabelevaluation.y"
-
-
-
-
-
-
diff -urN tcm-2.20/src/sd/bv/adsedgelabelevaluation.tab.h tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.tab.h
--- tcm-2.20/src/sd/bv/adsedgelabelevaluation.tab.h	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabelevaluation.tab.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-typedef union{
-  int i;
-  char *str;
-} YYSTYPE;
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	OPENB	260
-#define	CLOSEB	261
-#define	NL	262
-#define	INTEGER	263
-#define	IDENTIFIER	264
-#define	TRUE	265
-#define	LEQ	266
-#define	GEQ	267
-#define	EQ	268
-#define	NEQ	269
-#define	GT	270
-#define	LT	271
-#define	MINUS	272
-#define	PLUS	273
-#define	OR	274
-#define	TIMES	275
-#define	DIV	276
-#define	AND	277
-#define	NEG	278
-#define	NOT	279
-#define	IN	280
-
-
-extern YYSTYPE adsedgelabelevaluationlval;
diff -urN tcm-2.20/src/sd/bv/adsedgelabel.tab.c tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.tab.c
--- tcm-2.20/src/sd/bv/adsedgelabel.tab.c	2003-01-21 17:14:08.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.tab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1209 +0,0 @@
-
-/*  A Bison parser, made from adsedgelabel.y
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse adsedgelabelparse
-#define yylex adsedgelabellex
-#define yyerror adsedgelabelerror
-#define yylval adsedgelabellval
-#define yychar adsedgelabelchar
-#define yydebug adsedgelabeldebug
-#define yynerrs adsedgelabelnerrs
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	OPENB	260
-#define	CLOSEB	261
-#define	NL	262
-#define	DAYS	263
-#define	HOURS	264
-#define	MINUTES	265
-#define	SECONDS	266
-#define	TIME	267
-#define	COLON	268
-#define	WHENTOKEN	269
-#define	AFTERTOKEN	270
-#define	ELSE	271
-#define	TRUE	272
-#define	LEQ	273
-#define	GEQ	274
-#define	EQ	275
-#define	NEQ	276
-#define	GT	277
-#define	LT	278
-#define	IDENTIFIER	279
-#define	INTEGER	280
-#define	MINUS	281
-#define	PLUS	282
-#define	OR	283
-#define	TIMES	284
-#define	DIV	285
-#define	AND	286
-#define	NEG	287
-#define	NOT	288
-#define	IN	289
-
-#line 1 "adsedgelabel.y"
-
-#include "adsedgelabelparse.h"
-#include "adspropertytype.h"
-#include "adsclocktypes.h"
-#include <math.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-
- 
-
-
-
-
-
-/*
-typedef char *CHAR_PTR;
-#define YYSTYPE CHAR_PTR
-#define YYDEBUG 1
-*/
-
-
-
-/* variables for normal guards */
- int iprop; /* index on propname and proptype */
- int isintorstrexp; /* bool to check wether integer of string expression is meant */
- int ivar; /* index on varname and vartype */
- int indexin; /* index on in nodes */
- int notindexin; /* index on in nodes */
- int isvar; /* true iff variable occurs in edge label */
- int iselse; /* true iff else clause exists */
- char temp[100];
- char *propname[200];  /* name of prop */
- char *varname[100];    /* name of var */
- char *inname[100];    /* name of in nodes */
- char *notinname[100];    /* name of in nodes */
- enum PropType proptype[200];
- enum PropType vartype[200];
-
- 
-/* variables for clock constraints */
- int timetype; /* h/s/m */
- int isclock;  
- int iclock;  /* index on clockconstraint, clockconstrainttype and clocktype */
- int clockconstraint[200]; /* amount */
- enum PropType clockconstrainttype[200];/*,  after, when (mod) */
- enum ClockType clocktype[200];  /* h/s/m  */
-
-/* variables for send actions */
- int hasaction; /* true iff action clause exists */
- char *sendeventname;
- int broadcast;  /* is the action event also directed to the environment? 1= system+environment, 0= only system */
-
-
-
-#line 61 "adsedgelabel.y"
-typedef union  {
-  char *str_ptr;
-      } YYSTYPE;
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		80
-#define	YYFLAG		-32768
-#define	YYNTBASE	37
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 289 ? yytranslate[x] : 54)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,    36,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-    27,    28,    29,    30,    31,    32,    33,    34,    35
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     6,     7,     9,    11,    17,    18,    20,    22,
-    24,    26,    27,    31,    32,    40,    41,    54,    55,    69,
-    70,    79,    80,    82,    84,    88,    92,    95,    99,   101,
-   102,   106,   107,   110,   113,   115,   117,   119,   121,   123,
-   125,   127,   129,   130
-};
-
-static const short yyrhs[] = {    38,
-     0,    39,    42,    53,     0,     0,    40,     0,    25,     0,
-    16,     4,    26,    41,     5,     0,     0,    10,     0,    11,
-     0,    12,     0,     9,     0,     0,     6,    47,     7,     0,
-     0,     6,    35,     4,    25,    43,     5,     7,     0,     0,
-     6,    34,     4,     4,    35,     4,    25,    44,     5,     5,
-     5,     7,     0,     0,     6,    34,     4,     4,    34,    35,
-     4,    25,    45,     5,     5,     5,     7,     0,     0,     6,
-    34,    35,     4,    25,    46,     5,     7,     0,     0,    17,
-     0,    48,     0,    47,    29,    47,     0,    47,    32,    47,
-     0,    34,    47,     0,     4,    47,     5,     0,    18,     0,
-     0,    25,    49,    50,     0,     0,    51,    26,     0,    52,
-     3,     0,    21,     0,    22,     0,    23,     0,    24,     0,
-    20,     0,    19,     0,    21,     0,    22,     0,     0,    31,
-    25,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    79,    82,    88,    89,    90,   100,   111,   112,   113,   114,
-   115,   120,   121,   122,   126,   127,   131,   132,   136,   137,
-   141,   145,   145,   146,   147,   148,   149,   150,   156,   157,
-   163,   182,   183,   189,   197,   198,   199,   200,   201,   202,
-   207,   208,   212,   216
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","QUOTE",
-"OPEN","CLOSE","OPENB","CLOSEB","NL","DAYS","HOURS","MINUTES","SECONDS","TIME",
-"COLON","WHENTOKEN","AFTERTOKEN","ELSE","TRUE","LEQ","GEQ","EQ","NEQ","GT","LT",
-"IDENTIFIER","INTEGER","MINUS","PLUS","OR","TIMES","DIV","AND","NEG","NOT","IN",
-"'^'","input","line","event","time","type","guard","@1","@2","@3","@4","pexp",
-"atomic","@5","isexp","irel","srel","action", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    37,    38,    39,    39,    39,    40,    41,    41,    41,    41,
-    41,    42,    42,    43,    42,    44,    42,    45,    42,    46,
-    42,    47,    47,    47,    47,    47,    47,    47,    48,    49,
-    48,    50,    50,    50,    51,    51,    51,    51,    51,    51,
-    52,    52,    53,    53
-};
-
-static const short yyr2[] = {     0,
-     1,     3,     0,     1,     1,     5,     0,     1,     1,     1,
-     1,     0,     3,     0,     7,     0,    12,     0,    13,     0,
-     8,     0,     1,     1,     3,     3,     2,     3,     1,     0,
-     3,     0,     2,     2,     1,     1,     1,     1,     1,     1,
-     1,     1,     0,     2
-};
-
-static const short yydefact[] = {     3,
-     0,     5,     1,    12,     4,     0,    22,    43,     7,    22,
-    23,    29,    30,    22,     0,     0,    24,     0,     2,    11,
-     8,     9,    10,     0,    22,     0,    32,    22,     0,    27,
-     0,    13,    22,    22,    44,     6,    28,    40,    39,    35,
-    36,    37,    38,    31,     0,     0,    22,     0,    14,    25,
-    26,    33,    34,    22,     0,    20,     0,     0,     0,     0,
-     0,     0,    16,     0,    15,    18,     0,    21,     0,     0,
-     0,     0,     0,     0,     0,    17,    19,     0,     0,     0
-};
-
-static const short yydefgoto[] = {    78,
-     3,     4,     5,    24,     8,    57,    67,    69,    60,    26,
-    17,    27,    44,    45,    46,    19
-};
-
-static const short yypact[] = {   -14,
-     0,-32768,-32768,     2,-32768,   -21,    -3,   -25,    70,    24,
--32768,-32768,-32768,    -1,     5,    28,-32768,   -15,-32768,-32768,
--32768,-32768,-32768,     7,    24,    35,    51,    44,     9,-32768,
-    -6,-32768,    24,    24,-32768,-32768,-32768,-32768,-32768,    17,
-    18,-32768,-32768,-32768,     3,    27,    19,    20,-32768,    11,
--32768,-32768,-32768,    21,    46,-32768,    47,    55,    26,    58,
-    59,    40,-32768,    61,-32768,-32768,    71,-32768,    72,    78,
-    79,    80,    81,    82,    83,-32768,-32768,    87,    88,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -7,
--32768,-32768,-32768,-32768,-32768,-32768
-};
-
-
-#define	YYLAST		90
-
-
-static const short yytable[] = {    16,
-    10,     1,    28,     6,     9,    18,    30,     7,    31,    35,
-     2,    36,    48,    11,    12,    11,    12,    30,    49,   -41,
-   -42,    13,    10,    13,    10,    50,    51,    10,    52,    53,
-    14,    15,    25,    29,    32,    11,    12,    11,    12,    37,
-    11,    12,    34,    13,    56,    13,    30,    47,    13,    59,
-    63,    61,    54,    55,    25,    58,    33,    25,    62,    34,
-    11,    12,    64,    33,    66,    65,    34,    68,    13,    38,
-    39,    40,    41,    42,    43,    70,    71,    25,    20,    21,
-    22,    23,    72,    73,    74,    75,    79,    80,    76,    77
-};
-
-static const short yycheck[] = {     7,
-     4,    16,     4,     4,    26,    31,    14,     6,     4,    25,
-    25,     5,     4,    17,    18,    17,    18,    25,    25,     3,
-     3,    25,     4,    25,     4,    33,    34,     4,    26,     3,
-    34,    35,    34,    35,     7,    17,    18,    17,    18,     5,
-    17,    18,    32,    25,    25,    25,    54,     4,    25,     4,
-    25,     5,    34,    35,    34,    35,    29,    34,     4,    32,
-    17,    18,     5,    29,    25,     7,    32,     7,    25,    19,
-    20,    21,    22,    23,    24,     5,     5,    34,     9,    10,
-    11,    12,     5,     5,     5,     5,     0,     0,     7,     7
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/usr/lib/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 5:
-#line 90 "adsedgelabel.y"
-{	 
-                         proptype[iprop]= EV_FROM_ENV; /* later it will be changed for EV_INT if we detect that it is
-							  sent as the action of some transition */
-                         propname[iprop]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-			 strcpy(propname[iprop],yyvsp[0].str_ptr);
-                         iprop++;
-
-;
-    break;}
-case 6:
-#line 100 "adsedgelabel.y"
-{
-    int amount; 
-    isclock=1;
-    clockconstrainttype[iclock]=AFTER;
-    amount=strtol(yyvsp[-2].str_ptr,NULL,10);
-    clockconstraint[iclock] = amount;
-    clocktype[iclock]=timetype;
-    iclock++;
-;
-    break;}
-case 7:
-#line 111 "adsedgelabel.y"
-{timetype=SECOND;;
-    break;}
-case 8:
-#line 112 "adsedgelabel.y"
-{timetype=HOUR;;
-    break;}
-case 9:
-#line 113 "adsedgelabel.y"
-{timetype=MINUTE;;
-    break;}
-case 10:
-#line 114 "adsedgelabel.y"
-{timetype=SECOND;;
-    break;}
-case 11:
-#line 115 "adsedgelabel.y"
-{timetype=DAY;;
-    break;}
-case 14:
-#line 122 "adsedgelabel.y"
-{
-                          inname[indexin]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-                          strcpy(inname[indexin],yyvsp[0].str_ptr);
-                          indexin++;
-           ;
-    break;}
-case 16:
-#line 127 "adsedgelabel.y"
-{
-                          notinname[notindexin]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-                          strcpy(notinname[notindexin],yyvsp[0].str_ptr);
-                          notindexin++;
-           ;
-    break;}
-case 18:
-#line 132 "adsedgelabel.y"
-{
-                          inname[indexin]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-                          strcpy(inname[indexin],yyvsp[0].str_ptr);
-                          indexin++;
-           ;
-    break;}
-case 20:
-#line 137 "adsedgelabel.y"
-{
-                          notinname[notindexin]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-                          strcpy(notinname[notindexin],yyvsp[0].str_ptr);
-                          notindexin++;
-           ;
-    break;}
-case 23:
-#line 145 "adsedgelabel.y"
-{iselse=1;;
-    break;}
-case 24:
-#line 146 "adsedgelabel.y"
-{;
-    break;}
-case 29:
-#line 156 "adsedgelabel.y"
-{isvar=0;;
-    break;}
-case 30:
-#line 157 "adsedgelabel.y"
-{ varname[ivar]= (char *)malloc (strlen(yyvsp[0].str_ptr)+1);
-			  strcpy(varname[ivar],yyvsp[0].str_ptr);;
-			  strcpy(temp,yyvsp[0].str_ptr);
-                          isvar=1;
-                        ;
-    break;}
-case 31:
-#line 163 "adsedgelabel.y"
-{ char name[100];
-			  if (!isintorstrexp) {
-			             strcpy(name,temp);
-				     proptype[iprop]= PROP;
-                                     if (isvar) {
-                                         vartype[ivar]=PROP;	 
-                                         ivar++;
-                                     };
-			  }
-			  else 
-			   { strcpy(name,yyvsp[-2].str_ptr); 
-			 }
-			 propname[iprop]= (char *)malloc (strlen(name)+1);
-			 strcpy(propname[iprop],name);
-			 iprop++;
-;
-    break;}
-case 32:
-#line 182 "adsedgelabel.y"
-{isintorstrexp=0;;
-    break;}
-case 33:
-#line 183 "adsedgelabel.y"
-{
-      			       proptype[iprop]= INT;
-                               if (isvar) {vartype[ivar]=INT;
-                                     ivar++;
-                               };
-			       isintorstrexp =1;;
-    break;}
-case 34:
-#line 189 "adsedgelabel.y"
-{ 
-        		       proptype[iprop]= STRING;
-                               if (isvar) {vartype[ivar]= STRING;
-                                           ivar++;};
-	
-                               isintorstrexp=1;;
-    break;}
-case 43:
-#line 212 "adsedgelabel.y"
-{hasaction=0; broadcast= 0;;
-    break;}
-case 44:
-#line 216 "adsedgelabel.y"
-{    hasaction= 1;
-	              if (strncmp(yyvsp[0].str_ptr,"broadcast ",10)==0){
-			int lon= strlen(yyvsp[0].str_ptr)-10+1; /* -10 because of "broadcast ", +1 for the \0 */
-			int i;
-                          sendeventname= (char *) malloc (lon*sizeof(char)); 
-			  for (i=0; i< lon-1; i++)
-			       sendeventname[i]= yyvsp[0].str_ptr[i+10];
-			  sendeventname[i]= '\0';
-			  broadcast= 1;
-                      }
-		      else{
-			  broadcast= 0;
-	                  sendeventname= (char *)malloc ((strlen(yyvsp[0].str_ptr)+1)*sizeof(char));
-	                  strcpy(sendeventname,yyvsp[0].str_ptr);
-		      }
-                 ;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 233 "adsedgelabel.y"
-
-
-
diff -urN tcm-2.20/src/sd/bv/adsedgelabel.tab.h tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.tab.h
--- tcm-2.20/src/sd/bv/adsedgelabel.tab.h	2003-01-21 17:14:08.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsedgelabel.tab.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-typedef union  {
-  char *str_ptr;
-      } YYSTYPE;
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	OPENB	260
-#define	CLOSEB	261
-#define	NL	262
-#define	DAYS	263
-#define	HOURS	264
-#define	MINUTES	265
-#define	SECONDS	266
-#define	TIME	267
-#define	COLON	268
-#define	WHENTOKEN	269
-#define	AFTERTOKEN	270
-#define	ELSE	271
-#define	TRUE	272
-#define	LEQ	273
-#define	GEQ	274
-#define	EQ	275
-#define	NEQ	276
-#define	GT	277
-#define	LT	278
-#define	IDENTIFIER	279
-#define	INTEGER	280
-#define	MINUS	281
-#define	PLUS	282
-#define	OR	283
-#define	TIMES	284
-#define	DIV	285
-#define	AND	286
-#define	NEG	287
-#define	NOT	288
-#define	IN	289
-
-
-extern YYSTYPE adsedgelabellval;
diff -urN tcm-2.20/src/sd/bv/adsltlformula.c tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.c
--- tcm-2.20/src/sd/bv/adsltlformula.c	2003-01-21 17:14:10.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1706 +0,0 @@
-#define yy_create_buffer adsltlformula_create_buffer
-#define yy_delete_buffer adsltlformula_delete_buffer
-#define yy_scan_buffer adsltlformula_scan_buffer
-#define yy_scan_string adsltlformula_scan_string
-#define yy_scan_bytes adsltlformula_scan_bytes
-#define yy_flex_debug adsltlformula_flex_debug
-#define yy_init_buffer adsltlformula_init_buffer
-#define yy_flush_buffer adsltlformula_flush_buffer
-#define yy_load_buffer_state adsltlformula_load_buffer_state
-#define yy_switch_to_buffer adsltlformula_switch_to_buffer
-#define yyin adsltlformulain
-#define yyleng adsltlformulaleng
-#define yylex adsltlformulalex
-#define yyout adsltlformulaout
-#define yyrestart adsltlformularestart
-#define yytext adsltlformulatext
-
-#line 19 "adsltlformula.c"
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header$
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-
-#define yywrap() 1
-#define YY_SKIP_YYWRAP
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 26
-#define YY_END_OF_BUFFER 27
-static yyconst short int yy_accept[61] =
-    {   0,
-        0,    0,   27,   26,   25,    6,    3,    1,    2,   26,
-       26,   26,   26,   26,   10,   11,   26,   26,   12,   13,
-        4,    5,   25,    7,    0,   24,    0,   14,   16,   23,
-       15,   17,   23,   23,    9,   23,    8,   24,   22,    0,
-       22,   22,   22,   22,   22,    0,   22,   23,    0,   22,
-       22,   22,   22,   20,   21,   19,   22,   22,   18,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    4,    1,    1,    1,    1,    5,    1,    6,
-        7,    1,    1,    1,    8,    1,    1,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    1,    1,   10,
-        1,   11,    1,    1,   12,   13,   13,   13,   14,   15,
-       16,   13,   17,   13,   13,   18,   13,   19,   13,   13,
-       13,   20,   21,   22,   23,   13,   13,   24,   13,   13,
-        1,    1,    1,    1,   25,    1,   13,   13,   13,   13,
-
-       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
-       13,   13,    1,   26,    1,   27,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[28] =
-    {   0,
-        1,    1,    2,    1,    1,    1,    1,    2,    3,    1,
-        1,    4,    4,    4,    4,    4,    4,    4,    4,    4,
-        4,    4,    4,    4,    2,    1,    1
-    } ;
-
-static yyconst short int yy_base[70] =
-    {   0,
-        0,    0,  121,  151,   26,  151,  151,  151,  151,  109,
-      111,   27,   50,   73,   87,   16,   30,   17,   31,    0,
-      151,  151,   42,  151,  107,    0,    0,    0,    0,   38,
-        0,    0,   54,   29,   33,   36,  151,    0,   61,    0,
-       65,   75,   49,   63,   46,   84,   98,  102,  104,   96,
-       94,   59,   74,   95,   93,   72,  101,   76,   61,  151,
-      128,  131,   67,  133,  135,  138,  141,  143,  146
-    } ;
-
-static yyconst short int yy_def[70] =
-    {   0,
-       60,    1,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   61,   62,   61,   63,   63,   16,   17,   61,   19,
-       60,   60,   60,   60,   60,   64,   65,   65,   65,   66,
-       65,   65,   66,   33,   33,   33,   60,   64,   67,   68,
-       69,   69,   42,   42,   42,   67,   67,   68,   69,   42,
-       42,   42,   42,   42,   42,   42,   42,   42,   42,    0,
-       60,   60,   60,   60,   60,   60,   60,   60,   60
-    } ;
-
-static yyconst short int yy_nxt[179] =
-    {   0,
-        4,    5,    5,    6,    7,    8,    9,   10,    4,   11,
-        4,   12,   13,   14,   15,   16,   17,   13,   13,   13,
-       13,   18,   19,   20,    4,   21,   22,   23,   23,   26,
-       27,   27,   26,   60,   26,   30,   36,   26,   60,   27,
-       40,   28,   29,   23,   23,   40,   41,   43,   35,   44,
-       41,   26,   26,   41,   26,   60,   40,   26,   45,   54,
-       52,   40,   40,   46,   27,   27,   50,   49,   46,   50,
-       30,   42,   49,   27,   26,   26,   56,   49,   40,   50,
-       26,   50,   49,   50,   53,   46,   60,   31,   32,   49,
-       57,   60,   50,   59,   50,   51,   50,   26,   33,   49,
-
-       46,   27,   27,   34,   40,   46,   60,   55,   60,   40,
-       27,   60,   58,   50,   50,   50,   50,   37,   25,   24,
-       60,   50,   46,   60,   60,   60,   40,   60,   60,   27,
-       60,   27,   30,   60,   30,   38,   38,   39,   39,   41,
-       41,   41,   47,   47,   47,   48,   48,   50,   50,   50,
-        3,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60
-    } ;
-
-static yyconst short int yy_chk[179] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    5,    5,   12,
-       16,   16,   17,   19,   12,   18,   18,   17,   19,   16,
-       30,   12,   12,   23,   23,   30,   34,   34,   17,   35,
-       35,   12,   13,   36,   17,   19,   33,   13,   36,   45,
-       43,   33,   30,   39,   13,   13,   45,   41,   39,   43,
-       63,   33,   41,   13,   13,   14,   52,   42,   33,   52,
-       14,   59,   42,   44,   44,   39,   46,   14,   14,   41,
-       53,   46,   56,   58,   53,   42,   58,   14,   15,   42,
-
-       47,   15,   15,   15,   48,   47,   49,   51,   46,   48,
-       15,   49,   57,   55,   51,   54,   50,   25,   11,   10,
-        3,   57,   47,    0,    0,    0,   48,    0,   49,   61,
-        0,   61,   62,    0,   62,   64,   64,   65,   65,   66,
-       66,   66,   67,   67,   67,   68,   68,   69,   69,   69,
-       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
-       60,   60,   60,   60,   60,   60,   60,   60
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "adsltlformula.l"
-#define INITIAL 0
-#line 2 "adsltlformula.l"
-#include <stdio.h>
-#include <string.h>
-#include "adsltlformula.tab.h"
-#include "adsltlformulaparse.h"
-
-char adsltlformula_errormsg[1024] = "";
-char adsltlformula_constraint[1024] = "";
-#line 447 "adsltlformula.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 18 "adsltlformula.l"
-
-#line 600 "adsltlformula.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 61 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 151 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 19 "adsltlformula.l"
-{return(OPEN);}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 20 "adsltlformula.l"
-{return(CLOSE);}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 21 "adsltlformula.l"
-{return(AND);}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 22 "adsltlformula.l"
-{return(OR);}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 23 "adsltlformula.l"
-{return(NOT);}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 24 "adsltlformula.l"
-{return(NOT);}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 25 "adsltlformula.l"
-{return(IMPLIES);}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 26 "adsltlformula.l"
-{return(EQUIV);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 27 "adsltlformula.l"
-{return IN;}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 28 "adsltlformula.l"
-{return FUTURE;}
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 29 "adsltlformula.l"
-{return GLOBALLY;}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 30 "adsltlformula.l"
-{return UNTIL;}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 31 "adsltlformula.l"
-{return NEXT;} 
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 32 "adsltlformula.l"
-{return AF;}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 33 "adsltlformula.l"
-{return EF;}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 34 "adsltlformula.l"
-{return AG;}
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 35 "adsltlformula.l"
-{return EG;}
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 36 "adsltlformula.l"
-{return INITI;} 
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 37 "adsltlformula.l"
-{return FINAL;} 
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 38 "adsltlformula.l"
-{return(TRUE);} 
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 39 "adsltlformula.l"
-{return(FALSE);}
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 40 "adsltlformula.l"
-{adsltlformulalval.str_ptr=adsltlformulatext;return IDENTIFIER;}
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 41 "adsltlformula.l"
-{adsltlformulalval.str_ptr=adsltlformulatext;return IDENTIFIER;}
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 42 "adsltlformula.l"
-{adsltlformulalval.str_ptr=adsltlformulatext;return IDENTIFIER;}
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 43 "adsltlformula.l"
-{}
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 45 "adsltlformula.l"
-ECHO;
-	YY_BREAK
-#line 813 "adsltlformula.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 61 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 61 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 60);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 45 "adsltlformula.l"
-
-
-
-int adsltlformulawrap() {
-	return(1);
-}
-
-int adsltlformulaerror(char *s) {
-strcpy(adsltlformula_errormsg, s);
-printf("ERORORRORO:\t%s\n",s);
-        return 0;
-}
-
diff -urN tcm-2.20/src/sd/bv/adsltlformula.tab.c tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.tab.c
--- tcm-2.20/src/sd/bv/adsltlformula.tab.c	2003-01-21 17:14:10.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.tab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1165 +0,0 @@
-
-/*  A Bison parser, made from adsltlformula.y
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse adsltlformulaparse
-#define yylex adsltlformulalex
-#define yyerror adsltlformulaerror
-#define yylval adsltlformulalval
-#define yychar adsltlformulachar
-#define yydebug adsltlformuladebug
-#define yynerrs adsltlformulanerrs
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	NL	260
-#define	IDENTIFIER	261
-#define	COLON	262
-#define	TRUE	263
-#define	FALSE	264
-#define	LEQ	265
-#define	GEQ	266
-#define	EQ	267
-#define	NEQ	268
-#define	GT	269
-#define	LT	270
-#define	FUTURE	271
-#define	GLOBALLY	272
-#define	NEXT	273
-#define	UNTIL	274
-#define	IMPLIES	275
-#define	EQUIV	276
-#define	INITI	277
-#define	FINAL	278
-#define	AF	279
-#define	EG	280
-#define	AG	281
-#define	EF	282
-#define	OR	283
-#define	AND	284
-#define	NEG	285
-#define	NOT	286
-#define	IN	287
-
-#line 1 "adsltlformula.y"
-
-#include "adsltlformulaparse.h"
-#include <math.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-
- 
-  /* adapted from the nusmv ltl parser */
-
-
-
-  /*
-typedef char *CHAR_PTR;
-#define YYSTYPE CHAR_PTR
-#define YYDEBUG 1
-  */
-
-  char *ltlprop; /* the temporal property */
-  char *initial; /* predicate characterising initial configuration */
-  /*  char *final; */ /*predicate characterising final configuration */
-  int isfinal; /* true iff FINAL is part of requirement */
-
-  char *identifier[100];    /* name of var */
-  int identifier_count;
-
-  char *mycpy(char *text);
-  char *Mymalloc(unsigned size);
-  char *mystrconcat3(char *s1, char *s2, char *s3);
-  char *mystrconcat2(char *s1, char *s2);
-
-  extern char adsltlformulatext[];
-
-  int isltl; /* if true, then formula is ltl formula*/
-
-
-#line 47 "adsltlformula.y"
-typedef union  {
-  char *str_ptr;
-      } YYSTYPE;
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		49
-#define	YYFLAG		-32768
-#define	YYNTBASE	35
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 287 ? yytranslate[x] : 44)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,    34,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-    27,    28,    29,    30,    31,    32,    33
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     4,     6,     8,    10,    12,    17,    19,    21,
-    23,    27,    31,    33,    37,    39,    43,    45,    49,    52,
-    55,    58,    61,    64,    67,    70,    73,    77
-};
-
-static const short yyrhs[] = {    36,
-     0,    39,     0,     9,     0,    10,     0,    23,     0,    24,
-     0,    33,     4,    38,     5,     0,    38,     0,     7,     0,
-    40,     0,    39,    21,    40,     0,    39,    22,    40,     0,
-    41,     0,    40,    29,    41,     0,    42,     0,    41,    30,
-    42,     0,    43,     0,    42,    20,    43,     0,    32,    43,
-     0,    19,    43,     0,    18,    43,     0,    17,    43,     0,
-    28,    43,     0,    25,    43,     0,    27,    43,     0,    26,
-    43,     0,     4,    39,     5,     0,    37,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    58,    61,    67,    68,    69,    70,    71,    72,    77,    91,
-    92,    93,    95,    96,    98,    99,   101,   102,   104,   105,
-   106,   107,   108,   109,   110,   111,   112,   113
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","QUOTE",
-"OPEN","CLOSE","NL","IDENTIFIER","COLON","TRUE","FALSE","LEQ","GEQ","EQ","NEQ",
-"GT","LT","FUTURE","GLOBALLY","NEXT","UNTIL","IMPLIES","EQUIV","INITI","FINAL",
-"AF","EG","AG","EF","OR","AND","NEG","NOT","IN","'^'","input","line","simple_expr",
-"ident","ltlexpr","orexpr","andexpr","untilexpr","atomexpr", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    35,    36,    37,    37,    37,    37,    37,    37,    38,    39,
-    39,    39,    40,    40,    41,    41,    42,    42,    43,    43,
-    43,    43,    43,    43,    43,    43,    43,    43
-};
-
-static const short yyr2[] = {     0,
-     1,     1,     1,     1,     1,     1,     4,     1,     1,     1,
-     3,     3,     1,     3,     1,     3,     1,     3,     2,     2,
-     2,     2,     2,     2,     2,     2,     3,     1
-};
-
-static const short yydefact[] = {     0,
-     0,     9,     3,     4,     0,     0,     0,     5,     6,     0,
-     0,     0,     0,     0,     0,     1,    28,     8,     2,    10,
-    13,    15,    17,     0,    22,    21,    20,    24,    26,    25,
-    23,    19,     0,     0,     0,     0,     0,     0,    27,     0,
-    11,    12,    14,    16,    18,     7,     0,     0,     0
-};
-
-static const short yydefgoto[] = {    47,
-    16,    17,    18,    19,    20,    21,    22,    23
-};
-
-static const short yypact[] = {    11,
-    11,-32768,-32768,-32768,    11,    11,    11,-32768,-32768,    11,
-    11,    11,    11,    11,     9,-32768,-32768,-32768,   -18,   -15,
-   -14,    -3,-32768,     5,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,    12,    11,    11,    11,    11,    11,-32768,    17,
-   -15,   -15,   -14,    -3,-32768,-32768,    23,    24,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,-32768,    -8,    30,   -23,    -4,     3,    -5
-};
-
-
-#define	YYLAST		44
-
-
-static const short yytable[] = {    25,
-    26,    27,    34,    35,    28,    29,    30,    31,    32,    39,
-    41,    42,    33,    36,     1,    37,    38,     2,     2,     3,
-     4,    46,    48,    49,    40,    34,    35,     5,     6,     7,
-    24,    43,    45,     8,     9,    10,    11,    12,    13,    44,
-     0,     0,    14,    15
-};
-
-static const short yycheck[] = {     5,
-     6,     7,    21,    22,    10,    11,    12,    13,    14,     5,
-    34,    35,     4,    29,     4,    30,    20,     7,     7,     9,
-    10,     5,     0,     0,    33,    21,    22,    17,    18,    19,
-     1,    36,    38,    23,    24,    25,    26,    27,    28,    37,
-    -1,    -1,    32,    33
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/usr/lib/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 1:
-#line 58 "adsltlformula.y"
-{ltlprop=mycpy(yyvsp[0].str_ptr);;
-    break;}
-case 3:
-#line 67 "adsltlformula.y"
-{yyval.str_ptr=mycpy("TRUE");;
-    break;}
-case 4:
-#line 68 "adsltlformula.y"
-{yyval.str_ptr=mycpy("FALSE");;
-    break;}
-case 5:
-#line 69 "adsltlformula.y"
-{yyval.str_ptr=mycpy(initial);;
-    break;}
-case 6:
-#line 70 "adsltlformula.y"
-{yyval.str_ptr=mycpy("FINAL");isfinal=1;;
-    break;}
-case 7:
-#line 71 "adsltlformula.y"
-{ yyval.str_ptr=mystrconcat2(yyvsp[-1].str_ptr,">0");;
-    break;}
-case 8:
-#line 72 "adsltlformula.y"
-{yyval.str_ptr=yyvsp[0].str_ptr;;
-    break;}
-case 9:
-#line 77 "adsltlformula.y"
-{
-int i;
-yyval.str_ptr = mycpy(adsltlformulalval.str_ptr);
- i=strlen(yyval.str_ptr);
- while (i){
-   if (yyval.str_ptr[i-1]==' ') yyval.str_ptr[i-1]='_'; /* replace spaces by underscores for model checker */
-   if (yyval.str_ptr[i-1]=='-') yyval.str_ptr[i-1]='_'; /* replace dashes by underscores for model checker */
-   i--;
- }
- identifier[identifier_count]=mycpy(adsltlformulalval.str_ptr);
- identifier_count++; 
-;
-    break;}
-case 10:
-#line 91 "adsltlformula.y"
-{yyval.str_ptr=yyvsp[0].str_ptr;;
-    break;}
-case 11:
-#line 92 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3(yyvsp[-2].str_ptr," -> ",yyvsp[0].str_ptr);;
-    break;}
-case 12:
-#line 93 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3(yyvsp[-2].str_ptr," <-> ",yyvsp[0].str_ptr);;
-    break;}
-case 13:
-#line 95 "adsltlformula.y"
-{yyval.str_ptr = yyvsp[0].str_ptr;;
-    break;}
-case 14:
-#line 96 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3(yyvsp[-2].str_ptr," | ",yyvsp[0].str_ptr);;
-    break;}
-case 15:
-#line 98 "adsltlformula.y"
-{yyval.str_ptr=yyvsp[0].str_ptr;;
-    break;}
-case 16:
-#line 99 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3(yyvsp[-2].str_ptr," & ",yyvsp[0].str_ptr);;
-    break;}
-case 17:
-#line 101 "adsltlformula.y"
-{yyval.str_ptr=yyvsp[0].str_ptr;;
-    break;}
-case 18:
-#line 102 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3(yyvsp[-2].str_ptr," U ",yyvsp[0].str_ptr);;
-    break;}
-case 19:
-#line 104 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("! ",yyvsp[0].str_ptr);;
-    break;}
-case 20:
-#line 105 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("X ",yyvsp[0].str_ptr);;
-    break;}
-case 21:
-#line 106 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("G ",yyvsp[0].str_ptr);;
-    break;}
-case 22:
-#line 107 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("F ",yyvsp[0].str_ptr);;
-    break;}
-case 23:
-#line 108 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("EF ",yyvsp[0].str_ptr);isltl=0;;
-    break;}
-case 24:
-#line 109 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("AF ",yyvsp[0].str_ptr);isltl=0;;
-    break;}
-case 25:
-#line 110 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("AG ",yyvsp[0].str_ptr);isltl=0;;
-    break;}
-case 26:
-#line 111 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat2("EG ",yyvsp[0].str_ptr);isltl=0;;
-    break;}
-case 27:
-#line 112 "adsltlformula.y"
-{yyval.str_ptr = mystrconcat3("(",yyvsp[-1].str_ptr,")");;
-    break;}
-case 28:
-#line 113 "adsltlformula.y"
-{yyval.str_ptr = yyvsp[0].str_ptr;;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 122 "adsltlformula.y"
-
-char *mystrconcat2(char *s1, char *s2)
-{
-  char *ret;
-  int len;
-  len = strlen(s1);
-  len += strlen(s2);
-  ret = (char *)malloc(sizeof(char)*(len+1));
-  strcpy(ret,s1);
-  strcat(ret,s2);
-  return(ret);
-}
-;
-
-char *mystrconcat3(char *s1, char *s2, char *s3)
-{
-  char *ret;
-  int len;
-  len = strlen(s1);
-  len += strlen(s2);
-  len += strlen(s3);
-  ret = (char*)malloc(sizeof(char)*(len+3));
-  strcpy(ret,s1);
-  strcat(ret," ");
-  strcat(ret,s2);
-  strcat(ret," ");
-  strcat(ret,s3);
-  return(ret);
-}
-         
-
-char *mycpy(char *text)
-{
-  char *cptr;
-  cptr = (char *) Mymalloc(strlen(text) + 1);
-  strcpy(cptr, text);
-  return(cptr);
-}
- 
-char *Mymalloc(unsigned size)
-{
-  char *ret;
- 
-  ret = malloc(size);
-  if (ret == NULL) {
-    printf("malloc returns NULL\n");
-    exit(1);
-  }
-  return(ret);
-}  
-
diff -urN tcm-2.20/src/sd/bv/adsltlformula.tab.h tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.tab.h
--- tcm-2.20/src/sd/bv/adsltlformula.tab.h	2003-01-21 17:14:10.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsltlformula.tab.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-typedef union  {
-  char *str_ptr;
-      } YYSTYPE;
-#define	QUOTE	257
-#define	OPEN	258
-#define	CLOSE	259
-#define	NL	260
-#define	IDENTIFIER	261
-#define	COLON	262
-#define	TRUE	263
-#define	FALSE	264
-#define	LEQ	265
-#define	GEQ	266
-#define	EQ	267
-#define	NEQ	268
-#define	GT	269
-#define	LT	270
-#define	FUTURE	271
-#define	GLOBALLY	272
-#define	NEXT	273
-#define	UNTIL	274
-#define	IMPLIES	275
-#define	EQUIV	276
-#define	INITI	277
-#define	FINAL	278
-#define	AF	279
-#define	EG	280
-#define	AG	281
-#define	EF	282
-#define	OR	283
-#define	AND	284
-#define	NEG	285
-#define	NOT	286
-#define	IN	287
-
-
-extern YYSTYPE adsltlformulalval;
diff -urN tcm-2.20/src/sd/bv/adsmcoutput.c tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.c
--- tcm-2.20/src/sd/bv/adsmcoutput.c	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1639 +0,0 @@
-#define yy_create_buffer adsmcoutput_create_buffer
-#define yy_delete_buffer adsmcoutput_delete_buffer
-#define yy_scan_buffer adsmcoutput_scan_buffer
-#define yy_scan_string adsmcoutput_scan_string
-#define yy_scan_bytes adsmcoutput_scan_bytes
-#define yy_flex_debug adsmcoutput_flex_debug
-#define yy_init_buffer adsmcoutput_init_buffer
-#define yy_flush_buffer adsmcoutput_flush_buffer
-#define yy_load_buffer_state adsmcoutput_load_buffer_state
-#define yy_switch_to_buffer adsmcoutput_switch_to_buffer
-#define yyin adsmcoutputin
-#define yyleng adsmcoutputleng
-#define yylex adsmcoutputlex
-#define yyout adsmcoutputout
-#define yyrestart adsmcoutputrestart
-#define yytext adsmcoutputtext
-
-#line 19 "adsmcoutput.c"
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header$
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-
-#define yywrap() 1
-#define YY_SKIP_YYWRAP
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 16
-#define YY_END_OF_BUFFER 17
-static yyconst short int yy_accept[58] =
-    {   0,
-        0,    0,   17,   16,   14,   11,   12,   13,    2,   15,
-       13,   13,   13,   13,   13,   13,   14,   13,    1,   10,
-        0,   13,   13,   13,   13,   13,    0,    0,   13,   13,
-       13,    9,    4,    7,    8,   13,   13,   13,    6,   13,
-       13,   13,   13,   13,   13,   13,    0,   13,    0,   13,
-        0,   13,    5,   13,    0,    3,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    5,    6,    1,    7,    1,    1,    6,    1,    6,
-        6,    6,    6,    6,    8,    6,    6,    9,   10,    6,
-        6,    6,    6,    6,    6,    6,    6,    6,    1,    6,
-       11,   12,    1,    6,    6,    6,    6,    6,    6,    6,
-        6,    6,    6,    6,    6,    6,    6,    6,    6,    6,
-        6,    6,   13,    6,    6,    6,    6,    6,    6,    6,
-        1,    1,    1,    1,   14,    1,   15,   16,   17,   18,
-
-       19,    6,    6,    6,   20,    6,    6,   21,    6,   22,
-       23,    6,   24,   25,   26,   27,   28,    6,    6,    6,
-        6,    6,    1,    6,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[29] =
-    {   0,
-        1,    1,    1,    1,    1,    2,    1,    1,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2
-    } ;
-
-static yyconst short int yy_base[59] =
-    {   0,
-        0,    0,   72,   73,   27,   73,   73,    0,   73,   22,
-       66,   43,   55,   46,   45,   47,   31,    0,   73,   73,
-       28,   50,   50,   48,   54,   37,   57,   56,   31,   43,
-       40,   73,    0,   73,   73,   36,   40,   32,    0,   35,
-       32,   27,   31,   20,   42,   24,   34,   17,   38,   23,
-       31,   15,   73,   34,   24,   73,   73,   29
-    } ;
-
-static yyconst short int yy_def[59] =
-    {   0,
-       57,    1,   57,   57,   57,   57,   57,   58,   57,   57,
-       58,   58,   58,   58,   58,   58,   57,   58,   57,   57,
-       57,   58,   58,   58,   58,   58,   57,   57,   58,   58,
-       58,   57,   58,   57,   57,   58,   58,   58,   58,   58,
-       58,   58,   58,   58,   58,   58,   57,   58,   57,   58,
-       57,   58,   57,   58,   57,   57,    0,   57
-    } ;
-
-static yyconst short int yy_nxt[102] =
-    {   0,
-        4,    5,    6,    7,    5,    8,    9,   10,    8,    8,
-       11,    8,   12,    8,    8,    8,   13,    8,   14,   15,
-        8,    8,    8,    8,    8,   16,    8,    8,   17,   19,
-       18,   17,   17,   20,   56,   17,   27,   28,   55,   54,
-       53,   52,   51,   50,   49,   48,   47,   46,   45,   44,
-       43,   42,   41,   40,   39,   38,   37,   36,   35,   34,
-       33,   32,   31,   30,   29,   26,   25,   24,   23,   22,
-       21,   57,    3,   57,   57,   57,   57,   57,   57,   57,
-       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
-       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
-
-       57
-    } ;
-
-static yyconst short int yy_chk[102] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    5,   10,
-       58,    5,   17,   10,   55,   17,   21,   21,   54,   52,
-       51,   50,   49,   48,   47,   46,   45,   44,   43,   42,
-       41,   40,   38,   37,   36,   31,   30,   29,   28,   27,
-       26,   25,   24,   23,   22,   16,   15,   14,   13,   12,
-       11,    3,   57,   57,   57,   57,   57,   57,   57,   57,
-       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
-       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
-
-       57
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "adsmcoutput.l"
-#define INITIAL 0
-#line 2 "adsmcoutput.l"
-#include <stdio.h>
-#include <string.h>
-#include "adsmcoutput.tab.h"
-#include "adsmcoutputparse.h"
-
-char adsmcoutput_errormsg[1024] = "";
-char adsmcoutput_constraint[1024] = "";
-#line 431 "adsmcoutput.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 15 "adsmcoutput.l"
-
-#line 584 "adsmcoutput.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 58 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 73 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 16 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return COMMENT;}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 17 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return HASH;}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 18 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return COUNTER;}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 19 "adsmcoutput.l"
-{return IQ;}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 20 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return ENABLED;} /* enabled = 1 iff some hyperedge is taken */
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 21 "adsmcoutput.l"
-{return STATE;} 
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 22 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return ISZERO;} 
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 23 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return ISONE;} 
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 24 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return IN;} 
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 25 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext; return ARROW;} 
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 26 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return NL;}
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 27 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;return NL;}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 28 "adsmcoutput.l"
-{adsmcoutputlval.str_ptr=adsmcoutputtext;  return STRING;}
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 29 "adsmcoutput.l"
-{}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 30 "adsmcoutput.l"
-{}
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 33 "adsmcoutput.l"
-ECHO;
-	YY_BREAK
-#line 747 "adsmcoutput.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 58 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 58 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 57);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 33 "adsmcoutput.l"
-
-
-
-int adsmcoutputwrap() {
-	return(1);
-}
-
-int adsmcoutputerror(char *s) {
-        strcpy(adsmcoutput_errormsg, s);
-        return 0;
-}
-
diff -urN tcm-2.20/src/sd/bv/adsmcoutput.tab.c tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.tab.c
--- tcm-2.20/src/sd/bv/adsmcoutput.tab.c	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.tab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1099 +0,0 @@
-
-/*  A Bison parser, made from adsmcoutput.y
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse adsmcoutputparse
-#define yylex adsmcoutputlex
-#define yyerror adsmcoutputerror
-#define yylval adsmcoutputlval
-#define yychar adsmcoutputchar
-#define yydebug adsmcoutputdebug
-#define yynerrs adsmcoutputnerrs
-#define	IQ	257
-#define	QUOTE	258
-#define	COMMENT	259
-#define	COUNTER	260
-#define	HASH	261
-#define	ISZERO	262
-#define	ISONE	263
-#define	STATE	264
-#define	NL	265
-#define	ARROW	266
-#define	STRING	267
-#define	ENABLED	268
-#define	IN	269
-
-#line 1 "adsmcoutput.y"
-
-
-#include "adsmcoutputparse.h"
-
-
-
-  /*
-typedef char *CHAR_PTR;
-#define YYSTYPE CHAR_PTR
-#define YYDEBUG 1
-  */
-
-int mctraceindex;
- int mctrace[100];
- int mcfeedback;
-
- int enabledindex;
- int enabledhyperedge[2000];
- int enabledstatenumber[2000];
- char *sourcename[2000];  /* name of source */
- char *targetname[2000];    /* name of target */
- int sourcestatenumber[2000];
- int targetstatenumber[2000]; /* what statecounter does sourcestatenumber[i] belong to?*/
- int statecounter;
- int sourceindex, targetindex;
-
-#line 29 "adsmcoutput.y"
-typedef union  {
-  char *str_ptr;
-} YYSTYPE;
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		89
-#define	YYFLAG		-32768
-#define	YYNTBASE	16
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 269 ? yytranslate[x] : 38)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     6,     9,    12,    15,    18,    19,    22,    25,
-    28,    29,    33,    34,    39,    42,    43,    47,    50,    52,
-    58,    65,    67,    71,    72,    78,    80,    83,    84,    88,
-    91,    94,    98,   102,   105,   107,   111,   113,   116,   118,
-   121,   122,   129,   135,   138
-};
-
-static const short yyrhs[] = {    17,
-     0,    21,    22,    34,     0,    13,    18,     0,     9,    18,
-     0,     8,    18,     0,    12,    18,     0,     0,    13,    19,
-     0,     9,    19,     0,     8,    19,     0,     0,    19,    11,
-    20,     0,     0,    20,     5,    18,    11,     0,    23,    24,
-     0,     0,     5,    19,    11,     0,    26,    25,     0,    26,
-     0,     5,    33,     5,    11,    26,     0,    25,     5,    33,
-     5,    11,    26,     0,    27,     0,    28,    30,    27,     0,
-     0,    12,    29,    13,    13,    11,     0,    10,     0,    31,
-    30,     0,     0,    13,    14,    11,     0,    13,     8,     0,
-    13,     9,     0,    13,    13,     8,     0,    13,    13,     9,
-     0,    14,    11,     0,    11,     0,     6,    13,    11,     0,
-     7,     0,    32,     7,     0,    19,     0,    35,    36,     0,
-     0,    32,    11,    19,    37,    11,    19,     0,    32,    19,
-    37,    11,    19,     0,     5,    37,     0,     5,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    39,    42,    47,    48,    49,    50,    51,    54,    55,    56,
-    57,    60,    60,    64,    67,    68,    71,    74,    74,    78,
-    79,    85,    90,    92,    97,   100,   104,   105,   108,   122,
-   135,   148,   149,   151,   152,   153,   162,   162,   164,   168,
-   168,   171,   174,   181,   182
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","IQ","QUOTE",
-"COMMENT","COUNTER","HASH","ISZERO","ISONE","STATE","NL","ARROW","STRING","ENABLED",
-"IN","input","line","arrowstringseq","stringseq","stringlines","start","middle",
-"middle1","middle2","middle4","feedback","enabledfeedback","stateseq","state",
-"enabledfeedback2","enabledfeedbackatom","hashseq","loop","end","end1","end2",
-"commentseq", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    16,    17,    18,    18,    18,    18,    18,    19,    19,    19,
-    19,    20,    20,    21,    22,    22,    23,    24,    24,    25,
-    25,    26,    27,    27,    28,    29,    30,    30,    31,    31,
-    31,    31,    31,    31,    31,    31,    32,    32,    33,    34,
-    34,    35,    36,    37,    37
-};
-
-static const short yyr2[] = {     0,
-     1,     3,     2,     2,     2,     2,     0,     2,     2,     2,
-     0,     3,     0,     4,     2,     0,     3,     2,     1,     5,
-     6,     1,     3,     0,     5,     1,     2,     0,     3,     2,
-     2,     3,     3,     2,     1,     3,     1,     2,     1,     2,
-     0,     6,     5,     2,     1
-};
-
-static const short yydefact[] = {    11,
-    11,    11,    11,     1,     0,     0,    16,    10,     9,     8,
-    11,     7,    11,    41,    24,    12,     7,     7,     7,     7,
-     0,     0,    37,     0,     2,     0,     0,    15,    19,    22,
-    28,     5,     4,     6,     3,    14,    17,    38,    11,    11,
-    40,    26,     0,    11,    18,     0,    35,     0,     0,    24,
-    28,     0,     0,     0,    39,     0,    11,     0,    30,    31,
-     0,     0,    34,    23,    27,    45,     0,     0,     0,     0,
-     0,    36,    32,    33,    29,    44,    11,    11,    25,    24,
-     0,    42,    43,    20,    24,    21,     0,     0,     0
-};
-
-static const short yydefgoto[] = {    87,
-     4,    21,     5,     6,     7,    14,    15,    28,    45,    29,
-    30,    31,    43,    50,    51,    24,    56,    25,    26,    41,
-    67
-};
-
-static const short yypact[] = {     0,
-    -2,    -2,    -2,-32768,    -7,     9,    19,-32768,-32768,-32768,
-     0,    21,    -2,    28,    30,-32768,    21,    21,    21,    21,
-    26,    37,-32768,    25,-32768,    28,    39,-32768,    45,-32768,
-     4,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -2,    12,
--32768,-32768,    38,    -2,    47,    40,-32768,    14,    43,    30,
-     4,    50,    50,    44,-32768,    53,    -2,    48,-32768,-32768,
-    32,    49,-32768,-32768,-32768,    50,    51,    52,    54,    55,
-    56,-32768,-32768,-32768,-32768,-32768,    -2,    -2,-32768,    30,
-    57,-32768,-32768,-32768,    30,-32768,    64,    67,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,    27,    -1,    58,-32768,-32768,-32768,-32768,-32768,   -54,
-    20,-32768,-32768,    22,-32768,    46,    17,-32768,-32768,-32768,
-   -50
-};
-
-
-#define	YYLAST		77
-
-
-static const short yytable[] = {     8,
-     9,    10,    68,    11,   -13,     1,     2,     1,     2,    46,
-     3,    22,     3,    12,    47,    76,    48,    49,    38,     1,
-     2,    59,    60,    13,     3,    84,    61,    62,    17,    18,
-    86,    38,    19,    20,    23,    39,    36,    52,    53,    73,
-    74,    27,    55,    32,    33,    34,    35,    37,    42,    44,
-    54,    57,    58,    63,    66,    55,    69,    70,    72,    75,
-    81,    77,    78,    88,    79,    80,    89,    85,    16,    64,
-     0,    40,    65,    71,     0,    82,    83
-};
-
-static const short yycheck[] = {     1,
-     2,     3,    53,    11,     5,     8,     9,     8,     9,     6,
-    13,    13,    13,     5,    11,    66,    13,    14,     7,     8,
-     9,     8,     9,     5,    13,    80,    13,    14,     8,     9,
-    85,     7,    12,    13,     7,    11,    11,    39,    40,     8,
-     9,    12,    44,    17,    18,    19,    20,    11,    10,     5,
-    13,     5,    13,    11,     5,    57,    13,     5,    11,    11,
-     5,    11,    11,     0,    11,    11,     0,    11,    11,    50,
-    -1,    26,    51,    57,    -1,    77,    78
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/usr/lib/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-case 3:
-#line 47 "adsmcoutput.y"
-{;
-    break;}
-case 8:
-#line 54 "adsmcoutput.y"
-{;
-    break;}
-case 15:
-#line 67 "adsmcoutput.y"
-{mcfeedback=1;;
-    break;}
-case 16:
-#line 68 "adsmcoutput.y"
-{mcfeedback=0;;
-    break;}
-case 22:
-#line 85 "adsmcoutput.y"
-{;
-    break;}
-case 23:
-#line 90 "adsmcoutput.y"
-{
-statecounter++;;
-    break;}
-case 25:
-#line 97 "adsmcoutput.y"
-{;
-    break;}
-case 29:
-#line 109 "adsmcoutput.y"
-{
-  int i=3; /* STRING starts with "HE_" */
-  char temp[5];
-  while (yyvsp[-2].str_ptr[i]!='-'){
-    temp[i-3]=yyvsp[-2].str_ptr[i];
-    i++;
-  }
-  temp[i-3]='\0';
-  enabledhyperedge[enabledindex]  = atoi(temp);
-  enabledstatenumber[enabledindex]= statecounter ;
-  enabledindex++;
-
-;
-    break;}
-case 30:
-#line 123 "adsmcoutput.y"
-{
-  char temp[100];
-  int len;
-  strcpy(temp,yyvsp[-1].str_ptr);
-  len=strcspn(temp,"=\r\n");
-  /* printf("name\t%d\t%s\n",len,temp);*/
-  sourcename[sourceindex]= (char *)malloc(len+1);
-  strncpy(sourcename[sourceindex],temp,len);  
-  sourcename[sourceindex][len]='\0';
-  sourcestatenumber[sourceindex]=statecounter;
-  sourceindex++;
-;
-    break;}
-case 31:
-#line 136 "adsmcoutput.y"
-{
-  char temp[100];
-  int len;
-  strcpy(temp,yyvsp[-1].str_ptr);
-  len=strcspn(temp," =\r\n");
-  /*  printf("name\t%d\t%s\n",len,temp);*/
-  targetname[targetindex]= (char *)malloc(len+1);
-  strncpy(targetname[targetindex],temp,len);  
-  targetname[targetindex][len]='\0';
-  targetstatenumber[targetindex]=statecounter;
-  targetindex++;
-;
-    break;}
-case 32:
-#line 148 "adsmcoutput.y"
-{;
-    break;}
-case 33:
-#line 149 "adsmcoutput.y"
-{;
-    break;}
-case 34:
-#line 151 "adsmcoutput.y"
-{;
-    break;}
-case 35:
-#line 152 "adsmcoutput.y"
-{;
-    break;}
-case 36:
-#line 154 "adsmcoutput.y"
-{ 
-	 
-          mctrace[mctraceindex] =atoi(yyvsp[-1].str_ptr);
-          mctraceindex++;
-       ;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 187 "adsmcoutput.y"
-
-
-
diff -urN tcm-2.20/src/sd/bv/adsmcoutput.tab.h tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.tab.h
--- tcm-2.20/src/sd/bv/adsmcoutput.tab.h	2003-01-21 17:14:09.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/bv/adsmcoutput.tab.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-typedef union  {
-  char *str_ptr;
-} YYSTYPE;
-#define	IQ	257
-#define	QUOTE	258
-#define	COMMENT	259
-#define	COUNTER	260
-#define	HASH	261
-#define	ISZERO	262
-#define	ISONE	263
-#define	STATE	264
-#define	NL	265
-#define	ARROW	266
-#define	STRING	267
-#define	ENABLED	268
-#define	IN	269
-
-
-extern YYSTYPE adsmcoutputlval;
diff -urN tcm-2.20/src/sd/dv/apline.c tcm-2.20+TSQD.orig/src/sd/dv/apline.c
--- tcm-2.20/src/sd/dv/apline.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/apline.c	2004-07-10 00:43:04.000000000 +0200
@@ -0,0 +1,520 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1998, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+#include "grafport.h"
+#include "inputfile.h"
+#include "outputfile.h"
+#include "assoclist.h"
+#include "lifeline.h"
+#include "apline.h"
+#include "point.h"
+#include "llist.h"
+#include "sqobjectnode.h"
+#include "sqanchorlinkedge.h"
+
+APLine::APLine(ShapeView *v, Grafport *g, GShape *n1, GShape *n2,
+		List<Point *> *aline, bool Curved):
+		Line(v, g, n1, n2, aline, Curved) {
+
+std::cout << " APLine::APLine(*v, *g, *n1, *n2, List, curved)" << std::endl << std::flush;
+std::cout << " APLine(*v, *g, GS1=" << n1->GetId()
+<< ", GS2=" << n2->GetId()
+<< std::endl << std::flush;
+
+
+
+	apline = new List<Point *>;
+std::cout << " line so far " << std::endl << std::flush;
+	for (aline->first(); !aline->done(); aline->next()) {
+		Point *p1 = aline->cur();
+std::cout << ">> Got line *p1= " << *p1 << std::endl << std::flush;
+		apline->add(new Point(*p1));
+	}
+
+	apend1.SetType(LineEnd::EMPTY);
+	apend2.SetType(LineEnd::EMPTY);
+	apend2.SetType(LineEnd::FILLED_ARROW);
+
+std::cout << "reset line " << std::endl << std::flush;
+
+
+std::cout << "$$$$$$ (Re)CalcEndPoints() {" << std::endl << std::flush;
+//hz	ReCalcEndPoints(apline);
+	ReCalcEndPoints(apline);
+	ReCalcEndPoints(aline);
+
+std::cout << "$$$$ apline after ReCalc" << std::endl << std::flush;
+	int i = 0;
+	for (apline->first(); !apline->done(); apline->next()) {
+		Point *p1 = apline->cur();
+std::cout << ">> Got line *p1= " << *p1 << std::endl << std::flush;
+		SetPoint( p1 , i);
+		i++;
+	}
+
+std::cout << "$$$$ ALINE after ReCalc" << std::endl << std::flush;
+	for (aline->first(); !aline->done(); aline->next()) {
+		Point *p1 = aline->cur();
+std::cout << ">> Got line *p1= " << *p1 << std::endl << std::flush;
+
+
+	}
+
+std::cout << " -a4- " << std::endl << std::flush;
+}
+
+
+APLine::APLine(ShapeView *v, Grafport *g, GShape *n1, GShape *n2,
+		bool Curved): Line(v, g, n1, n2, Curved) {
+
+std::cout << " APLine::APLine(*v, *g, *n1, *n2, curved)" << std::endl << std::flush;
+
+	apend1.SetType(LineEnd::EMPTY);
+	apend2.SetType(LineEnd::FILLED_ARROW);
+
+}
+
+APLine::APLine(const APLine &aline): Line(aline) {
+
+std::cout << " APLine::APLine(const APLine &aline) {" << std::endl << std::flush;
+
+	apend1.SetType(LineEnd::EMPTY);
+	apend2.SetType(LineEnd::FILLED_ARROW);
+}
+
+
+void APLine::SetAnchors() {
+std::cout << " void APLine::SetAnchors() {" << std::endl << std::flush;
+
+	Point *firstPt, *lastPt;
+
+	int len = GetLine()->count();
+
+	firstPt = (*GetLine())[0];
+	lastPt = (*GetLine())[len-1];
+
+std::cout << " firstPt = " << *firstPt << std::endl << std::flush;
+std::cout << " lastPt = " << *lastPt << std::endl << std::flush;
+
+	SQAnchorLinkEdge *obj = (SQAnchorLinkEdge *)GetSubject();
+std::cout << " -b- " << std::endl << std::flush;
+
+//AleisterMod 20
+//std::cout << " obj->gCt=" << obj->GetClassType() << std::endl << std::flush;
+
+
+
+std::cout<<""<<std::endl<<std::flush;
+std::cout<<"ANCHOR________1"<< *(obj->GetAnchor1()) <<std::endl<<std::flush;
+std::cout<<"ANCHOR________2"<<  *(obj->GetAnchor2())<<std::endl<<std::flush;
+std::cout<<""<<std::endl<<std::flush;
+
+
+	Subject *sub1 = (Subject*) obj->GetSubject1();
+std::cout << " -c- " << std::endl << std::flush;
+	SQObjectNode *sub1a = (SQObjectNode *) sub1;
+std::cout << " -C- " << std::endl << std::flush;
+	SQObjectNode *on2 = (SQObjectNode *) obj->GetSubject2();
+std::cout << " -d- " << std::endl << std::flush;
+
+
+if((((obj->GetAnchor1()))->x)!=0 && (((obj->GetAnchor1()))->y)!=0 && (((obj->GetAnchor2()))->x)!=0 && (((obj->GetAnchor2()))->y)!=0) {
+	sub1a->RemoveAnchor(((obj->GetAnchor1()))->x, 4);
+	on2->RemoveAnchor(((obj->GetAnchor2()))->x, 5);
+}
+
+	Point *pt1 = new Point(firstPt->y, 4);
+	obj->SetAnchor1(pt1);
+
+	Point *pt2 = new Point(lastPt->y, 5);
+	obj->SetAnchor2(pt2);
+
+	//if() {
+
+	sub1a->AddAnchor(firstPt->y, 4);
+std::cout << " -e- " << std::endl << std::flush;
+	on2->AddAnchor(lastPt->y, 5);
+std::cout << " -f- " << std::endl << std::flush;
+
+}
+
+void APLine::DrawShape() {
+
+std::cout << " void APLine::DrawShape() {" << std::endl << std::flush;
+
+std::cout << " GetLine->count() = " << GetLine()->count() << std::endl << std::flush;
+
+
+	if (check(GetLine()->count()>=2)) {
+std::cout << " GetLine()->count() = " << GetLine()->count() << std::endl << std::flush;
+
+for (GetLine()->first(); !GetLine()->done(); GetLine()->next()) {
+		std::cout << "GetLine()->cur() = [" << *GetLine()->cur() << "]" << std::endl << std::flush;
+//HZ	std::cout << "GetLine()->cur() = [" << *(GetLine()->cur()) << "]" << std::endl << std::flush;
+}
+
+
+		DPoint ep1, ep2;
+		DPoint tp1 = *(*GetLine())[1];	//convert
+		DPoint tp2 = *(*GetLine())[0];	//convert
+		DPoint tp3 = *(*GetLine())[GetLine()->count()-2];	//convert
+		DPoint tp4 = *(*GetLine())[GetLine()->count()-1];	//convert
+std::cout << " tp1: [" << (*GetLine())[1] << " == " << tp1 << std::endl << std::flush;
+std::cout << " tp2: [" << (*GetLine())[0] << " == " << tp2 << std::endl << std::flush;
+std::cout << " tp3: [" << (*GetLine())[GetLine()->count()-2] << " == " << tp3 << std::endl << std::flush;
+std::cout << " tp4: [" << (*GetLine())[GetLine()->count()-1] << " == " << tp4 << std::endl << std::flush;
+
+
+
+		if (GetGrafport()->GetLineStyle() != LineStyle::INVISIBLE) {
+			GetGrafport()->SetLineStyle(LineStyle::SOLID);
+			apend1.Draw(GetGrafport(), &tp1, &tp2, &ep1);
+
+std::cout << " apend1: [" << (*GetLine())[1] << " -> "
+<< (*GetLine())[0] << "] -> " << ep1
+<< std::endl << std::flush;
+
+			apend2.Draw(GetGrafport(), &tp3, &tp4, &ep2);
+std::cout << " apend2: [" << (*GetLine())[GetLine()->count()-2] << " -> "
+<< (*GetLine())[GetLine()->count()-1] << "] -> " << ep2
+<< std::endl << std::flush;
+
+			GetGrafport()->SetLineStyle(GetLineStyle());
+
+
+std::cout << "apend1=[" << *(*GetLine())[1] << "->"
+	<< *(*GetLine())[0] << "] ==> " << ep1 << std::endl << std::flush;
+std::cout << "apend2=[" << *(*GetLine())[GetLine()->count()-2] << "->"
+	<< *(*GetLine())[GetLine()->count()-1] << "] ==> " << ep2 << std::endl << std::flush;
+		}
+
+		SetAnchors();
+
+
+		if (IsCurved())
+//			DrawBezier(&ep1, &ep2);
+			DrawLine(&ep1, &ep2);
+		else
+			DrawLine(&ep1, &ep2);
+	}
+
+}
+
+void APLine::DrawLine(const DPoint *ep1, const DPoint *ep2) /* const */ {
+
+std::cout << "$$$ void APLine::DrawLine(" << *ep1 << "," <<  *ep2 << ")" << std::endl << std::flush;
+
+
+//	delete [/* apline->count() */] p;
+
+
+	unsigned u = GetLine()->count();
+	if ( u < 2 || ! GetLine()->first() )
+		return;
+	DPoint *p = new DPoint[u];
+	p[--u] = *ep1;
+	while ( --u ) {
+		GetLine()->next();
+		p[u] = *GetLine()->cur();
+	}
+	p[0] = *ep2;
+	GetGrafport()->DrawOpenPolygon(p, GetLine()->count());
+	delete [/* GetLine()->count() */] p;
+
+
+std::cout << " ENDOFFFF void APLine::DrawLine() " << std::endl << std::flush;
+}
+
+
+
+
+
+
+
+bool APLine::SetReferences(AssocList *al) {
+
+std::cout << " bool APLine::SetReferences(AssocList *al) {" << std::endl << std::flush;
+
+//
+//	Line::SetReferences(al);
+//
+	Assoc *find, *assoc;
+	find = new Assoc(GetFromShape());
+	assoc = al->Get(find);
+	delete find;
+	if (check(assoc))
+		SetFromShape((GShape *)assoc->copy);
+	else {
+		error("line %ld has no existing fromShape\n", GetId());
+		SetFromShape((GShape *)0);
+		return False;
+	}
+	if (!GetFromShape() || !GetFromShape()->IsShape()) {
+		error("line %ld has no real shape as fromShape\n", GetId());
+		SetFromShape(0);
+		return False;
+	}
+	find = new Assoc(GetToShape());
+	assoc = al->Get(find);
+	delete find;
+	if (check(assoc))
+		SetToShape((GShape *)assoc->copy);
+	else {
+		error("line %ld has no existing toShape\n", GetId());
+		SetToShape(0);
+		return False;
+	}
+	if (!GetToShape() || !GetToShape()->IsShape()) {
+		error("line %ld has no real shape as toShape\n", GetId());
+		SetToShape(0);
+		return False;
+	}
+	Point *l = (*GetLine())[0];
+//	*l = GetFromShape()->GiveOrthoSnp(*l);
+//	*l = ((LifeLine *)GetFromShape())->GiveAnchorSnp(*l);
+//	l = (*GetLine())[GetLine()->count() - 1];
+//	*l = GetToShape()->GiveOrthoSnp(*l);
+//	*l = ((LifeLine *)GetToShape())->GiveAnchorSnp(*l);
+
+	return True;
+}
+
+void APLine::CalcEndPoints() {
+
+std::cout << "######  void APLine::CalcEndPoints() {" << std::endl << std::flush;
+std::cout << " -chk-2- = " << (int) check(GetSubject()) << std::endl << std::flush;
+std::cout << " GOING 2 	ReCalcEndPoints();" << std::endl << std::flush;
+	ReCalcEndPoints();
+
+}
+
+bool APLine::CalcEndPoint(const Point *pt, unsigned int n) {
+
+std::cout << " =!= APLine::CalcEndPoint([" << *pt << " ] ," << n << ")" << std::endl << std::flush;
+	return True;
+}
+
+
+void APLine::ReCalcEndPoints() {
+
+std::cout << "$$$  void APLine::ReCalcEndPoints() {" << std::endl << std::flush;
+std::cout << " -chk-3- = " << (int) check(GetSubject()) << std::endl << std::flush;
+
+	if (!check(GetFromShape()) || !check(GetToShape()))
+		return;
+	Point from, to, dummy;
+	Point *firstPt, *lastPt;
+//HZ	int code = orientation;
+	int code = 1;
+	int len = GetLine()->count();
+
+	firstPt = (*GetLine())[0];
+	lastPt = (*GetLine())[len-1];
+std::cout << " <-- firstPt = " << *firstPt
+	 << " <-- lastPt = " << *lastPt << " {" << len << "}" << std::endl << std::flush;
+	if ((*GetLine())[1] == lastPt) {
+		dummy = *(GetToShape()->GetPosition());
+		to.x = dummy.x;
+		to.y = lastPt->y;
+	}
+	else
+		to = *(*GetLine())[1];
+	if ((*GetLine())[len-2] == firstPt) {
+		dummy = *(GetFromShape()->GetPosition());
+		from.x = dummy.x;
+		from.y = firstPt->y;
+	}
+	else
+		from = *(*GetLine())[len-2];
+
+std::cout << " <== from = " << from
+	 << " <== to = " << to << "{" << len << "}" << std::endl << std::flush;
+	if ((GetCount() == 1) || (GetFromShape() == GetToShape())) {
+		if (len == 2) {
+			if (GetFromShape()->IsLine() && !GetToShape()->IsLine()) {
+				from = GetFromShape()->GiveOrthoSnp(to);
+				to = GetToShape()->GiveSnp(from);
+				firstPt->Set(from.x, from.y);
+				lastPt->Set(to.x, to.y);
+				return;
+			}
+			else if (GetToShape()->IsLine() && !GetFromShape()->IsLine()) {
+				to = GetToShape()->GiveOrthoSnp(from);
+				from = GetFromShape()->GiveSnp(to);
+				firstPt->Set(from.x, from.y);
+				lastPt->Set(to.x, to.y);
+				return;
+			}
+			else if (GetFromShape()->IsLine() && GetToShape()->IsLine()) {
+				Point p1 = GetFromShape()->GiveSnp(to);
+				Point p2 = GetToShape()->GiveSnp(from);
+				firstPt->Set(p1.x, p1.y);
+				lastPt->Set(p2.x, p2.y);
+			}
+			else {
+std::cout << " got HeRe " << std::endl << std::flush;
+				GShape *s1 = GetFromShape();
+				LifeLine *l1 = (LifeLine *) s1;
+//				Point p1 = l1->GiveAnchorSnp(*firstPt, to);
+				Point p1 = l1->GiveAnchorSnp(from, to);
+
+//				Point p2 = ((LifeLine *)GetToShape())->GiveAnchorSnp(*lastPt, from);
+				Point p2 = ((LifeLine *)GetToShape())->GiveAnchorSnp(to, from);
+std::cout << "!!!firstPt [" << *firstPt << "] ==> [" << p1 << "]" << std::endl << std::flush;
+std::cout << "!!!lastPt [" << *lastPt << "] ==> [" << p2 << "]" << std::endl << std::flush;
+std::cout << "!!!to [" << to << "] ==> [" << p2 << "]" << std::endl << std::flush;
+				firstPt->Set(p1.x, p1.y);
+				lastPt->Set(p2.x, p2.y);
+std::cout << " -1-> firstPt = " << *firstPt
+	 << " -1-> lastPt = " << *lastPt << std::endl << std::flush;
+			}
+		}
+		else {
+
+std::cout << " len != 2 : {" << len << "}" << std::endl << std::flush;
+
+//			Point p1 = GetFromShape()->GiveOrthoSnp(to);
+//			Point p2 = GetToShape()->GiveOrthoSnp(from);
+			/*Point p1 = ((LifeLine *)GetFromShape())->GiveAnchorSnp(*firstPt, to);
+			Point p2 = ((LifeLine *)GetToShape())->GiveAnchorSnp(*lastPt, from);
+			firstPt->Set(p1.x, p1.y);
+			lastPt->Set(p2.x, p2.y);*/
+	firstPt->Set((GetFromShape()->GetPosition())->x, firstPt->y);
+			lastPt->Set((GetToShape()->GetPosition())->x, 	lastPt->y);
+
+std::cout << " -2-> firstPt = " << *firstPt
+	 << " -2-> lastPt = " << *lastPt << std::endl << std::flush;
+		}
+	}
+	else {
+		/*Point p1 = GetFromShape()->GiveSnp(to, GetOrder(), GetCount(), code);
+		Point p2 = GetToShape()->GiveSnp(from, GetOrder(), GetCount(), code);
+		firstPt->Set(p1.x, p1.y);
+		lastPt->Set(p2.x, p2.y);*/
+
+		firstPt->Set((GetFromShape()->GetPosition())->x, firstPt->y);
+			lastPt->Set((GetToShape()->GetPosition())->x, lastPt->y);
+std::cout << " -3-> firstPt = " << *firstPt
+	 << " -3-> lastPt = " << *lastPt << std::endl << std::flush;
+	}
+}
+
+void APLine::ReCalcEndPoints(List<Point *> *oline) {
+
+std::cout << "$$$  void APLine::ReCalcEndPoints(oline) {" << std::endl << std::flush;
+
+std::cout << " oline is " << std::endl << std::flush;
+	for (oline->first(); !oline->done(); oline->next()) {
+		Point *p1 = oline->cur();
+std::cout << ">> Got oline *p1= " << *p1 << std::endl << std::flush;
+	}
+	if (!check(GetFromShape()) || !check(GetToShape()))
+		return;
+	Point from, to;
+	Point *firstPt, *lastPt;
+//HZ	int code = orientation;
+	int code = 1;
+	int len = oline->count();
+
+	firstPt = (*oline)[0];
+	lastPt = (*oline)[len-1];
+std::cout << " <-- firstPt = " << *firstPt
+	 << " <-- lastPt = " << *lastPt << std::endl << std::flush;
+/*
+	if ((*oline)[1] == lastPt)
+		to = *(GetToShape()->GetPosition());
+	else
+*/
+		to = *(*oline)[1];
+/*
+	if ((*oline)[len-2] == firstPt)
+		from = *(GetFromShape()->GetPosition());
+	else
+*/
+		from = *(*oline)[len-2];
+
+std::cout << " <== from = " << from
+	 << " <== to = " << to << std::endl << std::flush;
+	if ((GetCount() == 1) || (GetFromShape() == GetToShape())) {
+		if (len == 2) {
+			if (GetFromShape()->IsLine() && !GetToShape()->IsLine()) {
+				from = GetFromShape()->GiveOrthoSnp(to);
+				to = GetToShape()->GiveSnp(from);
+				firstPt->Set(from.x, from.y);
+				lastPt->Set(to.x, to.y);
+				return;
+			}
+			else if (GetToShape()->IsLine() && !GetFromShape()->IsLine()) {
+				to = GetToShape()->GiveOrthoSnp(from);
+				from = GetFromShape()->GiveSnp(to);
+				firstPt->Set(from.x, from.y);
+				lastPt->Set(to.x, to.y);
+				return;
+			}
+			else if (GetFromShape()->IsLine() && GetToShape()->IsLine()) {
+				Point p1 = GetFromShape()->GiveSnp(to);
+				Point p2 = GetToShape()->GiveSnp(from);
+				firstPt->Set(p1.x, p1.y);
+				lastPt->Set(p2.x, p2.y);
+			}
+			else {
+
+				GShape *s1 = GetFromShape();
+				LifeLine *l1 = (LifeLine *) s1;
+				Point p1 = l1->GiveAnchorSnp(*firstPt, to);
+
+				Point p2 = ((LifeLine *)GetToShape())->GiveAnchorSnp(*lastPt, from);
+std::cout << "!!!firstPt [" << *firstPt << "] ==> [" << p1 << "]" << std::endl << std::flush;
+std::cout << "!!!lastPt [" << *lastPt << "] ==> [" << p2 << "]" << std::endl << std::flush;
+				firstPt->Set(p1.x, p1.y);
+				lastPt->Set(p2.x, p2.y);
+std::cout << " -1-> firstPt = " << *firstPt
+	 << " -1-> lastPt = " << *lastPt << std::endl << std::flush;
+			}
+		}
+		else {
+			/*Point p1 = GetFromShape()->GiveOrthoSnp(to);
+			Point p2 = GetToShape()->GiveOrthoSnp(from);
+			firstPt->Set(p1.x, p1.y);
+			lastPt->Set(p2.x, p2.y);*/
+
+			firstPt->Set((GetFromShape()->GetPosition())->x, firstPt->y);
+			lastPt->Set((GetToShape()->GetPosition())->x, lastPt->y);
+
+std::cout << " -2-> firstPt = " << *firstPt
+	 << " -2-> lastPt = " << *lastPt << std::endl << std::flush;
+		}
+	}
+	else {
+		/*Point p1 = GetFromShape()->GiveSnp(to, GetOrder(), GetCount(), code);
+		Point p2 = GetToShape()->GiveSnp(from, GetOrder(), GetCount(), code);
+		firstPt->Set(p1.x, p1.y);
+		lastPt->Set(p2.x, p2.y);*/
+firstPt->Set((GetFromShape()->GetPosition())->x, firstPt->y);
+			lastPt->Set((GetToShape()->GetPosition())->x, lastPt->y);
+
+
+std::cout << " -3-> firstPt = " << *firstPt
+	 << " -3-> lastPt = " << *lastPt << std::endl << std::flush;
+	}
+}
+
+
diff -urN tcm-2.20/src/sd/dv/apline.h tcm-2.20+TSQD.orig/src/sd/dv/apline.h
--- tcm-2.20/src/sd/dv/apline.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/apline.h	2002-07-25 16:20:00.000000000 +0200
@@ -0,0 +1,84 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1998, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl)
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _APLINE_H
+#define _APLINE_H
+
+#include "line.h"
+//#include "llist.h"
+//#include "gshape.h"
+//#include "lineend.h"
+
+/// line class (abstract) having two extra text shape.
+class APLine: public Line { 
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	APLine(ShapeView *v, Grafport *g, GShape *n1, GShape *n2, 
+		List<Point *> *line, bool Curved);
+	///
+	APLine(ShapeView *v, Grafport *g, GShape *n1, GShape *n2, 
+		bool Curved);
+	///
+	APLine(const APLine &) ;
+	///
+	int GetClassType() const {return Code::T4_LINE;}
+
+	/// Set also fromShape and toShape references.
+	bool SetReferences(AssocList *);
+
+	/// set anchors
+	void SetAnchors();
+
+	/// draw line+textshapes.
+	void DrawShape(); 
+
+	/// yep.
+	bool IsLine() const {return True;}
+	///
+	virtual void DrawLine(const DPoint *ep1, const DPoint *ep2);
+
+	/// Calculate begin and end-points (intersections with the shapes).
+	virtual void CalcEndPoints();
+
+	///
+	bool CalcEndPoint(const Point *pt, unsigned int n);
+
+	/// Calculate begin and end-points (intersections with the shapes).
+	virtual void ReCalcEndPoints();
+
+	/// ReCalculate begin and end-points (intersections with the shapes).
+	virtual void ReCalcEndPoints(List<Point *> *orgline);
+
+private:
+	/// The points of the anchorpointline (aka handles).
+	List<Point *> *apline;
+
+	/// The anchorpointline (aka handles).
+	Line *theline;
+
+	///
+	LineEnd apend1;
+	///
+	LineEnd apend2;
+
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/cardconstraint.c tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.c
--- tcm-2.20/src/sd/dv/cardconstraint.c	2003-01-21 17:12:45.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1602 +0,0 @@
-#define yy_create_buffer cardconstraint_create_buffer
-#define yy_delete_buffer cardconstraint_delete_buffer
-#define yy_scan_buffer cardconstraint_scan_buffer
-#define yy_scan_string cardconstraint_scan_string
-#define yy_scan_bytes cardconstraint_scan_bytes
-#define yy_flex_debug cardconstraint_flex_debug
-#define yy_init_buffer cardconstraint_init_buffer
-#define yy_flush_buffer cardconstraint_flush_buffer
-#define yy_load_buffer_state cardconstraint_load_buffer_state
-#define yy_switch_to_buffer cardconstraint_switch_to_buffer
-#define yyin cardconstraintin
-#define yyleng cardconstraintleng
-#define yylex cardconstraintlex
-#define yyout cardconstraintout
-#define yyrestart cardconstraintrestart
-#define yytext cardconstrainttext
-#define yywrap cardconstraintwrap
-
-#line 20 "cardconstraint.c"
-/* A lexical scanner generated by flex */
-
-/* Scanner skeleton version:
- * $Header$
- */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-
-#include <stdio.h>
-#include <unistd.h>
-
-
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
-
-
-#ifdef __cplusplus
-
-#include <stdlib.h>
-
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-#if __STDC__
-
-#define YY_USE_PROTOS
-#define YY_USE_CONST
-
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
-
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN yy_start = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START ((yy_start - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#define YY_BUF_SIZE 16384
-
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-
-extern int yyleng;
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
-		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
-
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-	};
-
-static YY_BUFFER_STATE yy_current_buffer = 0;
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- */
-#define YY_CURRENT_BUFFER yy_current_buffer
-
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
-typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
-
-#define YY_NUM_RULES 15
-#define YY_END_OF_BUFFER 16
-static yyconst short int yy_accept[25] =
-    {   0,
-        0,    0,   16,   14,   13,   13,   14,    1,   14,   12,
-       12,    7,    4,    8,   11,   10,   13,    5,    9,   12,
-        2,    6,    3,    0
-    } ;
-
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    5,    1,    6,    1,    7,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    1,    9,
-       10,   11,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,   12,   13,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst int yy_meta[14] =
-    {   0,
-        1,    2,    2,    1,    1,    1,    3,    3,    1,    1,
-        1,    1,    1
-    } ;
-
-static yyconst short int yy_base[27] =
-    {   0,
-        0,    0,   21,   22,    0,    0,   10,   22,   13,   22,
-        0,    4,   22,    8,   22,   22,    0,   22,   22,    0,
-       22,   22,   22,   22,   15,   13
-    } ;
-
-static yyconst short int yy_def[27] =
-    {   0,
-       24,    1,   24,   24,   25,   25,   24,   24,   24,   24,
-       26,   24,   24,   24,   24,   24,   25,   24,   24,   26,
-       24,   24,   24,    0,   24,   24
-    } ;
-
-static yyconst short int yy_nxt[36] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   15,   16,   21,   22,   20,   17,   23,   19,   18,
-       24,    3,   24,   24,   24,   24,   24,   24,   24,   24,
-       24,   24,   24,   24,   24
-    } ;
-
-static yyconst short int yy_chk[36] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,   12,   12,   26,   25,   14,    9,    7,
-        3,   24,   24,   24,   24,   24,   24,   24,   24,   24,
-       24,   24,   24,   24,   24
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "cardconstraint.l"
-#define INITIAL 0
-#line 2 "cardconstraint.l"
-#include "cardconstraint.tab.h"
-#include "erparse.h"
-char cardconstraint_errormsg[1024] = "";
-char cardconstraint_constraint[1024] = "";
-#line 400 "cardconstraint.c"
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
-
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
-#endif
-
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
-		{ \
-		int c = '*', n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-YY_DECL
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
-	register int yy_act;
-
-#line 10 "cardconstraint.l"
-
-#line 553 "cardconstraint.c"
-
-	if ( yy_init )
-		{
-		yy_init = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-
-		yy_load_buffer_state();
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = yy_c_buf_p;
-
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = yy_start;
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 25 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 22 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-
-do_action:	/* This label is used only to access EOF actions. */
-
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 11 "cardconstraint.l"
-{strcat(cardconstraint_constraint, ",");return(COMMA);}
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 12 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "<=");return(LESSEQUAL);}
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 13 "cardconstraint.l"
-{strcat(cardconstraint_constraint, ">=");return(GREATEREQUAL);}
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 14 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "=");return(EQUAL);}
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 15 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "!=");return(NOTEQUAL);}
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 16 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "!=");return(NOTEQUAL);}
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 17 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "<");return(LESS);}
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 18 "cardconstraint.l"
-{strcat(cardconstraint_constraint, ">");return(GREATER);}
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 19 "cardconstraint.l"
-{strcat(cardconstraint_constraint, "..");return(DOTDOT);}
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 20 "cardconstraint.l"
-{return(N);} 
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 21 "cardconstraint.l"
-{return(M);} 
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 22 "cardconstraint.l"
-{strcat(cardconstraint_constraint, cardconstrainttext);return(NUMBER);}
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 23 "cardconstraint.l"
-
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 24 "cardconstraint.l"
-{return(UNDEFINED);}
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 25 "cardconstraint.l"
-ECHO;
-	YY_BREAK
-#line 711 "cardconstraint.c"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state();
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = yy_c_buf_p;
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer() )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				yy_did_buffer_switch_on_eof = 0;
-
-				if ( yywrap() )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
-
-				yy_current_state = yy_get_previous_state();
-
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of yylex */
-
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
-
-	else
-		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
-
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	if ( yy_n_chars == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
-
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
-
-	return ret_val;
-	}
-
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-static yy_state_type yy_get_previous_state()
-	{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 25 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-	}
-
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
-	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 25 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 24);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
-
-
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
-
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
-
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
-		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
-
-		while ( source > yy_current_buffer->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
-
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
-#ifdef __cplusplus
-static int yyinput()
-#else
-static int input()
-#endif
-	{
-	int c;
-
-	*yy_c_buf_p = yy_hold_char;
-
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
-			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
-
-		else
-			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
-
-			switch ( yy_get_next_buffer() )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/* fall through */
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap() )
-						return EOF;
-
-					if ( ! yy_did_buffer_switch_on_eof )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
-
-	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
-
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
-		return;
-
-	if ( yy_current_buffer )
-		{
-		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
-		}
-
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
-	if ( ! b )
-		return;
-
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
-
-	{
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
-	}
-
-
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
-
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b );
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
-
-
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
-
-
-/* Internal utility routines. */
-
-#ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-	}
-#endif
-
-#ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-	}
-#endif
-
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
-	return (void *) malloc( size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-	}
-
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
-
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 25 "cardconstraint.l"
-
-
-int cardconstraintwrap() {
-	return(1);
-}
-
-int cardconstrainterror(char *s) {
-        strcpy(cardconstraint_errormsg, s);
-        return 0;
-}
-
diff -urN tcm-2.20/src/sd/dv/cardconstraint.tab.c tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.tab.c
--- tcm-2.20/src/sd/dv/cardconstraint.tab.c	2003-01-21 17:12:45.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.tab.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,925 +0,0 @@
-
-/*  A Bison parser, made from cardconstraint.y
-    by GNU Bison version 1.28  */
-
-#define YYBISON 1  /* Identify Bison output.  */
-
-#define yyparse cardconstraintparse
-#define yylex cardconstraintlex
-#define yyerror cardconstrainterror
-#define yylval cardconstraintlval
-#define yychar cardconstraintchar
-#define yydebug cardconstraintdebug
-#define yynerrs cardconstraintnerrs
-#define	COMMA	257
-#define	NUMBER	258
-#define	N	259
-#define	M	260
-#define	DOTDOT	261
-#define	UNDEFINED	262
-#define	EQUAL	263
-#define	NOTEQUAL	264
-#define	LESS	265
-#define	LESSEQUAL	266
-#define	GREATER	267
-#define	GREATEREQUAL	268
-
-#line 1 "cardconstraint.y"
-
-#include "erparse.h"
-#include <stdio.h>
-#define YYERROR_VERBOSE
-#ifndef YYSTYPE
-#define YYSTYPE int
-#endif
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
-#endif
-
-
-
-#define	YYFINAL		24
-#define	YYFLAG		-32768
-#define	YYNTBASE	15
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 268 ? yytranslate[x] : 18)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     6,    10,    14,    18,    22,    26,    30,    34,
-    36,    38,    40
-};
-
-static const short yyrhs[] = {    16,
-     0,    15,     3,    16,     0,     4,     7,     4,     0,    17,
-     9,     4,     0,    17,    10,     4,     0,    17,    11,     4,
-     0,    17,    12,     4,     0,    17,    13,     4,     0,    17,
-    14,     4,     0,     4,     0,     5,     0,     6,     0,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    11,    12,    15,    16,    17,    18,    19,    20,    21,    22,
-    25,    26,    27
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","COMMA",
-"NUMBER","N","M","DOTDOT","UNDEFINED","EQUAL","NOTEQUAL","LESS","LESSEQUAL",
-"GREATER","GREATEREQUAL","cardconstraint","expr","nletter", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    15,    15,    16,    16,    16,    16,    16,    16,    16,    16,
-    17,    17,    17
-};
-
-static const short yyr2[] = {     0,
-     1,     3,     3,     3,     3,     3,     3,     3,     3,     1,
-     1,     1,     0
-};
-
-static const short yydefact[] = {    13,
-    10,    11,    12,     0,     1,     0,     0,    13,     0,     0,
-     0,     0,     0,     0,     3,     2,     4,     5,     6,     7,
-     8,     9,     0,     0
-};
-
-static const short yydefgoto[] = {     4,
-     5,     6
-};
-
-static const short yypact[] = {     7,
-     0,-32768,-32768,     6,-32768,    -9,     4,     7,    10,    11,
-    12,    13,    14,    15,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,    20,-32768
-};
-
-static const short yypgoto[] = {-32768,
-     2,-32768
-};
-
-
-#define	YYLAST		20
-
-
-static const short yytable[] = {     9,
-    10,    11,    12,    13,    14,    23,     7,    15,     8,    16,
-     1,     2,     3,    17,    18,    19,    20,    21,    22,    24
-};
-
-static const short yycheck[] = {     9,
-    10,    11,    12,    13,    14,     0,     7,     4,     3,     8,
-     4,     5,     6,     4,     4,     4,     4,     4,     4,     0
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
-
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
-
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
-
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
-}
-
-#endif
-#endif
-
-#line 217 "/usr/lib/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-#ifdef YYPARSE_PARAM
-int yyparse (void *);
-#else
-int yyparse (void);
-#endif
-#endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
-  int yylen;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
-
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
-
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
-    }
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
-
-  goto yybackup;
- yybackup:
-
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
-  if (yychar == YYEMPTY)
-    {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
-    }
-
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
-    {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
-    }
-  else
-    {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
-    }
-
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
-  goto yynewstate;
-
-/* Do the default action for the current state.  */
-yydefault:
-
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
-yyreduce:
-  yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
-
-  switch (yyn) {
-
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-  *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
-
-  goto yynewstate;
-
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
-    {
-      ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
-
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
-      yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
-
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
-
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  yystate = yyn;
-  goto yynewstate;
-
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
-}
-#line 29 "cardconstraint.y"
-
diff -urN tcm-2.20/src/sd/dv/cardconstraint.tab.h tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.tab.h
--- tcm-2.20/src/sd/dv/cardconstraint.tab.h	2003-01-21 17:12:45.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/cardconstraint.tab.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-#ifndef YYSTYPE
-#define YYSTYPE int
-#endif
-#define	COMMA	257
-#define	NUMBER	258
-#define	N	259
-#define	M	260
-#define	DOTDOT	261
-#define	UNDEFINED	262
-#define	EQUAL	263
-#define	NOTEQUAL	264
-#define	LESS	265
-#define	LESSEQUAL	266
-#define	GREATER	267
-#define	GREATEREQUAL	268
-
-
-extern YYSTYPE cardconstraintlval;
diff -urN tcm-2.20/src/sd/dv/createfoccmd.c tcm-2.20+TSQD.orig/src/sd/dv/createfoccmd.c
--- tcm-2.20/src/sd/dv/createfoccmd.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/createfoccmd.c	2004-06-14 17:38:02.000000000 +0200
@@ -0,0 +1,464 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2002, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+//// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+//#include "grafport.h"
+#include "nodeshape.h"
+#include "shapeview.h"
+#include "diagram.h"
+#include "subject.h"
+#include "diagramviewer.h"
+//#include "drawwindow.h"
+#include "createfoccmd.h"
+#include "lifeline.h"
+#include "sqobjectnode.h"
+
+
+// dir = handle nr + 1
+// Aleister5 mod line 36 , bool simetricResize
+CreateFOCCmd::CreateFOCCmd(GShape *s, int y, int startF, int endF, bool simetricResize)				: Command(s->GetView()->GetViewer()->GetDiagram(),
+			s->GetView()->GetViewer()),
+			fixpoint(*s->GetPosition()),
+			centre(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0),
+			corner(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
+{
+	this->simetricResize = simetricResize;
+	std::cout << "<<<  CreateFOCCmd::CreateFOCCmd(*s, " << y << " ["
+	<<  startF << "->" << endF << "] )" << std::endl << std::flush;
+
+	if ( ! (shape = dynamic_cast<NodeShape *>(s)) )
+		error("Illegal use of size shape command");
+
+	SetPdirection(5);
+	std::cout << "-3-> pdirection = " << pdirection << " Gdir = " << GetPdirection()
+	<< std::endl << std::flush;
+	startFOC = startF;
+	endFOC = endF;
+	startY = y;
+	//endY = endF;
+	endY = y;
+
+	if(simetricResize) {
+		if(endY == startF) {
+			simetricEndY = endF;
+		} else {
+			simetricEndY = startF;
+		}
+	}
+	std::cout << " startFOC = " << startFOC  << std::endl << std::flush;
+	std::cout << " endFOC = " << endFOC  << std::endl << std::flush;
+	std::cout << " startY " << startY  << std::endl << std::flush;
+	std::cout << " endY = " << endY  << std::endl << std::flush;
+	std::cout << "-4-> pdirection = " << pdirection << " Gdir = " << GetPdirection()
+	<< std::endl << std::flush;
+}
+
+//Begin Aleister5
+CreateFOCCmd::CreateFOCCmd(GShape *s, int y, int startF, int endF)
+			: Command(s->GetView()->GetViewer()->GetDiagram(),
+			s->GetView()->GetViewer()),
+			fixpoint(*s->GetPosition()),
+			centre(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0),
+			corner(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
+{
+	this->simetricResize = false;
+	std::cout << "<<<  CreateFOCCmd::CreateFOCCmd(*s, " << y << " ["
+	<<  startF << "->" << endF << "] )" << std::endl << std::flush;
+
+	if ( ! (shape = dynamic_cast<NodeShape *>(s)) )
+		error("Illegal use of size shape command");
+
+	SetPdirection(5);
+	std::cout << "-3-> pdirection = " << pdirection << " Gdir = " << GetPdirection()
+	<< std::endl << std::flush;
+	startFOC = startF;
+	endFOC = endF;
+	startY = y;
+	//endY = endF;
+	endY = y;
+	std::cout << " startFOC = " << startFOC  << std::endl << std::flush;
+	std::cout << " endFOC = " << endFOC  << std::endl << std::flush;
+	std::cout << " startY " << startY  << std::endl << std::flush;
+	std::cout << " endY = " << endY  << std::endl << std::flush;
+	std::cout << "-4-> pdirection = " << pdirection << " Gdir = " << GetPdirection()
+	<< std::endl << std::flush;
+}
+//End Aleistert5
+
+void CreateFOCCmd::TrackMouse(TrackType aPhase, Point * /* anchorPoint */,
+	Point * /* previousPoint */, Point *nextPoint)
+{
+std::cout << "-M-> pdirection = " << pdirection << " Gdir = " << GetPdirection()
+<< std::endl << std::flush;std::cout << "MMMMM CreateFOCCmd::TrackMouse(" <<
+aPhase << ", -, -, " << *nextPoint << ") pdirection="<< pdirection << std::endl
+<< std::flush; 	LifeLine *l = (LifeLine *) shape;
+	switch(aPhase) {
+		case TRACK_PRESS:
+			GetMainWindow()->SetSizeCursor(pdirection);
+			CalcEndPoint(nextPoint);
+//			Draw();
+			break;
+		case TRACK_DRAG:
+//			l->UndrawTail(nextPoint);
+//			l->Undraw();
+			CalcEndPoint(nextPoint);
+			DrawFOC(nextPoint);
+//			Draw();
+			break;
+		case TRACK_RELEASE:
+//			Und raw();
+
+			l->DrawOutLineFOC(min(startFOC,endFOC), max(startFOC,endFOC));	//undraw
+//Begin Aleister6
+			if(!simetricResize) {
+				//Wilford 
+
+				//Wilford___antes:
+				//l->DrawOutLineFOC(min(startFOC,endY), max(startFOC,endY));
+
+				//Wilford___ahora:
+				if(startY==startFOC)
+					l->DrawOutLineFOC(min(endFOC,endY), max(endFOC,endY));		//draw
+				else
+		                	l->DrawOutLineFOC(min(startFOC,endY), max(startFOC,endY));		//draw
+				//Wilford ??????????????????????????????????????????
+			} else {
+				l->DrawOutLineFOC(min(endY, simetricEndY), max(endY, simetricEndY));
+			}
+//End Aleister6
+			GetMainWindow()->SetCursor(MouseCursor::LEFT_PTR);
+			break;
+		default:
+			error("unknown track type\n");
+			break;
+	}
+}
+
+
+void CreateFOCCmd::CalcEndPoint(const Point *p) {
+
+
+std::cout << " void CreateFOCCmd::CalcEndPoint(" << *p << ") GCt=" <<
+		shape->GetSubject()->GetClassType()  << std::endl << std::flush;
+
+	LifeLine *l = (LifeLine *) shape;
+//	l->Undraw();
+	int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT CalcEndPoint[" << *p << "] @end:" << yy << " p->y=" <<
+p->y << std::endl << std::flush;//	l->SetEndPositionY(p->y);
+//	l->SetPositionHandles();
+//	l->Draw();
+}
+
+
+void CreateFOCCmd::Draw() {
+std::cout << " *****************!!! void CreateFOCCmd::Draw() " << std::endl <<
+std::flush;//	shape->DrawOutLine(shape->GetPosition());
+//	LifeLine *l = (LifeLine *) shape;
+//	l->DrawOutLine(shape->GetPosition(), np->y);
+}
+
+
+
+void CreateFOCCmd::DrawFOC(const Point *np) {
+	LifeLine *l = (LifeLine *) shape;
+
+	int prevEndY = endY;	//prev end
+	endY = np->y;
+
+std::cout << " !____set_____! void CreateFOCCmd::DrawFOC( [" << startFOC << " :" << prevEndY << "-->" <<  endY << "] ) {" << std::endl << std::flush;
+
+	SetPdirection( (endY >= startFOC) ? 5 : 6 );
+	GetMainWindow()->SetSizeCursor(pdirection);
+//Begin Aleister6
+	if(!simetricResize) {
+	//Wilford
+		//Wilford___antes:
+		//l->DrawOutLineFOC(min(startFOC,prevEndY), max(startFOC,prevEndY));
+		//l->DrawOutLineFOC(min(startFOC,endY), max(startFOC,endY));
+
+		//Wilford___ahora:
+
+		if(startY==startFOC) {
+			l->DrawOutLineFOC(min(endFOC,prevEndY), max(endFOC,prevEndY));	//undraw prev endY
+			l->DrawOutLineFOC(min(endFOC,endY), max(endFOC,endY));			//draw new endY
+		}
+        	else {
+			l->DrawOutLineFOC(min(startFOC,prevEndY), max(startFOC,prevEndY));	//undraw prev endY
+			l->DrawOutLineFOC(min(startFOC,endY), max(startFOC,endY));			//draw new endY
+		}
+	} else {
+		int prevSimetricEndY = simetricEndY;
+
+		if(startY == startFOC) {
+			simetricEndY = endFOC - (endY - startFOC);
+		} else {
+			simetricEndY = startFOC + (endFOC - endY);
+		}
+		l->DrawOutLineFOC(min(prevEndY, prevSimetricEndY), max(prevEndY, prevSimetricEndY));	//undraw prevendY
+		l->DrawOutLineFOC(min(endY, simetricEndY), max(endY, simetricEndY));
+	}
+	//Wilford?????????????????????????????????????????????????????
+//Begin Aleister6//draw new endY
+}
+
+
+void CreateFOCCmd::Execute() {
+	LifeLine *l = (LifeLine *) shape;
+
+	if (startY == endY) {		//no action needed
+		GetMainWindow()->SetStatus("aborted: no changes");
+		Abort();
+		return;
+	}
+
+//head && tail check
+//Aleister mod
+	if ( (endY < (l->GetPosition()->y + l->GetHeight()/2)) ||
+	     (endY > l->GetEndPositionY()) ) {
+
+		GetMainWindow()->SetStatus("aborted: invalid FOC");
+		Abort();
+		return;
+	} /*Begin Aleister*/else {
+		if(simetricResize) {
+			if ( (simetricEndY < (l->GetPosition()->y + l->GetHeight()/2)) ||
+			     (simetricEndY > l->GetEndPositionY()) ) {
+
+				GetMainWindow()->SetStatus("aborted: invalid FOC");
+				Abort();
+				return;
+			}
+		}
+	}
+	/*End Aleister*/
+	// Begin Aleister7
+	if(l->IsOverlappingAnotherFOC(startFOC, endFOC, min(startFOC, endY), max(startFOC, endY))) {
+		std::cout<<"kokokoko"<<std::endl<<std::flush;
+		GetMainWindow()->SetStatus("aborted: overlapping FOC");
+		Abort();
+		return;
+	}
+
+	if(simetricResize) {
+		if(l->IsOverlappingAnotherFOC(startFOC, endFOC,
+					 min(startFOC, simetricEndY),
+					 max(startFOC, simetricEndY))) {
+			GetMainWindow()->SetStatus("aborted: overlapping FOC");
+			Abort();
+			return;
+		}
+	}
+	// End Aleister7
+//creating an new FOC block
+	if (startFOC == endFOC) { 	//creating an new FOC block
+		l->Undraw();
+		((SQObjectNode *)shape->GetSubject())->InsertAnchor(min(startFOC, endY), 2);
+		((SQObjectNode *)shape->GetSubject())->InsertAnchor(max(startFOC, endY), 3);
+		endFOC = max(startFOC, endY);
+		startFOC = min(startFOC, endY);
+		l->Draw();
+		shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+	}//creating an new FOC block
+
+//in existing FOC
+	else {  	//resizing an existing FOC block
+		//Aleister6 mod if(simetricResize) {}else {}
+		if(!simetricResize) {
+			if (startY == startFOC) {	//at top of FOC
+				if ( endY < startFOC ) {	//moved up
+	std::cout << " valid upper move " << std::endl << std::flush;
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 2);
+					startFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//moved up
+
+				if ( (endY > startFOC) &&
+					(endY < endFOC) ) {		//moved down
+	std::cout << " valid down move " << std::endl << std::flush;
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 2);
+					startFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//moved down
+
+				if ( endY > endFOC ) {		//moved down
+	std::cout << " valid down toggle " << std::endl << std::flush;
+
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endFOC, 2);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 3);
+					startFOC = endFOC;
+					endFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//toggled down
+			}	//at top of FOC
+
+
+			if (startY == endFOC) {	//at bottom of FOC
+				if (endY > endFOC) {		//moved down
+	std::cout << " valid down move " << std::endl << std::flush;
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 3);
+					endFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//moved up
+
+				if ((endY < endFOC) &&
+					(endY > startFOC)) {		//moved up within FOC
+	std::cout << " valid up move within FOC" << std::endl << std::flush;
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 3);
+					endFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//moved down
+
+				if ( endY < startFOC ) {		//toggled up
+	std::cout << " valid up toggle " << std::endl<< std::flush;
+
+					l->Undraw();
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+					((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(endY, 2);
+					((SQObjectNode *)shape->GetSubject())->InsertAnchor(startFOC, 3);
+					endFOC = startFOC;
+					startFOC = endY;
+					l->Draw();
+					shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+				}		//toggled down
+			}	//at bottom of FOC
+		} else {
+////////////////Begin Aleister6 Begin//////////////////////////////////
+			//Situaciones a validar
+			int newStartFOC = min(endY, simetricEndY);
+			int newEndFOC = max(endY, simetricEndY);
+
+			l->Undraw();
+
+			((SQObjectNode*)shape->GetSubject())->RemoveAnchor(startFOC,2);
+			((SQObjectNode*)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(newStartFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(newEndFOC, 3);
+
+			startFOC = newStartFOC;
+			endFOC = newEndFOC;
+			l->Draw();
+			shape->GetView()->GetViewer()->ShapePositionUpdate((GShape *)shape);
+		}
+	} 	//resizing an existing FOC block
+
+
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);
+//	GetMainWindow()->FitDocument();
+
+	Command::Execute();
+}
+
+
+void CreateFOCCmd::UnExecute() {
+
+std::cout << "UX: CreateFOCCmd: FOC=[" << startFOC << "-" << endFOC
+<< " y: " << startY << "<--" << endY << std::endl << std::flush;
+
+	LifeLine *l = (LifeLine *) shape;
+	l->Undraw();
+
+
+//removing a new FOC block
+	if ( ((startFOC == startY) && (endFOC == endY)) ||
+		 ((startFOC == endY) && (endFOC == startY)) ) {	//removing a FOC block
+std::cout << "ux: removing a new FOC block" << std::endl << std::flush; 
+		((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+		((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+
+		if (startY < endY) {
+std::cout << " ux: ### (startY < endY) : endFOC = startFOC; reset " << std::endl
+<< std::flush; 			endFOC = startFOC;		//reset
+		} else {
+std::cout << " ux: ### (startY >= endY) : startFOC = endFOC; reset " <<
+std::endl << std::flush; 			startFOC = endFOC;
+		}
+	}	//removing a FOC block
+
+	else if ( endY == startFOC ) {	// resize at startFOC _or_ toggle
+std::cout << "ux: (endY == startFOC) : resize at startFOC or toggle" << 
+std::endl << std::flush;
+		if ( startY < endFOC ) {
+std::cout << "ux: 		( startY < endFOC ) : @startFOC" << std::endl << std::flush;
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(startY, 2);
+			startFOC = startY;
+		}
+		else  {	//toggle
+std::cout << "ux: else 	(startY >= endFOC) : toggle" << std::endl << std::flush;
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+		//always remaining FOC
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(endFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(startY, 3);
+			startFOC = endFOC;
+			endFOC = startY;
+		}	//toggle
+
+	}	// resize at startFOC 
+
+	else if ( endY == endFOC ) {	// resize at endFOC _or_ toggle
+std::cout << "ux:  else if ( endY == endFOC ) : resize at endFOC or toggle" << 
+std::endl << std::flush;		if ( startY > startFOC ) {
+std::cout << "ux:  ( startY > startFOC ) {: @endFOC" << std::endl << std::flush;
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(startY, 3);
+			endFOC = startY;
+		}
+		else  {	//toggle
+std::cout << "ux:  else ( startY <= startFOC ) : toggle" << std::endl <<
+std::flush; 			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+		//always remaining FOC
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(startY, 2);
+			((SQObjectNode *)shape->GetSubject())->InsertAnchor(startFOC, 3);
+			endFOC = startFOC;	
+			startFOC = startY;
+		}	//toggle
+	}	// resize at endFOC 
+
+	l->Draw();
+
+//	shape->UpdateSize(int(0.5 + oldWidth), int(0.5 + oldHeight));
+	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);	
+
+std::cout << "==> UX AFTER: CreateFOCCmd: FOC=[" << startFOC << "-" << endFOC 
+<< " y: " << startY << "<--" << endY << std::endl << std::flush;
+
+	Command::UnExecute();
+}
diff -urN tcm-2.20/src/sd/dv/createfoccmd.h tcm-2.20+TSQD.orig/src/sd/dv/createfoccmd.h
--- tcm-2.20/src/sd/dv/createfoccmd.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/createfoccmd.h	2004-06-11 15:55:10.000000000 +0200
@@ -0,0 +1,88 @@
+//------------------------------------------------------------------------------

+// 

+// This file is part of Toolkit for Conceptual Modeling (TCM).

+// (c) copyright 2002, University of Twente.

+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).

+//

+// TCM is free software; you can redistribute it and/or modify

+// it under the terms of the GNU General Public License as published by

+// the Free Software Foundation; either version 2 of the License, or

+// (at your option) any later version.

+//

+// TCM is distributed in the hope that it will be useful,

+// but WITHOUT ANY WARRANTY; without even the implied warranty of

+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

+// GNU General Public License for more details.

+//

+// You should have received a copy of the GNU General Public License

+// along with TCM; if not, write to the Free Software

+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA

+// 02111-1307, USA.

+//-----------------------------------------------------------------------------

+#ifndef _CREATEFOCCMD_H

+#define _CREATEFOCCMD_H

+

+#include "command.h"

+#include "polypoint.h"

+#include "dpoint.h"

+class NodeShape;

+class GShape;

+

+/// abstract command class for pulling a shape's tail.

+class CreateFOCCmd: public Command {

+/*@Doc: {\large {\bf scope:} diagram} */

+public:

+	//Aleister5

+ 	CreateFOCCmd(GShape *s, int y, int startF, int endF, bool simetricResize);

+	///

+	CreateFOCCmd(GShape *s, int y, int startF, int endF);

+	///

+	void TrackMouse(TrackType aPhase, Point *anchorPoint,

+		Point *previousPoint, Point *nextPoint);

+	///

+	const char *GetName() const {return "pull shape FOC";}

+	///

+	void Execute();

+	///

+	void UnExecute();

+protected:

+	///

+	NodeShape *shape;

+	/// coordinates of the fix point of the figure.

+	DPoint fixpoint;

+	/// coordinates of the position of the shape.

+	PolyPoint centre;

+	/// coordinates of the moving corner of the shape.

+	PolyPoint corner;

+	///

+	int startFOC;

+	///

+	int endFOC;

+	///

+	int startY;

+	///

+	int endY;

+	///

+	int GetPdirection() const {return pdirection;}

+	///

+	void SetPdirection(int d) {pdirection=d;}

+	///

+	void CalcEndPoint(const Point *p);

+	///

+	void DrawFOC(const Point *np);

+	///

+	void Draw();

+	///

+	void Undraw() {

+		Draw();

+	}

+private:

+	///

+	int pdirection;

+

+	//Aleister5

+	bool simetricResize;

+	//Aleister5

+	int simetricEndY;

+};

+#endif

diff -urN tcm-2.20/src/sd/dv/createl2ledgecmd.c tcm-2.20+TSQD.orig/src/sd/dv/createl2ledgecmd.c
--- tcm-2.20/src/sd/dv/createl2ledgecmd.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/createl2ledgecmd.c	2004-03-25 14:19:14.000000000 +0100
@@ -0,0 +1,254 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2002, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+#include "drawwindow.h"
+#include "messagedialog.h"
+#include "shapeview.h"
+#include "edge.h"
+#include "line.h"
+#include "diagram.h"
+#include "diagramviewer.h"
+#include "grafport.h"
+#include "toolkit.h"
+#include "nodeshape.h"
+#include "createl2ledgecmd.h"
+#include "sqviewer.h"
+
+CreateL2LEdgeCmd::CreateL2LEdgeCmd(GShape *fs):
+	Command(fs->GetView()->GetViewer()->GetDiagram(), 
+		fs->GetView()->GetViewer()) {
+std::cout << " CreateL2LEdgeCmd::CreateL2LEdgeCmd(GShape *fs):" << std::endl << std::flush; 
+	view = fs->GetView();
+	diagram = fs->GetView()->GetViewer()->GetDiagram();
+	edge = 0;
+	line = 0;
+	fromShape = fs;
+	toShape = 0;
+	points = new List<Point *>;
+	GetViewer()->SetZigZag(True);
+	connectEdges = Toolkit::EditorWithInterEdgeConnections(
+                        GetMainWindow()->GetTool());
+}
+
+void CreateL2LEdgeCmd::EraseLines() {
+std::cout << " void CreateL2LEdgeCmd::EraseLines() {" << std::endl << std::flush; 
+	Point *pt1, *pt2;
+	if (!check(points->first()))
+		return;
+	pt1 = pt2 = points->cur();
+	GetGrafport()->SetLineWidth(1);
+        GetGrafport()->SetForegroundColor("black");
+	while(points->next()) {
+		pt2 = points->cur();
+		GetGrafport()->DrawEditLine(pt1->x, pt1->y, pt2->x, pt2->y);
+		GetGrafport()->DrawEditPoint(pt2->x, pt2->y);
+		pt1 = pt2;
+	}
+	GetGrafport()->DrawEditPoint(pt2->x, pt2->y);
+}
+
+
+void CreateL2LEdgeCmd::TrackMouse(TrackType aPhase,
+	Point *anchorPoint, Point *previousPoint, Point *nextPoint) {
+std::cout << " #### CreateL2LEdgeCmd::TrackMouse(" << (int) aPhase << ", " <<
+	*anchorPoint << "," <<  *previousPoint << "," <<  *nextPoint << ")" << std::endl << std::flush;
+	int x,y;
+	GetGrafport()->SetLineWidth(1);
+        GetGrafport()->SetForegroundColor("black");
+	switch(aPhase) {
+		case TRACK_PRESS:
+			GetMainWindow()->SetCursor(MouseCursor::PLUS);
+			GetGrafport()->DrawEditLine(anchorPoint->x,
+				anchorPoint->y, nextPoint->x, nextPoint->y);
+			AddPoint(anchorPoint);
+			break;
+		case TRACK_DRAG:
+			GetGrafport()->DrawEditLine(
+				anchorPoint->x, anchorPoint->y,
+				previousPoint->x, previousPoint->y);
+			GetGrafport()->DrawEditLine(anchorPoint->x,
+				anchorPoint->y, nextPoint->x, nextPoint->y);
+			abortPoint = *nextPoint;
+			break;
+		case TRACK_UP:
+			// erase old line
+			GetGrafport()->DrawEditLine(
+				anchorPoint->x, anchorPoint->y,
+				previousPoint->x, previousPoint->y);
+			// draw temporary
+			GetGrafport()->DrawEditLine(anchorPoint->x,
+				anchorPoint->y, nextPoint->x, nextPoint->y);
+			AddPoint(nextPoint);
+			// where was the mouse released
+			x = int(0.5 + ScaleCorrect(nextPoint->x));
+			y = int(0.5 + ScaleCorrect(nextPoint->y));
+			if (connectEdges)
+				toShape = view->HitShape(x, y);
+			else
+				toShape = view->HitNodeShape(x, y);
+			if (toShape) 
+				TrackMouse(TRACK_RELEASE, anchorPoint,
+					previousPoint, nextPoint);
+			break;
+		case TRACK_RELEASE:
+std::cout << " TRL 1 " << std::endl << std::flush; 
+			GetMainWindow()->SetCursor(MouseCursor::LEFT_PTR);
+std::cout << " TRL 2 " << std::endl << std::flush; 
+			EraseLines();
+std::cout << " TRL 3 " << std::endl << std::flush; 
+			GetViewer()->SetZigZag(False);
+std::cout << " TRL 4 " << std::endl << std::flush; 
+			GetViewer()->ExecuteCommand();
+std::cout << " TRL 5 " << std::endl << std::flush; 
+			break;
+		default:
+			error("unknown track type\n");
+			break;
+	}
+}
+
+
+void CreateL2LEdgeCmd::Execute() {
+std::cout << " void CreateL2LEdgeCmd::Execute() {" << std::endl << std::flush; 
+
+	Subject *n1 = fromShape->GetSubject();
+	Subject *n2 = toShape->GetSubject();
+
+	if (!check(n1) || !check(n2))
+		return;
+	if (fromShape == toShape)
+		if (points->count() <= 3 && !diagram->IsCurve()) {
+			GetMainWindow()->SetStatus(
+				"aborted: 2 intermediate points needed");
+			(new MessageDialog(GetMainWindow()->GetWidget(),
+			MessageDialog::ERROR))->
+			  Show("Error", 
+			  "An edge from and to the same shape requires\n"
+			  " at least two intermediate points.");
+			Command::Abort();
+			return;
+		}
+	if (diagram->IsCurve()) {
+		if (points->count() != 4) {
+			GetMainWindow()->SetStatus(
+				"aborted: 2 intermediate points needed");
+			(new MessageDialog(GetMainWindow()->GetWidget(),
+			MessageDialog::ERROR))->Show("Error", 
+			  "A curve requires exactly two intermediate points.");
+			Command::Abort();
+			return;
+		}
+	}
+	if ((fromShape->IsLine() && ((Line*)fromShape)->IsCurved()) ||
+	    (toShape->IsLine() && ((Line*)toShape)->IsCurved())) {
+			GetMainWindow()->SetStatus(
+				"aborted: cannot connect to a curve");
+			(new MessageDialog(GetMainWindow()->GetWidget(),
+				MessageDialog::ERROR))->Show("Error", 
+			  "It is not possible to connect to a curve");
+			Command::Abort();
+			return;
+	}
+
+
+
+std::cout << " CHECK INVALID CONNECT == " 
+<< ((SQViewer *)GetViewer())->IsInvalidConnect() << std::endl << std::flush; 
+
+	if (((SQViewer *)GetViewer())->IsInvalidConnect()) {
+
+std::cout << " Aborting invalid connect " << std::endl << std::flush; 
+
+			GetMainWindow()->SetStatus(
+				"aborted: cannot connect to objectbox");
+			(new MessageDialog(GetMainWindow()->GetWidget(),
+				MessageDialog::ERROR))->Show("Error", 
+			  "It is not possible to connect to an objectbox");
+			Command::Abort();
+			return;
+	}
+
+
+	// correct to internal coordinates and make them positive.
+	for (points->first(); !points->done(); points->next()) {
+		Point *pt = points->cur();
+		view->Snap(pt);
+		*pt = ScaleCorrect(pt);
+		if (pt->x <= 0)
+			pt->x = 1;	 
+		if (pt->y <= 0)
+			pt->y = 1;
+	}
+	edge  = diagram->CreateEdge(n1, n2);
+	if (edge) {
+		line = diagram->CreateLine(edge, fromShape, toShape, points);
+		if (line) {
+			ReExecute();
+			GetMainWindow()->FitDocument();
+			return;
+		}
+	}
+	GetMainWindow()->SetStatus("aborted: edge could not be created");
+	Command::Abort();
+}
+
+void CreateL2LEdgeCmd::UnExecute() {
+std::cout << " void CreateL2LEdgeCmd::UnExecute() {" << std::endl << std::flush; 
+	if (edge && line) {
+		view->RemoveShape(line);
+		diagram->RemoveSubject(edge);
+		Command::UnExecute();
+	}
+}
+
+void CreateL2LEdgeCmd::ReExecute() {
+std::cout << " void CreateL2LEdgeCmd::ReExecute() {" << std::endl << std::flush; 
+	if (edge && line) {
+		view->DeselectAll();
+		view->AddShape(line);
+		view->SelectShape(line);
+		diagram->AddSubject(edge);
+		Command::Execute();
+	}
+}
+
+void CreateL2LEdgeCmd::Abort() {
+std::cout << " void CreateL2LEdgeCmd::Abort() {" << std::endl << std::flush; 
+	AddPoint(&abortPoint);
+	EraseLines();
+	GetViewer()->SetZigZag(False);
+	SayAborted();
+	Command::Abort();
+}
+
+CreateL2LEdgeCmd::~CreateL2LEdgeCmd() {
+std::cout << " CreateL2LEdgeCmd::~CreateL2LEdgeCmd() {" << std::endl << std::flush; 
+	if (!CmdDone()) {
+		if (edge)
+			delete edge;
+		if (line)
+			delete line;
+	}
+	if (points) {
+		points->clear();
+		delete points;
+	}
+}
diff -urN tcm-2.20/src/sd/dv/createl2ledgecmd.h tcm-2.20+TSQD.orig/src/sd/dv/createl2ledgecmd.h
--- tcm-2.20/src/sd/dv/createl2ledgecmd.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/createl2ledgecmd.h	2002-08-23 12:26:27.000000000 +0200
@@ -0,0 +1,82 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1995, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _CREATEL2LEDGECMD_H
+#define _CREATEL2LEDGECMD_H
+
+
+#include "command.h"
+#include "point.h"
+#include "llist.h"
+class Edge;
+class Line;
+class GShape;
+class ShapeView;
+class Diagram;
+
+/// command class for creating edges between LifeLines
+class CreateL2LEdgeCmd: public Command {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	CreateL2LEdgeCmd(GShape *from);
+	///
+	virtual ~CreateL2LEdgeCmd();
+	///
+	void TrackMouse(TrackType aPhase, Point *anchorPoint, 
+		Point *previousPoint, Point *nextPoint);
+	///
+	void Execute();
+	///
+	void UnExecute();
+	///
+	void ReExecute();
+	///
+	void Abort();
+	///
+	const char *GetName() const {return "create l2l edge";}
+
+protected:
+	///
+	void AddPoint(Point *pt) {points->add(new Point(pt->x, pt->y));}
+	///
+	void EraseLines();
+private:
+	///
+	Diagram *diagram;
+	///
+	ShapeView *view;
+	///
+	Edge *edge;
+	///
+	Line *line;
+	///
+	GShape *fromShape;
+	///
+	GShape *toShape;
+	///
+	List<Point *> *points;
+	///
+	Point abortPoint;
+	///
+	bool connectEdges;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/lifeline.c tcm-2.20+TSQD.orig/src/sd/dv/lifeline.c
--- tcm-2.20/src/sd/dv/lifeline.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/lifeline.c	2004-07-10 00:42:27.000000000 +0200
@@ -0,0 +1,889 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, Universiteit Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+
+#include "lifeline.h"
+#include "inputfile.h"
+#include "outputfile.h"
+#include "subject.h"
+#include "grafport.h"
+#include "sqobjectnode.h"
+#include "shapetype.h"
+#include "polypoint.h"
+#include "intersect.h"
+#include "diagram.h"
+#include "diagramviewer.h"
+#include "sqviewer.h"
+#include <limits.h>
+
+const int LifeLine::LIFELINE_WIDTH = 80;
+const int LifeLine::LIFELINE_HEIGHT = 40;
+
+const ShapeType LifeLine::llType(Code::BOX,
+	LIFELINE_WIDTH, LIFELINE_HEIGHT, 0.0, 0.0,
+	&Polygon::Box, &Polygon::Box1, &PolyPoint::Index, &PolyPoint::Dupli,
+	&PolyPoint::Multi, &Polygon::Box);
+
+LifeLine::LifeLine(ShapeView *v, Grafport *g, double x, double y)
+	:NodeShape(v, g, x, y, &llType)
+{
+    GetName()->SetUnderlined(True);
+	endPosition.x = GetPosition()->x;
+	endPosition.y = GetPosition()->y + 400;
+
+	destructive = False;	//init
+}
+
+LifeLine::LifeLine(const NodeShape &c)
+	:NodeShape(c, &llType)
+{
+        GetName()->SetUnderlined(True);
+}
+
+
+
+
+void LifeLine::WriteMembers(OutputFile *ofile) {
+	NodeShape::WriteMembers(ofile);
+	(*ofile) << "\t{ EndPosition " << endPosition  << " }\n";
+	(*ofile) << "\t{ Destructive " << (int) destructive << " }\n";
+}
+
+bool LifeLine::ReadMembers(InputFile *ifile, double format) {
+std::cout << "a" << std::endl << std::flush;
+	if (!NodeShape::ReadMembers(ifile, format))
+		return False;
+std::cout << "b" << std::endl << std::flush;
+	if (format >= 1.32) {	//HZ : AnchorNode patch
+std::cout << "eP" << std::endl << std::flush;
+		string val1, val2;
+		if (!ifile->ReadAttribute2("EndPosition", &val1, &val2)) {
+std::cout << "Wrong EndPos: " << std::endl << std::flush;
+			return False;
+		}
+std::cout << "Got EndPos [" << val1 << ", " << val2 << "]" << std::endl << std::flush;
+		endPosition.x = val1.toint();
+		endPosition.y = val2.toint();
+
+
+
+		string val;
+		if (!ifile->ReadAttribute("Destructive", &val))	{
+std::cout << "Wrong DESTR: " << std::endl << std::flush;
+			return False;
+		}
+std::cout << "Got DESTR = " << val << std::endl << std::flush;
+		destructive = (val1 %= "True");
+	}
+
+
+
+	return True;
+}
+
+
+
+void LifeLine::DrawOutLine(double x, double y, double w, double h) {
+std::cout << " !!! void LifeLine::DrawOutLine(" << x << ", " << y << ", " << w
+<< ", " << h << ")" << std::endl << std::flush;
+
+std::cout << " GetPosition = " << *GetPosition() << std::endl << std::flush; 
+std::cout << " GetHeight = " << GetHeight() << std::endl << std::flush; 
+std::cout << " EndPosition = " << endPosition << std::endl << std::flush; 
+
+	NodeShape::DrawOutLine(x, y, w, h);
+
+
+	GetGrafport()->SetLineStyle(LineStyle::DOTTED);
+	GetGrafport()->DrawLine((double) x, (double) (y + h/2),
+							(double) x, (double) endPosition.y);	
+	GetGrafport()->SetLineStyle(LineStyle::SOLID);
+
+}
+
+
+
+void LifeLine::DrawOutLine(const Point *center, double t) {
+std::cout << " !TTT! void LifeLine::DrawOutLine(" << *center 
+<< ", T=" << t << ")" << std::endl << std::flush;
+	DrawOutLine(center->x, center->y,
+				GetWidth(), GetHeight());
+
+	GetGrafport()->SetLineStyle(LineStyle::SOLID);
+//Z	GetGrafport()->DrawLine((double) endPosition.x, (double) endPosition.y,
+//Z											(double) endPosition.x, t);	
+	GetGrafport()->SetLineStyle(LineStyle::DASHED);
+
+}
+
+
+void LifeLine::DrawOutLineTail(const Point *center, double t) {
+std::cout << " !T__tail__T! void LifeLine::DrawOutLineTail(" << *center 
+<< ", T=" << t << ")" << std::endl << std::flush;
+
+	GetGrafport()->SetLineStyle(LineStyle::DOTTED);
+	GetGrafport()->DrawLine((double) center->x, (double) center->y,
+											(double) endPosition.x, t);	
+	GetGrafport()->SetLineStyle(LineStyle::DASHED);
+
+}
+
+
+
+
+void LifeLine::DrawOutLineFOC(double startFOC, double endFOC) {
+std::cout << " !T__FOC__T! void LifeLine::DrawOutLineFOC(" << startFOC
+<< "-->" << endFOC << ")" << std::endl << std::flush;
+
+	GetGrafport()->SetLineStyle(LineStyle::DOTTED);
+	GetGrafport()->DrawRectangle( (double) GetPosition()->x - 5, startFOC, 10, endFOC - startFOC );
+	GetGrafport()->SetLineStyle(LineStyle::DASHED);
+}
+
+void LifeLine::DrawShape() {
+std::cout << " void LifeLine::DrawShape() {"
+<< GetPosition()->y << " -d- " << endPosition.y
+<< std::endl << std::flush;
+
+	if (GetPosition()->x != endPosition.x) {
+		endPosition.x = GetPosition()->x;
+	}
+
+	NodeShape::DrawShape();
+std::cout << " GetPosition = " << *GetPosition() << std::endl << std::flush;
+std::cout << " GetHeight = " << GetHeight() << std::endl << std::flush;
+
+
+std::cout << " EndPosition = " << endPosition << std::endl << std::flush;
+
+	//AleisterMod 20
+	/*if (check(GetSubject() &&
+		  GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {*/
+
+std::cout << "GetSubject()->GetId()  = " << GetSubject()->GetId()
+//<< " GetName.getstr=" << *GetSubject()->GetName()->getstr()
+<< std::endl << std::flush;
+
+std::cout << "NrAnchors =" << ((SQObjectNode *)GetSubject())->NrAnchors() << std::endl << std::flush;
+
+		List<Point *> *apoints;
+		DPoint *prev = new DPoint ((double) GetPosition()->x,
+								(double) (GetPosition()->y + GetHeight()/2) );
+		apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+std::cout << "NrAnchors2 =" << apoints->count() << std::endl << std::flush;
+
+
+		for(apoints->first(); !apoints->done(); apoints->next()) {
+			Point *ap = apoints->cur();
+			Point p = *apoints->cur();
+std::cout << "*ap=" << *ap << " p=" << p << std::endl << std::flush;
+
+			switch (p.y) {
+				case 2:
+					std::cout << " Start FOC : " << p << std::endl << std::flush;
+					GetGrafport()->SetLineStyle(LineStyle::DASHED);
+					GetGrafport()->DrawLine(prev->x, prev->y,
+											(double) prev->x, (double) p.x);
+					prev->y = p.x;
+					break;
+				case 3:
+					std::cout << " End FOC : " << p << std::endl << std::flush;
+					GetGrafport()->SetLineStyle(LineStyle::SOLID);
+//					GetGrafport()->DrawLine((double) prev->x, (double) prev->y,
+//											(double) prev->x, (double) p.x);
+					GetGrafport()->DrawRectangle( (double) prev->x - 5,
+												  (double) prev->y,
+												  10,
+												  (double) p.x - prev->y );
+
+					prev->y = p.x;
+					break;
+				default:
+					std::cout << " ignored : " << p << std::endl << std::flush;
+					break;
+			}
+		}
+
+
+		if (prev->y != endPosition.y) {
+std::cout << "Finishing " << std::endl << std::flush;
+			GetGrafport()->SetLineStyle(LineStyle::DASHED);
+			GetGrafport()->DrawLine((double) prev->x, (double) prev->y,
+									(double) endPosition.x,
+									(double) endPosition.y);
+		}
+
+	//AleisterMod 20
+	/*}*/
+
+
+std::cout << " going 2 DrawDuplicate? " << IsDuplicate() << std::endl << std::flush;
+	if (IsDuplicate())
+		DrawDuplicate();
+
+//	GetGrafport()->SetLineStyle(LineStyle::DASHED);
+//	GetGrafport()->DrawLine((double) GetPosition()->x,
+//					(double) (GetPosition()->y + GetHeight()/2),
+//							(double) endPosition.x, (double) endPosition.y);
+//	GetGrafport()->SetLineStyle(LineStyle::SOLID);
+
+}
+
+
+void LifeLine::UndrawShape() {
+std::cout << " void LifeLine::UndrawShape() {"
+<< GetPosition()->y << " -u- " << endPosition.y
+<< std::endl << std::flush;
+	DrawShape();
+}
+
+
+
+
+/* virtual */ Point LifeLine::GiveSnp(Point to) const {
+std::cout << "___ Point LifeLine::GiveSnp([" << to << "]) ep="
+<< endPosition.x << std::endl << std::flush;
+
+	Point p1 = NodeShape::GiveSnp(to);
+//	return p1;
+
+	Point p2 = to;
+	if (p2.x != endPosition.x)
+		p2.x = endPosition.x;
+
+std::cout << " p1 = " << p1 << " => p2 = " << p2 << std::endl << std::flush;
+	return p2;
+
+}
+
+// Begin Aleister7
+bool LifeLine::IsOverlappingAnotherFOC(int prevStartFOC,
+					int prevEndFOC,
+					int startFOC, int endFOC) {
+	if (check(GetSubject() &&
+		  GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {
+		List<Point *> *apoints;
+		apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+		bool in_FOC = False;
+
+		for(apoints->first(); !apoints->done(); apoints->next()) {
+			Point *ap = apoints->cur();
+
+			if(ap->y == 2) {
+				// FOC
+				if(ap->x != prevStartFOC) {
+					if(ap->x >= startFOC &&
+					   ap->x <= endFOC) {
+						in_FOC = True;
+					}
+				}
+			} else {
+			if(ap->y == 3) {
+				// FOC
+				if (ap->x != prevEndFOC) {
+					if(ap->x <= endFOC &&
+					   ap->x >= startFOC) {
+						in_FOC = True;
+					}
+				}
+			}
+			}
+		}
+
+		return (in_FOC);
+	}
+
+	return False;
+}
+// End Aleister7
+
+bool LifeLine::PtInFOCblock(int x, int y) const {
+std::cout << " bool LifeLine::PtInFOCblock(" << x << "," << y << ") @["
+<< *GetPosition() << "]" << std::endl << std::flush;
+
+	Rectangle rect(GetPosition()->x - 5,
+					GetPosition()->y + GetHeight()/2,
+					10,
+					endPosition.y - (GetPosition()->y + GetHeight()/2));
+	if (rect.Inside(x, y)) {
+		std::cout << "PtInFOCblock: inside rect (" << std::endl << std::flush;
+
+
+		if (check(GetSubject() &&
+		  	GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {
+
+
+
+std::cout << "_F_GetSubject()->GetId()  = " << GetSubject()->GetId()
+//<< " GetName.getstr=" << *GetSubject()->GetName()->getstr()
+<< std::endl << std::flush;
+
+std::cout << "_F_NrAnchors =" << ((SQObjectNode *)GetSubject())->NrAnchors() << std::endl << std::flush;
+
+			List<Point *> *apoints;
+			DPoint *prev = new DPoint ((double) GetPosition()->x,
+									(double) (GetPosition()->y + GetHeight()/2) );
+			apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+std::cout << "_F_NrAnchors2 =" << apoints->count() << std::endl << std::flush;
+
+			int start_FOC = INT_MAX;
+			int end_FOC = 0;
+			bool in_FOC = False;
+
+			for(apoints->first(); !apoints->done(); apoints->next()) {
+				Point *ap = apoints->cur();
+				Point p = *apoints->cur();
+std::cout << "FOC*ap=" << *ap << " p=" << p << std::endl << std::flush;
+
+				if (!in_FOC) {
+					switch (p.y) {
+						case 2:
+							std::cout << "_F_Start FOC : " << p << std::endl << std::flush;
+							start_FOC = p.x;
+							break;
+						case 3:
+							std::cout << "_F_End FOC : " << p << std::endl << std::flush;
+							if (y >= start_FOC && y <= p.x) {
+std::cout << " Point [" << x << ", " << y << "] in FOC! " << std::endl << std::flush;
+								in_FOC = True;
+								end_FOC = p.x;
+							}
+							else
+								start_FOC = INT_MAX;		//reset
+							break;
+						default:
+							std::cout << "_F_ignored : " << p << std::endl << std::flush;
+							break;
+					}
+				}
+			}
+
+
+std::cout << "--F---> PtInFOCblok: in_FOC=" << in_FOC << "[" << start_FOC << "->"
+<< end_FOC <<"]" << std::endl << std::flush;
+
+			return (in_FOC);
+		}
+
+		return False;
+	}
+	else {
+		std::cout << "PtInFOCBlock: NOT inside rect " << std::endl << std::flush;
+		return False;
+	}
+}
+
+
+bool LifeLine::PtInFOCblock(int x, int y, int *start, int *end) const {
+std::cout << " bool LifeLine::PtInFOCblock(" << x << "," << y << ", start, end ) @["
+<< *GetPosition() << "]" << std::endl << std::flush;
+
+	Rectangle rect(GetPosition()->x - 5,
+					GetPosition()->y + GetHeight()/2,
+					10,
+					endPosition.y - (GetPosition()->y + GetHeight()/2));
+	if (rect.Inside(x, y)) {
+		std::cout << "_R_PtInFOCblock: inside rect (" << std::endl << std::flush; 
+
+
+		if (check(GetSubject() &&
+		  	GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {
+		  	
+
+
+std::cout << "_R_GetSubject()->GetId()  = " << GetSubject()->GetId()  
+//<< " GetName.getstr=" << *GetSubject()->GetName()->getstr()
+<< std::endl << std::flush; 
+
+std::cout << "_R_NrAnchors =" << ((SQObjectNode *)GetSubject())->NrAnchors() << std::endl << std::flush; 
+
+			List<Point *> *apoints;
+			DPoint *prev = new DPoint ((double) GetPosition()->x,
+									(double) (GetPosition()->y + GetHeight()/2) );
+			apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+std::cout << "_R_NrAnchors2 =" << apoints->count() << std::endl << std::flush; 
+
+			int start_FOC = INT_MAX;
+			int end_FOC = 0;
+			bool in_FOC = False;
+
+			for(apoints->first(); !apoints->done(); apoints->next()) {
+				Point *ap = apoints->cur();
+				Point p = *apoints->cur();
+std::cout << "_R_FOC*ap=" << *ap << " p=" << p << std::endl << std::flush;
+
+				if (!in_FOC) {
+					switch (p.y) {
+						case 2:
+							std::cout << "_R_Start FOC : " << p << std::endl << std::flush; 
+							start_FOC = p.x;
+							break;
+						case 3:
+							std::cout << "_R_End FOC : " << p << std::endl << std::flush; 
+							if (y >= start_FOC && y <= p.x) {
+std::cout << "_R_ Point [" << x << ", " << y << "] in FOC! " << std::endl << std::flush;
+								in_FOC = True;
+								end_FOC = p.x;
+							}
+							else
+								start_FOC = INT_MAX;		//reset
+							break;
+						default:
+							std::cout << "_R_ignored : " << p << std::endl << std::flush; 
+							break;
+					}
+				}
+			}
+
+
+std::cout << "--R---> PtInFOCblok: in_FOC=" << in_FOC << "[" << start_FOC << "->" 
+<< end_FOC <<"]" << std::endl << std::flush; 
+			*start = start_FOC;
+			*end = end_FOC;
+			return (in_FOC);
+		}
+
+		return False;
+	}
+	else {
+		std::cout << "_R_PtInFOCBlock: NOT inside rect " << std::endl << std::flush;
+		return False;
+	}
+}
+
+
+bool LifeLine::PtInFOCarea(int x, int y) const {
+std::cout << " bool LifeLine::PtInFOCarea(" << x << "," << y << ") @[" 
+<< *GetPosition() << "]" << std::endl << std::flush;
+
+	Rectangle rect(GetPosition()->x - 5,
+					GetPosition()->y + GetHeight()/2,
+					10,
+					endPosition.y - (GetPosition()->y + GetHeight()/2));
+	if (rect.Inside(x, y)) {
+		std::cout << "PtInFOCarea: inside rect (" << std::endl << std::flush; 
+		return True;
+	} else {
+		std::cout << "PtInFOCarea: NOT inside rect " << std::endl << std::flush; 
+		return False;
+	}
+//	return (rect.Inside(x, y));
+}
+
+
+bool LifeLine::IsOverlappingFOC(int startFOC, int endFOC) const {
+std::cout << " bool LifeLine::IsOverlappingFOC(" << startFOC << ", " << endFOC << ")" << std::endl << std::flush;
+
+		if (check(GetSubject() &&
+		  	GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {
+
+
+
+std::cout << "_O_GetSubject()->GetId()  = " << GetSubject()->GetId()
+//<< " GetName.getstr=" << *GetSubject()->GetName()->getstr()
+<< std::endl << std::flush;
+
+std::cout << "_O_NrAnchors =" << ((SQObjectNode *)GetSubject())->NrAnchors() << std::endl << std::flush;
+
+			List<Point *> *apoints;
+			apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+std::cout << "_O_NrAnchors2 =" << apoints->count() << std::endl << std::flush;
+
+			bool in_FOC = False;
+
+			for(apoints->first(); !apoints->done(); apoints->next()) {
+				Point *ap = apoints->cur();
+				Point p = *apoints->cur();
+std::cout << "_O_FOC*ap=" << *ap << " p=" << p << std::endl << std::flush;
+
+				if ( (ap->x > startFOC) && (ap->x < endFOC) ) {		//excluding borders
+std::cout << " #### GOT IT: [" << startFOC << " <- " << ap->x << " -> " << endFOC << "]" << std::endl << std::flush;
+					in_FOC = True;
+				}
+			}
+
+std::cout << "--O--> IsOverlappingFOC(" << startFOC << ", " << endFOC << ") ==> " << in_FOC << std::endl << std::flush;
+
+			return (in_FOC);
+		}
+
+std::cout << " NOT A Code::CBD_OBJECT_NODE ??? " << std::endl << std::flush;
+		return False;
+}
+
+
+
+/* virtual */ Point LifeLine::GiveAnchorSnp(Point ap, Point to) const {
+std::cout << " Point LifeLine::GiveAnchorSnp([" << ap << "], ->[" << to << "] <" 
+<< GetPosition()->x << "> )" << std::endl << std::flush;
+
+
+	Point ref = ap;
+	Point p1 = ap;
+std::cout << " ap=" << ap << " - ref =" << ref << std::endl << std::flush; 
+
+	if (ref.x != GetPosition()->x) {
+std::cout << "DIFF in X: " << ref.x << " <-> " << GetPosition()->x << std::endl << std::flush; 
+		ref.x = GetPosition()->x;
+	}
+
+	if (PtInFOCblock(ap.x, ap.y))
+		p1 = Intersect::BoxIntersects(ap, to, 10, 10);
+	else
+		p1 = Intersect::BoxIntersects(ref, to, 1, 1);
+
+std::cout << " p1 = " << p1 << std::endl << std::flush; 
+	return p1;
+
+}
+
+
+
+/* virtual */ Point LifeLine::GiveSnp(Point to, int order, int count,
+	int &) /* const */
+{
+std::cout << "Point LifeLine::GiveSnp([" << to << "], " <<  order 
+	<< ", {" << count << "})" << std::endl << std::flush; 
+
+	int dum = 4;
+	int *dumm = &dum;
+	int *dummy = new int(3);
+
+std::cout << "dum=" << dum << " *dumm=" << *dumm << "*dummy=" << *dummy << std::endl << std::flush;
+
+	Point p1 = NodeShape::GiveSnp(to, order, count, dum ) ;
+	Point p2 = NodeShape::GiveSnp(to, order, count, *dumm ) ;
+std::cout << " p1 = " << p1 << std::endl << std::flush; 
+	return p1;
+
+}
+
+
+Point LifeLine::GiveOrthoSnp(double dx, double dy, double hs, double vs,
+		double tw, double th) const {
+std::cout << "$$$ Point LifeLine::GiveOrthoSnp(" << dx << "," << dy << "," 
+<< hs << "," << vs << "," << tw << "," << th 
+<< std::endl << std::flush; 
+	Point *np = new Point (333, 333);
+std::cout << " new Poitn ==> " << *np << std::endl << std::flush; 
+	return *np;
+}
+
+
+
+Point LifeLine::GiveOrthoSnp(Point p) const {
+std::cout << "$$$ Point LifeLine::GiveOrthoSnp(" << p << ") ep="
+<< endPosition.x 
+<< std::endl <<std::flush; 
+	Point dummy = endPosition;
+	dummy.y = 300;
+	Point np = GiveAnchorSnp(dummy, p);
+std::cout << " GiveAnchorSnp : " << np << " ==> " << p << std::endl << std::flush; 
+	return np;
+}
+
+
+
+TextShape *LifeLine::ChooseTextShape(int x, int y) {
+
+std::cout << "TextShape *LifeLine::ChooseTextShape(" << x << "," << y <<") "
+<< std::endl << std::flush;
+
+std::cout << " GetPosition = " << *GetPosition() << std::endl << std::flush; 
+std::cout << " GetHeight = " << GetHeight() << std::endl << std::flush; 
+std::cout << " EndPosition = " << endPosition << std::endl << std::flush; 
+std::cout << " CalcBottomRight = " << GetShapeType()->CalcBottomRight().GetXHorizScaled() << std::endl << std::flush; 
+
+	Rectangle rect2(GetPosition()->x - 5,
+					GetPosition()->y + GetHeight()/2,
+					10,
+					endPosition.y - (GetPosition()->y + GetHeight()/2));
+
+	return NodeShape::ChooseTextShape(x, y);
+}
+
+
+
+
+bool LifeLine::ContainsPt(int x, int y) {
+std::cout << "****** bool LifeLine::ContainsPt(" << x << "," << y << ")" << std::endl << std::flush;
+std::cout << " CONNECT CHECK: IsInConnectMode()="
+	<< ((SQViewer *)GetViewer())->IsInConnectMode() << std::endl << std::flush;
+std::cout << " prevPos=" << prevPosition << " pos= " << *GetPosition() <<std::endl<<std::flush;
+
+
+//	bool thisInFOCblock = False; 	//default init
+
+//A	((SQViewer *)GetViewer())->SetInFOCblock(False);	//default init
+
+	Rectangle rect(GetPosition()->x - 11,
+					GetPosition()->y + GetHeight()/2,
+					22,
+					endPosition.y - (GetPosition()->y + GetHeight()/2));
+	if (rect.Inside(x, y)) {
+		std::cout << ">>> inside rect (" << std::endl << std::flush; 
+
+
+		if (check(GetSubject() &&
+		  	GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) {
+		  	
+
+
+std::cout << "__GetSubject()->GetId()  = " << GetSubject()->GetId()  
+//<< " GetName.getstr=" << *GetSubject()->GetName()->getstr()
+<< std::endl << std::flush; 
+
+std::cout << "__NrAnchors =" << ((SQObjectNode *)GetSubject())->NrAnchors() << std::endl << std::flush; 
+
+			List<Point *> *apoints;
+//			DPoint *prev = new DPoint ((double) GetPosition()->x,
+//									(double) (GetPosition()->y + GetHeight()/2) );
+			apoints = ((SQObjectNode *)GetSubject())->GetAnchors();
+
+std::cout << "__NrAnchors2 =" << apoints->count() << std::endl << std::flush; 
+
+			int start_FOC = INT_MAX;
+			int end_FOC = 0;
+			bool in_FOC = False;
+
+			for(apoints->first(); !apoints->done(); apoints->next()) {
+				Point *ap = apoints->cur();
+				Point p = *apoints->cur();
+std::cout << "*ap=" << *ap << " p=" << p << std::endl << std::flush;
+
+				if (!in_FOC) {
+					switch (p.y) {
+						case 2:
+							std::cout << "__Start FOC : " << p << std::endl << std::flush; 
+							start_FOC = p.x;
+							break;
+						case 3:
+							std::cout << "__End FOC : " << p << std::endl << std::flush; 
+							if (y >= start_FOC && y <= p.x) {
+std::cout << " Point [" << x << ", " << y << "] in FOC! " << std::endl << std::flush; 
+								in_FOC = True;
+								end_FOC = p.x;
+							}
+							else
+								start_FOC = INT_MAX;		//reset
+							break;
+						default:
+							std::cout << "__ignored : " << p << std::endl << std::flush;
+							break;
+					}
+				}
+			}
+
+
+std::cout << " in_FOC=" << in_FOC << "[" << start_FOC << "->" 
+<< end_FOC <<"]" << std::endl << std::flush; 
+//std::cout << " GNT=" << GetNodeType() << std::endl << std::flush; 
+//std::cout << " GdNT=" << GetDefaultNodeType() << std::endl << std::flush; 
+
+			if (in_FOC) {
+				//UndrawSelect();
+
+//A				((SQViewer *)GetViewer())->SetInFOCblock(True);
+
+/* ****** *******
+
+				Point old_tl = *GetTopLeft();
+std::cout << " old_tl=[" << old_tl << "]" << std::endl << std::flush; 
+
+				prevPosition = *GetPosition();
+
+
+				int prevWidth = GetWidth();
+				int prevHeight = GetHeight();
+				SetWidth (10);
+				SetHeight (end_FOC - start_FOC);
+
+//				SetXHorizScaled(0.0);
+
+
+				Point *p1 = new Point ( GetPosition()->x, 
+										start_FOC + (end_FOC - start_FOC)/2 );
+				SetPosition (p1);
+std::cout << " new_tl=[" << *GetTopLeft() << "]" << std::endl << std::flush; 
+
+				DrawSelect();
+
+std::cout << "done SetPositionHandles();" << std::endl << std::flush; 
+
+
+				SetWidth (prevWidth);
+				SetHeight (prevHeight);
+				SetPosition ( &prevPosition);		//reset 
+* ****** ******* */
+
+			}
+			else {
+//A				((SQViewer *)GetViewer())->SetInFOCblock(False);
+
+std::cout << " this not in_FOC block " << std::endl << std::flush; 
+std::cout << "IsInFOCmode()=" << ((SQViewer *)GetViewer())->IsInFOCmode() 
+<< "  IsInFOCblock()=" << ((SQViewer *)GetViewer())->IsInFOCblock() 
+<< std::endl << std::flush;
+
+
+/* *****************
+
+				if (((SQViewer *)GetViewer())->IsInFOCmode()) {
+std::cout << " inFOCmode: CREATE FOC here " << std::endl << std::flush; 					
+
+
+		UndrawShape();
+
+		((SQObjectNode *)GetSubject())->InsertAnchor(y-20,2);
+		((SQObjectNode *)GetSubject())->InsertAnchor(y+20,3);
+//		((SQObjectNode *)GetSubject())->SortAnchors();
+
+		DrawShape();
+
+
+				}
+***************** */
+
+
+
+			}
+
+
+		}
+
+
+std::cout << ">>> ### INSIDE rect: returning True" << std::endl << std::flush; 
+		return True;
+	}
+	else {
+		std::cout << ">>> NOT inside rect " << std::endl << std::flush; 
+		std::cout << ">> IsInConnectMode()=" << ((SQViewer *)GetViewer())->IsInConnectMode() << std::endl << std::flush; 
+
+		if ( ((SQViewer *)GetViewer())->IsInConnectMode() ) {
+			bool b1 = NodeShape::ContainsPt(x,y);
+std::cout << ">>> ### NOT INSIDE rect && IsInConnectMode: checking NS:ContainsPt: " << b1  << std::endl << std::flush;
+			if (b1) {
+std::cout << " >>> ### NodeShape::ContainPt True. Set invalidConnect" << std::endl << std::flush; 
+				((SQViewer *)GetViewer())->SetInvalidConnect(True);
+			}
+
+std::cout << " >>> ### RETURNING" << b1  << std::endl << std::flush; 
+
+			return (b1);
+//			return (NodeShape::ContainsPt(x,y));
+//			return 0;
+		} else {
+
+			bool b2 = NodeShape::ContainsPt(x,y);
+std::cout << ">>> $$$ NOT INSIDE rect && $$$$ NOT IsInConnectMode: returning NS:ContainsPt: " << b2 << std::endl << std::flush; 
+			return (b2);
+//			return (NodeShape::ContainsPt(x,y));
+		}
+	}
+}
+
+
+/* virtual */ void LifeLine::SetPositionHandles() {
+std::cout << " void LifeLine::SetPositionHandles() {" << std::endl << std::flush; 
+	// Positions of the handles:
+	//   0----5----1
+	//   |         |
+	//   6         7
+	//   |         |
+	//   3----4----2
+	const Point *pos = GetPosition();
+	DPoint tl, br;
+	GetShapeType()->CalcTopLeft().CalcPoint(&tl,
+		pos->x - HANDLE_WIDTH * 0.5, pos->y - HANDLE_WIDTH * 0.5,
+		GetWidth(), GetHeight(), GetName()->GetStringWidth(),
+		GetName()->GetStringHeight());
+	GetShapeType()->CalcBottomRight().CalcPoint(&br,
+		pos->x - HANDLE_WIDTH * 0.5, pos->y - HANDLE_WIDTH * 0.5,
+		GetWidth(), GetHeight(), GetName()->GetStringWidth(),
+		GetName()->GetStringHeight());
+	handles[0].Set(int(0.5 + tl.x), int(0.5 + tl.y), HANDLE_WIDTH, HANDLE_WIDTH);
+	handles[1].Set(int(0.5 + br.x), int(0.5 + tl.y), HANDLE_WIDTH, HANDLE_WIDTH);
+	handles[2].Set(int(0.5 + br.x), int(0.5 + br.y), HANDLE_WIDTH, HANDLE_WIDTH);
+	handles[3].Set(int(0.5 + tl.x), int(0.5 + br.y), HANDLE_WIDTH, HANDLE_WIDTH);
+//	handles[4].SetPosition(int(0.5 - HANDLE_WIDTH * 0.5 + pos->x), int(0.5 + br.y));
+	handles[4].SetPosition(int(0.5 - HANDLE_WIDTH * 0.5 + pos->x), int(0.5 + endPosition.y));
+	handles[5].SetPosition(int(0.5 - HANDLE_WIDTH * 0.5 + pos->x), int(0.5 + tl.y));
+	if ( ! IsResizable() || GetShapeType()->HasFixedHeight() ) {
+		handles[4].width = handles[5].width =
+		handles[4].height = handles[5].height = 0;
+	} else {
+		handles[4].width = handles[5].width = HANDLE_WIDTH;
+		handles[4].height = handles[5].height = HANDLE_WIDTH;
+	}
+	handles[6].SetPosition(int(0.5 + tl.x), int(0.5 - HANDLE_WIDTH * 0.5 + pos->y));
+	handles[7].SetPosition(int(0.5 + br.x), int(0.5 - HANDLE_WIDTH * 0.5 + pos->y));
+	if ( ! IsResizable() || GetShapeType()->HasFixedWidth() ) {
+		handles[6].width = handles[7].width =
+		handles[6].height = handles[7].height = 0;
+	} else {
+		handles[6].width = handles[7].width = HANDLE_WIDTH;
+		handles[6].height = handles[7].height = HANDLE_WIDTH;
+	}
+	SetNrHandles(8);
+}
+
+
+/* virtual */ void LifeLine::SnapPosition() {
+std::cout << " /* virtual */ void LifeLine::SnapPosition() {" << std::endl << std::flush; 
+	NodeShape::SnapPosition();
+}
+
+/* virtual */ void LifeLine::SetPosition(const Point *pos, bool snap) {
+std::cout << "@@@ void LifeLine::SetPosition(" << *pos << ", " << snap << ") {" << std::endl << std::flush;
+
+	NodeShape::SetPosition(pos, snap);
+}
+
+/* *****
+	if ( check(GetView()) &&
+	 	 (check(GetSubject() && GetSubject()->GetClassType()==Code::CBD_OBJECT_NODE)) ) {
+
+		if ( (GetView()->Snap(pos->y) + GetHeight()/2) >
+				((SQObjectNode *)GetSubject())->GetMinAnchor() ) {
+std::cout << "@@@@@@@@@@@@@@@@@@@@2 INVALID position... " << (GetView()->Snap(pos->y) + GetHeight()/2) << " >>> "
+<< ((SQObjectNode *)GetSubject())->GetMinAnchor() << std::endl << std::flush;
+std::cout << " *GetPosition() = " << *GetPosition() << std::endl << std::flush;
+			return;
+		} else
+			NodeShape::SetPosition(pos, snap);
+	} else {
+std::cout << " %%%%%%%%% INVALID CHECKS " << std::endl << std::flush;
+//	NodeShape::SetPosition(pos, snap);
+	}
+}
+
+* ***** */
+//???????????????????????????????????????????
+void LifeLine::UndrawHandles(){
+	UndrawSelect();
+}
+//???????????????????????????????????????????
+
diff -urN tcm-2.20/src/sd/dv/lifeline.h tcm-2.20+TSQD.orig/src/sd/dv/lifeline.h
--- tcm-2.20/src/sd/dv/lifeline.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/lifeline.h	2004-06-11 15:55:10.000000000 +0200
@@ -0,0 +1,121 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, Universiteit Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _LIFELINE_H
+#define _LIFELINE_H
+
+#include "nodeshape.h"
+
+/// LifeLine shape class.
+class LifeLine: public NodeShape {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	static const int LIFELINE_WIDTH;
+	static const int LIFELINE_HEIGHT;
+	///
+	LifeLine(ShapeView *v, Grafport *g, double x, double y);
+	///
+	LifeLine(const NodeShape &c);
+	///
+	virtual Shape *Clone() {return new LifeLine(*this);}
+	///
+	int GetClassType() const {return Code::SSD_SINGLE_OBJECT_BOX;}
+	///
+	void DrawShape();
+	///
+	void DrawOutLine(double x, double y, double w, double h);
+	///
+	void DrawOutLine(const Point *center, double t);
+	///
+	void DrawOutLineTail(const Point *center, double t);
+	///
+	void DrawOutLineFOC(double startFOC, double endFOC);
+	///
+	void UndrawShape();
+	///
+	TextShape *ChooseTextShape(int x, int y);
+	///
+//	TextShape *HitTextShape(int x, int y);
+
+	/// intersection of boundary and line from given point to anchorpoint
+	/* virtual */ Point GiveSnp(Point to) const;
+
+	/// intersection of boundary and line from given point to anchorpoint
+	/* virtual */ Point GiveAnchorSnp(Point a, Point to) const;
+
+	/// As GiveSnp but takes into account distribution of multiple lines.
+	/* virtual */ Point GiveSnp(Point to, int order, int count, int &code);
+
+	///
+	/* virtual */ Point GiveOrthoSnp(double dx, double dy, 
+			double hs, double vs, double tw, double th) const;
+	///
+	/* virtual */ Point GiveOrthoSnp(Point p) const;
+	
+	///
+	bool ContainsPt(int x, int y);
+	///
+	bool PtInFOCblock(int x, int y) const;
+	///
+	bool PtInFOCblock(int x, int y, int *start, int *end) const;
+	///
+	bool PtInFOCarea(int x, int y) const;
+	///
+	bool IsOverlappingFOC(int startFOC, int endFOC) const;
+
+	///
+	int GetEndPositionY() const {return endPosition.y;}
+	///
+	void SetEndPositionY(int y) {std::cout << " LifeLine::SetEndPosition(" << y << ")" << std::endl << std::flush; endPosition.y = y;}
+
+	///
+	/* virtual */ void SnapPosition();
+	///
+	/* virtual */ void SetPosition(const Point *p, bool snap=True);
+	///
+	/* virtual */ void SetPositionHandles();
+
+	//??????????????????????????????????
+	void UndrawHandles();
+	//??????????????????????????????????
+
+	//Aleister7
+	bool IsOverlappingAnotherFOC(int prevStartFOC, int prevEndFOC,
+					int startFOC, int endFOC);
+
+protected:
+	///
+	void WriteMembers(OutputFile *f);
+	///
+	bool ReadMembers(InputFile *f, double format);
+	///
+//	** virtual ** void SetPositionHandles();
+private:
+	///
+	static const ShapeType llType;
+	///
+	Point endPosition;
+	///
+	Point prevPosition;
+	///
+	bool destructive;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/Makefile tcm-2.20+TSQD.orig/src/sd/dv/Makefile
--- tcm-2.20/src/sd/dv/Makefile	2003-01-22 15:16:39.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/Makefile	2004-07-23 15:39:19.000000000 +0200
@@ -107,6 +107,34 @@
 	cbviewer.o\
 	cbwindow.o
 
+SQDOBJECTSX=cbactor.o\
+	sqchecks.o\
+	sqdiagram.o\
+	sqgraph.o\
+	sqanchorlinkedge.o\
+	cbdmessage.o\
+	cbclassnode.o\
+	lifeline.o\
+	apline.o\
+	createfoccmd.o\
+	createl2ledgecmd.o\
+	pullfoccmd.o\
+	pullshapecmd.o\
+	cbsingleclassbox.o\
+	ssdsingleclassbox.o\
+		ssddoubleclassbox.o\
+		ssdtripleclassbox.o\
+		doubleclassbox.o\
+		tripleclassbox.o\
+	sqobjectnode.o\
+	ucdsingleclassbox.o\
+	ssdsingleobjectbox.o\
+	cbupdateactortypecmd.o\
+	ssdupdateclassboxpropertycmd.o\
+	sqstubs.o\
+	sqviewer.o\
+	sqwindow.o
+
 CROBJECTS = $(EROBJECTS) $(SSCROBJECTS) $(CROBJECTSX)
 
 ESDOBJECTS = $(EROBJECTS) $(SSCROBJECTS) $(SESDOBJECTSX) $(ESDOBJECTSX)
@@ -117,8 +145,11 @@
 
 CBDOBJECTS = $(EROBJECTS) $(CBDOBJECTSX)
 
+SQDOBJECTS = $(EROBJECTS) $(SQDOBJECTSX)
+
 DVOBJECTS = $(EROBJECTS) $(SSCROBJECTS) $(CROBJECTSX) $(CBDOBJECTSX) \
-	$(SESDOBJECTSX) $(ESDOBJECTSX) $(SSDOBJECTSX) $(UCDOBJECTSX)
+	$(SESDOBJECTSX) $(ESDOBJECTSX) $(SSDOBJECTSX) $(UCDOBJECTSX) \
+	$(SQDOBJECTSX)
 
 tcmdv$(EXEEXTENSION):  $(DVOBJECTS) tcmdv.o
 	$(PURIFY) $(CC) $(CFLAGS) $(CPPFLAGS) $(DVOBJECTS) \
@@ -176,6 +207,13 @@
 	$(STRIP) $@
 	$(MV) $@ $(BIN_DIR)
 
+tsqd$(EXEEXTENSION):   $(SQDOBJECTS) sqeditor.o
+	$(PURIFY) $(CC) $(CFLAGS) $(CPPFLAGS) $(SQDOBJECTS) sqeditor.o -o $@ \
+	$(LDFLAGS) -ldiagram -leditor -lgui -lglobal $(LDLIBS)
+	chmod a+rx $@
+	$(STRIP) $@
+	$(MV) $@ $(BIN_DIR)
+
 cardconstraint.tab.c: cardconstraint.y cardconstraint.l
 	$(YACC) --debug -p cardconstraint -d cardconstraint.y
 	$(LEX) -Pcardconstraint -ocardconstraint.c cardconstraint.l
diff -urN tcm-2.20/src/sd/dv/pullfoccmd.c tcm-2.20+TSQD.orig/src/sd/dv/pullfoccmd.c
--- tcm-2.20/src/sd/dv/pullfoccmd.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/pullfoccmd.c	2004-03-25 14:25:11.000000000 +0100
@@ -0,0 +1,168 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2002, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+//// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+//#include "grafport.h"
+#include "nodeshape.h"
+#include "shapeview.h"
+#include "diagram.h"
+#include "subject.h"
+#include "diagramviewer.h"
+//#include "drawwindow.h"
+#include "pullfoccmd.h"
+#include "lifeline.h"
+#include "sqobjectnode.h"
+
+
+// dir = handle nr + 1
+
+PullFOCCmd::PullFOCCmd(GShape *s, int startY)
+	:Command(s->GetView()->GetViewer()->GetDiagram(), 
+		s->GetView()->GetViewer()),
+	fixpoint(*s->GetPosition()),
+	centre(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0),
+	corner(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
+{
+std::cout << "<<<  PullFOCCmd::PullFOCCmd(*s, " <<  startY << ")" << std::endl << std::flush; 
+
+	if ( ! (shape = dynamic_cast<NodeShape *>(s)) )
+		error("Illegal use of size shape command");
+
+	SetPdirection(5);
+std::cout << "-3-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+	
+	LifeLine *l = (LifeLine *) shape;
+	startFOC = startY;
+	newEndFOC = oldEndFOC = startY + 10;
+	std::cout << " startFOC = " << startFOC  << std::endl << std::flush; 
+	std::cout << " newEndFOC = oldEndFOC = " << newEndFOC  << std::endl << std::flush; 
+std::cout << "-4-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+}
+
+
+void PullFOCCmd::TrackMouse(TrackType aPhase, Point * /* anchorPoint */,
+	Point * /* previousPoint */, Point *nextPoint)
+{
+std::cout << "-M-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+std::cout << "MMMMM PullFOCCmd::TrackMouse(" << aPhase << ", -, -, " << *nextPoint << ") pdirection=" 
+<< pdirection << std::endl << std::flush; 
+	LifeLine *l = (LifeLine *) shape;
+	switch(aPhase) {
+		case TRACK_PRESS:
+			GetMainWindow()->SetSizeCursor(pdirection);
+			CalcEndPoint(nextPoint);
+//			Draw();
+			break;
+		case TRACK_DRAG:
+//			l->UndrawTail(nextPoint);
+//			l->Undraw();
+			CalcEndPoint(nextPoint);
+			DrawFOC(nextPoint);
+//			Draw();
+			break;
+		case TRACK_RELEASE:
+//			Undraw();
+			l->DrawOutLineFOC(startFOC, oldEndFOC);		//undraw
+			l->DrawOutLineFOC(startFOC, newEndFOC);		//draw
+
+			GetMainWindow()->SetCursor(MouseCursor::LEFT_PTR);
+			break;
+		default:
+			error("unknown track type\n");
+			break;
+	}
+}
+
+
+void PullFOCCmd::CalcEndPoint(const Point *p) {
+
+
+std::cout << " void PullFOCCmd::CalcEndPoint(" << *p << ") GCt=" <<
+		shape->GetSubject()->GetClassType()  << std::endl << std::flush; 
+
+	LifeLine *l = (LifeLine *) shape;
+//	l->Undraw();
+	int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT CalcEndPoint[" << *p << "] @end:" << yy << " p->y=" << p->y << std::endl << std::flush; 
+//	l->SetEndPositionY(p->y);
+//	l->SetPositionHandles();
+//	l->Draw();
+}
+
+
+void PullFOCCmd::Draw() {
+std::cout << " *****************!!! void PullFOCCmd::Draw() " << std::endl << std::flush; 
+//	shape->DrawOutLine(shape->GetPosition());
+	LifeLine *l = (LifeLine *) shape;
+//	l->DrawOutLine(shape->GetPosition(), np->y);
+}
+
+
+
+void PullFOCCmd::DrawFOC(const Point *np) {
+	LifeLine *l = (LifeLine *) shape;
+std::cout << " !____set_____! void PullFOCCmd::DrawFOC( [" << l->GetEndPositionY() << "-->" <<  np->y << "] ) {" << std::endl << std::flush; 
+//	l->DrawOutLine(shape->GetPosition(), l->GetEndPositionY());
+	l->DrawOutLineFOC(startFOC, newEndFOC);		//prev endPosY
+	newEndFOC = np->y;
+	l->DrawOutLineFOC(startFOC, np->y);
+}
+
+
+void PullFOCCmd::Execute() {
+	Command::Execute();
+
+	LifeLine *l = (LifeLine *) shape;
+	int yy = l->GetEndPositionY();
+std::cout << " X: WE ARE AT LifeLine End? @end:" << yy << std::endl << std::flush; 
+
+	l->Undraw();
+std::cout << " newEndFOC : " << newEndFOC << " <-- " << oldEndFOC << std::endl << std::flush; 
+//F	l->SetEndPositionY(newEndPositionY);
+//F	l->SetPositionHandles();
+
+
+	if (newEndFOC != startFOC) {
+		((SQObjectNode *)shape->GetSubject())->InsertAnchor(min(startFOC, newEndFOC), 2);
+		((SQObjectNode *)shape->GetSubject())->InsertAnchor(max(startFOC, newEndFOC), 3);
+	}
+
+	l->Draw();
+
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);
+//	GetMainWindow()->FitDocument();
+}
+
+
+void PullFOCCmd::UnExecute() {
+	Command::UnExecute();
+
+	LifeLine *l = (LifeLine *) shape;
+	int yy = l->GetEndPositionY();
+std::cout << "UX: PullFOCcmd :" << newEndFOC << "<--" << oldEndFOC << std::endl << std::flush; 
+	l->Undraw();
+//E	l->SetEndPositionY(oldEndFOC);
+//E	l->SetPositionHandles();
+	l->Draw();
+
+
+//	shape->UpdateSize(int(0.5 + oldWidth), int(0.5 + oldHeight));
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);	
+}
diff -urN tcm-2.20/src/sd/dv/pullfoccmd.h tcm-2.20+TSQD.orig/src/sd/dv/pullfoccmd.h
--- tcm-2.20/src/sd/dv/pullfoccmd.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/pullfoccmd.h	2002-08-08 10:57:14.000000000 +0200
@@ -0,0 +1,79 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2002, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _PULLFOCCMD_H
+#define _PULLFOCCMD_H
+
+#include "command.h"
+#include "polypoint.h"
+#include "dpoint.h"
+class NodeShape;
+class GShape;
+
+/// abstract command class for pulling a shape's tail.
+class PullFOCCmd: public Command {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	PullFOCCmd(GShape *s, int dir);
+	///
+	void TrackMouse(TrackType aPhase, Point *anchorPoint,
+		Point *previousPoint, Point *nextPoint);
+	///
+	const char *GetName() const {return "pull shape FOC";}
+	///
+	void Execute();
+	///
+	void UnExecute();
+protected:
+	///
+	NodeShape *shape;
+	/// coordinates of the fix point of the figure.
+	DPoint fixpoint;
+	/// coordinates of the position of the shape.
+	PolyPoint centre;
+	/// coordinates of the moving corner of the shape.
+	PolyPoint corner;
+	///
+	int startFOC;
+	///
+	int newEndFOC;
+	///
+	int oldEndFOC;
+	///
+	int GetPdirection() const {return pdirection;}
+	///
+	void SetPdirection(int d) {pdirection=d;}
+	///
+	void CalcEndPoint(const Point *p);
+	///
+	void DrawFOC(const Point *np);
+	///
+	void Draw();
+	///
+	void Undraw() {
+		Draw();
+	}
+private:
+	///
+	int pdirection;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/pullshapecmd.c tcm-2.20+TSQD.orig/src/sd/dv/pullshapecmd.c
--- tcm-2.20/src/sd/dv/pullshapecmd.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/pullshapecmd.c	2004-03-25 14:27:30.000000000 +0100
@@ -0,0 +1,190 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1995, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+//// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+//#include "grafport.h"
+#include "nodeshape.h"
+#include "shapeview.h"
+#include "diagram.h"
+#include "subject.h"
+#include "diagramviewer.h"
+//#include "drawwindow.h"
+#include "pullshapecmd.h"
+#include "lifeline.h"
+#include "sqobjectnode.h"
+
+
+// dir = handle nr + 1
+
+PullShapeCmd::PullShapeCmd(GShape *s, int dir)
+	:Command(s->GetView()->GetViewer()->GetDiagram(), 
+		s->GetView()->GetViewer()),
+	fixpoint(*s->GetPosition()),
+	centre(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0),
+	corner(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
+{
+std::cout << "<<<  PullShapeCmd::PullShapeCmd(*s, " <<  dir << ")" << std::endl << std::flush; 
+
+	if ( ! (shape = dynamic_cast<NodeShape *>(s)) )
+		error("Illegal use of size shape command");
+	SetPdirection(dir);
+
+std::cout << "-1-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+std::cout << "-2-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+	SetPdirection(5);
+std::cout << "-3-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+	
+	LifeLine *l = (LifeLine *) shape;
+	newEndPositionY = oldEndPositionY = l->GetEndPositionY();
+	std::cout << " newEndPositionY = oldEndPositionY = " << newEndPositionY  << std::endl << std::flush; 
+std::cout << "-4-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+}
+
+
+void PullShapeCmd::TrackMouse(TrackType aPhase, Point * /* anchorPoint */,
+	Point * /* previousPoint */, Point *nextPoint)
+{
+std::cout << "-M-> pdirection = " << pdirection << " Gdir = " << GetPdirection() << std::endl << std::flush; 
+std::cout << "MMMMM PullShapeCmd::TrackMouse(" << aPhase << ", -, -, " << *nextPoint << ") pdirection=" 
+<< pdirection << std::endl << std::flush; 
+	LifeLine *l = (LifeLine *) shape;
+	switch(aPhase) {
+		case TRACK_PRESS:
+			GetMainWindow()->SetSizeCursor(pdirection);
+			CalcEndPoint(nextPoint);
+//			Draw();
+			break;
+		case TRACK_DRAG:
+//			l->UndrawTail(nextPoint);
+//			l->Undraw();
+			CalcEndPoint(nextPoint);
+			DrawTail(nextPoint);
+//			Draw();
+			break;
+		case TRACK_RELEASE:
+//			Undraw();
+			l->DrawOutLineTail(shape->GetPosition(), l->GetEndPositionY());	//undraw
+			l->DrawOutLineTail(shape->GetPosition(), newEndPositionY);		//draw
+
+
+			GetMainWindow()->SetCursor(MouseCursor::LEFT_PTR);
+			break;
+		default:
+			error("unknown track type\n");
+			break;
+	}
+}
+
+
+void PullShapeCmd::CalcEndPoint(const Point *p) {
+
+
+std::cout << " void PullShapeCmd::CalcEndPoint(" << *p << ") GCt=" <<
+		shape->GetSubject()->GetClassType()  << std::endl << std::flush; 
+
+	LifeLine *l = (LifeLine *) shape;
+//	l->Undraw();
+	int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT CalcEndPoint[" << *p << "] @end:" << yy << " p->y=" << p->y << std::endl << std::flush; 
+//	l->SetEndPositionY(p->y);
+//	l->SetPositionHandles();
+//	l->Draw();
+}
+
+
+void PullShapeCmd::Draw() {
+std::cout << " *****************!!! void PullShapeCmd::Draw() " << std::endl << std::flush; 
+//	shape->DrawOutLine(shape->GetPosition());
+	LifeLine *l = (LifeLine *) shape;
+//	l->DrawOutLine(shape->GetPosition(), np->y);
+}
+
+
+
+void PullShapeCmd::DrawTail(const Point *np) {
+	LifeLine *l = (LifeLine *) shape;
+std::cout << " !____set_____! void PullShapeCmd::DrawTail( [" << l->GetEndPositionY() << "-->" <<  np->y << "] ) {" << std::endl << std::flush; 
+//	l->DrawOutLine(shape->GetPosition(), l->GetEndPositionY());
+	l->DrawOutLineTail(shape->GetPosition(), newEndPositionY);		//prev endPosY
+	newEndPositionY = np->y;
+	l->DrawOutLineTail(shape->GetPosition(), np->y);
+}
+
+
+void PullShapeCmd::Execute() {
+	LifeLine *l = (LifeLine *) shape;
+	int xx = l->GetPosition()->y + l->GetHeight()/2;
+	int yy = l->GetEndPositionY();
+std::cout << " X: WE ARE AT LifeLine @ [" << xx << "->" << yy << "]" << std::endl << std::flush; 
+std::cout << " X: MinAnchor =" << ((SQObjectNode *)l->GetSubject())->GetMinAnchor() << std::endl << std::flush; 
+std::cout << " X: MaxAnchor =" << ((SQObjectNode *)l->GetSubject())->GetMaxAnchor() << std::endl << std::flush; 
+
+//in or above starting point 
+	if ( newEndPositionY <= (l->GetPosition()->y + l->GetHeight()/2) ) {
+		GetMainWindow()->SetStatus("aborted: invalid lifeline");
+		Abort();
+		return;
+	}
+
+//above existing FOC 
+	if ( newEndPositionY < ((SQObjectNode *)l->GetSubject())->GetMaxAnchor() ) {
+		GetMainWindow()->SetStatus("aborted: above FOC");
+		Abort();
+		return;
+	}
+
+//in existing FOC 
+	if ( l->PtInFOCblock(l->GetPosition()->x, newEndPositionY) ) {
+		GetMainWindow()->SetStatus("aborted: in FOC");
+		Abort();
+		return;
+	}
+
+
+
+
+	l->Undraw();
+std::cout << " newEndPositionY : " << newEndPositionY << " <-- " << l->GetEndPositionY() << std::endl << std::flush; 
+	l->SetEndPositionY(newEndPositionY);
+	l->SetPositionHandles();
+	l->Draw();
+
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);
+//	GetMainWindow()->FitDocument();
+
+	Command::Execute();
+}
+
+
+void PullShapeCmd::UnExecute() {
+	Command::UnExecute();
+
+	LifeLine *l = (LifeLine *) shape;
+	int yy = l->GetEndPositionY();
+std::cout << "UX: WE ARE AT LifeLine End? @end:" << yy << "<--" << oldEndPositionY << std::endl << std::flush; 
+	l->Undraw();
+	l->SetEndPositionY(oldEndPositionY);
+	l->SetPositionHandles();
+	l->Draw();
+
+
+//	shape->UpdateSize(int(0.5 + oldWidth), int(0.5 + oldHeight));
+//	shape->GetView()->GetViewer()->ShapePositionUpdate(shape);	
+}
diff -urN tcm-2.20/src/sd/dv/pullshapecmd.h tcm-2.20+TSQD.orig/src/sd/dv/pullshapecmd.h
--- tcm-2.20/src/sd/dv/pullshapecmd.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/pullshapecmd.h	2002-08-05 15:58:46.000000000 +0200
@@ -0,0 +1,77 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1995, Vrije Universiteit Amsterdam.
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _PULLSHAPECMD_H
+#define _PULLSHAPECMD_H
+
+#include "command.h"
+#include "polypoint.h"
+#include "dpoint.h"
+class NodeShape;
+class GShape;
+
+/// abstract command class for pulling a shape's tail.
+class PullShapeCmd: public Command {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	///
+	PullShapeCmd(GShape *s, int dir);
+	///
+	void TrackMouse(TrackType aPhase, Point *anchorPoint,
+		Point *previousPoint, Point *nextPoint);
+	///
+	const char *GetName() const {return "pull shape tail";}
+	///
+	void Execute();
+	///
+	void UnExecute();
+protected:
+	///
+	NodeShape *shape;
+	/// coordinates of the fix point of the figure.
+	DPoint fixpoint;
+	/// coordinates of the position of the shape.
+	PolyPoint centre;
+	/// coordinates of the moving corner of the shape.
+	PolyPoint corner;
+	///
+	int newEndPositionY;
+	///
+	int oldEndPositionY;
+	///
+	int GetPdirection() const {return pdirection;}
+	///
+	void SetPdirection(int d) {pdirection=d;}
+	///
+	void CalcEndPoint(const Point *p);
+	///
+	void DrawTail(const Point *np);
+	///
+	void Draw();
+	///
+	void Undraw() {
+		Draw();
+	}
+private:
+	///
+	int pdirection;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqanchorlinkedge.c tcm-2.20+TSQD.orig/src/sd/dv/sqanchorlinkedge.c
--- tcm-2.20/src/sd/dv/sqanchorlinkedge.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqanchorlinkedge.c	2004-03-25 14:28:25.000000000 +0100
@@ -0,0 +1,75 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqanchorlinkedge.h"
+#include "sqgraph.h"
+#include "inputfile.h"
+#include "outputfile.h" 
+#include "subject.h"
+
+
+SQAnchorLinkEdge::SQAnchorLinkEdge(SQGraph *g, Subject *n1, Subject *n2): 
+		Edge(g, n1, n2) {
+		
+std::cout << "SQAnchorLinkEdge::SQAnchorLinkEdge(CBGraph *g, Subject *n1, Subject *n2): " << std::endl << std::flush;
+
+// std::cout << "subj1=" << n1->GetId() << ", subj2=" << n2->GetId() << std::endl << std::flush; 
+
+
+
+		}
+
+
+
+bool SQAnchorLinkEdge::ReadMembers(InputFile *ifile, double format) {
+	if (!Edge::ReadMembers(ifile, format))
+		return False;
+std::cout << "eA" << std::endl << std::flush;
+	string val;
+
+	string val1, val2;
+	if (!ifile->ReadAttribute2("Anchor1", &val1, &val2)) {
+std::cout << "Wrong anchor1: " << val1 << ", " << val2 << std::endl << std::flush; 
+		return False;
+	}
+
+//HZ	anchors->add(new Anchorpoint(val1, val2));
+//	anchors->add(new Point(val1.toint(), val2.toint())); 
+	anchor1.Set(val1.toint(), val2.toint()); 
+std::cout << "Got anchor1 : " << val1 << ", " << val2 << " | " << anchor1 << std::endl << std::flush; 
+
+
+	if (!ifile->ReadAttribute2("Anchor2", &val1, &val2)) {
+std::cout << "Wrong anchor2: " << val1 << ", " << val2 << std::endl << std::flush; 
+		return False;
+	}
+	anchor2.Set(val1.toint(), val2.toint()); 
+std::cout << "Got anchor2 : " << val1 << ", " << val2 << " | " << anchor2 << std::endl << std::flush; 
+
+	return True;
+}
+
+
+void SQAnchorLinkEdge::WriteMembers(OutputFile *ofile) {
+	Edge::WriteMembers(ofile);
+	(*ofile) << "\t{ Anchor1 " << anchor1 << " }\n";
+	(*ofile) << "\t{ Anchor2 " << anchor2 << " }\n";
+}
+
diff -urN tcm-2.20/src/sd/dv/sqanchorlinkedge.h tcm-2.20+TSQD.orig/src/sd/dv/sqanchorlinkedge.h
--- tcm-2.20/src/sd/dv/sqanchorlinkedge.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqanchorlinkedge.h	2002-02-05 08:58:25.000000000 +0100
@@ -0,0 +1,57 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 1999, Vrije Universiteit Amsterdam and University of Twente.
+// Author: Frank Dehne (frank@cs.vu.nl).
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQANCHORLINKEDGE_H
+#define _SQANCHORLINKEDGE_H
+
+#include "edge.h"
+#include "textshape.h"
+class SQGraph;
+
+/// binary anchor link edge class in a SQD.
+class SQAnchorLinkEdge: public Edge {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQAnchorLinkEdge(SQGraph *g, Subject *n1, Subject *n2);
+	///
+	Subject *Clone() {return new SQAnchorLinkEdge(*this);}
+	///
+	int GetClassType() const {return Code::CBD_OBJECT_LINK_EDGE;}
+	///
+	const Point *GetAnchor1() const {return &anchor1;} 
+	///
+	const Point *GetAnchor2() const {return &anchor2;} 
+	///
+	void SetAnchor1(const Point *pt) {anchor1=*pt;} 
+	///
+	void SetAnchor2(const Point *pt) {anchor2=*pt;} 
+	///
+	bool ReadMembers(InputFile *ifile, double format);
+	///
+	void WriteMembers(OutputFile *ofile);
+private:
+	///
+	Point anchor1;
+	///
+	Point anchor2;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqchecks.c tcm-2.20+TSQD.orig/src/sd/dv/sqchecks.c
--- tcm-2.20/src/sd/dv/sqchecks.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqchecks.c	2001-09-10 10:51:13.000000000 +0200
@@ -0,0 +1,23 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqchecks.h"
+
+SQChecks::SQChecks(Diagram *d, Graph *g): ERChecks(d,g) { }
diff -urN tcm-2.20/src/sd/dv/sqchecks.h tcm-2.20+TSQD.orig/src/sd/dv/sqchecks.h
--- tcm-2.20/src/sd/dv/sqchecks.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqchecks.h	2001-09-10 10:51:34.000000000 +0200
@@ -0,0 +1,34 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2000, Vrije Universiteit Amsterdam and University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+// Author: Frank Dehne (frank@cs.vu.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQCHECKS_H
+#define _SQCHECKS_H
+
+#include "erchecks.h"
+
+/// implements checks for soft constraints on sequence diagrams.
+class SQChecks: public ERChecks  {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+        ///
+        SQChecks(Diagram *d, Graph *g);
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqdiagram.c tcm-2.20+TSQD.orig/src/sd/dv/sqdiagram.c
--- tcm-2.20/src/sd/dv/sqdiagram.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqdiagram.c	2004-06-14 18:09:43.000000000 +0200
@@ -0,0 +1,462 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+
+#include "messagedialog.h"
+#include "ssdsingleclassbox.h"
+#include "cbsingleclassbox.h"
+#include "ssdsingleobjectbox.h"
+#include "c2r2mlistline.h"
+#include "t4tlistline.h"
+#include "commentlink.h"
+#include "ssdclassnode.h"
+#include "cbclassnode.h"
+#include "apline.h"
+#include "sqobjectnode.h"
+#include "ucdsingleclassbox.h"
+
+#include "lifeline.h"
+#include "stickman.h"
+#include "cbactor.h"
+#include "cbclasslinkedge.h"
+#include "cbobjectlinkedge.h"
+#include "sqanchorlinkedge.h"
+
+#include "textbox.h"
+#include "comment.h"
+#include "notebox.h"
+#include "note.h"
+
+#include "sqgraph.h"
+#include "sqwindow.h"
+#include "sqviewer.h"
+#include "sqchecks.h"
+#include "sqdiagram.h"
+#include "cbdmessage.h"
+#include <stdio.h>
+#include <values.h>
+
+SQDiagram::SQDiagram(Config *c, SQWindow *w, SQViewer *v, SQGraph *g): 
+	   ERDiagram(c, w, v, g) {
+	UpdateNodeType(1);
+	UpdateEdgeType(1);
+	((SQViewer *)GetDiagramViewer())->SetInFOCmode(False);
+	sqChecks = new SQChecks(this, g);
+}
+
+SQDiagram::~SQDiagram() {
+	delete sqChecks;
+}
+
+Thing *SQDiagram::CreateThing(int classNr) {
+	Grafport *g = GetDiagramViewer()->GetGrafport();
+	ShapeView *v = GetDiagramViewer()->GetCurView();
+	SQGraph *cg = (SQGraph *)GetGraph();
+	Thing *thing = 0;
+	if (classNr == Code::VIEW)
+		thing = new ShapeView(GetDiagramViewer());
+
+	// node shapes
+	else if (classNr==Code::SSD_SINGLE_OBJECT_BOX)
+//		thing = new SQObjectBoxLifeLine(v, g, 0, 0);
+		thing = new LifeLine(v, g, 0, 0); 
+	else if (classNr==Code::BOX)
+//		thing = new SQObjectBoxLifeLine(v, g, 0, 0); 
+		thing = new LifeLine(v, g, 0, 0); 
+/* HZ *
+	else if (classNr==Code::UCD_SINGLE_CLASS_BOX)
+		thing = new UCDSingleClassBox(v, g, 0, 0); 
+	else if (classNr==Code::STICKMAN)
+                thing = new StickMan(v, g, 0, 0);
+	else if (classNr==Code::SSD_SINGLE_CLASS_BOX)
+		thing = new SSDSingleClassBox(v, g, 0, 0); 
+	else if (classNr==Code::CBD_SINGLE_CLASS_BOX)
+		thing = new CBSingleClassBox(v, g, 0, 0); 
+	else if (classNr==Code::SSD_SINGLE_OBJECT_BOX)
+		thing = new SSDSingleObjectBox(v, g, 0, 0); 
+* HZ */
+	else if (classNr==Code::TEXT_BOX)
+		thing = new TextBox(v, g, 0, 0); 
+	else if (classNr==Code::NOTE_BOX)
+		thing = new NoteBox(v, g, 0, 0); 
+
+	// lines
+/* HZ *
+	else if (classNr==Code::T4_TLIST_LINE)
+		thing = new T4TListLine(v, g, 0, 0, 0);
+	else if (classNr==Code::C2R2_MLIST_LINE)
+		thing = new C2R2MListLine(v, g, 0, 0, 0);
+* HZ */
+	else if (classNr==Code::LINE)	{
+std::cout << " got a LINE " << std::endl << std::flush; 
+		thing = new Line(v, g, 0, 0, 0);
+}
+	else if (classNr==Code::T4_LINE) {
+std::cout << " got a T4_LINE " << std::endl << std::flush; 
+		thing = new APLine(v, g, 0, 0, 0);
+}
+
+	// nodes
+	else if (classNr==Code::CBD_OBJECT_NODE)	//HZ
+		thing = new SQObjectNode(cg);
+/* HZ *
+	else if (classNr==Code::UCD_ACTOR_NODE)
+		thing = new CBActor(cg);
+	else if (classNr==Code::CBD_CLASS_NODE)
+		thing = new CBClassNode(cg);
+* HZ */
+
+
+
+
+	else if (classNr==Code::NOTE)
+		thing = new Note(cg);
+	else if (classNr==Code::COMMENT)
+		thing = new Comment(cg);
+
+	// edges
+/* HZ *
+//	else if (classNr==Code::CBD_CLASS_LINK_EDGE)
+//		thing = new CBClassLinkEdge(cg, 0, 0);
+//	else if (classNr==Code::CBD_OBJECT_LINK_EDGE)
+//		thing = new CBObjectLinkEdge(cg, 0, 0);
+* HZ */
+	else if (classNr==Code::CBD_OBJECT_LINK_EDGE)
+		thing = new SQAnchorLinkEdge(cg, 0, 0);
+	else if (classNr==Code::COMMENT_LINK)
+		thing = new CommentLink(cg, 0, 0);
+
+	else
+		error("%s, line %d: impl error: wrong class number %d\n", 
+			__FILE__, __LINE__, classNr);
+	return thing;
+}
+ 
+Node *SQDiagram::CreateNode(){
+std::cout << " Node *SQDiagram::CreateNode(" << GetNodeType() << ")" << std::endl << std::flush;
+	Node *node = 0;
+	SQGraph *g = (SQGraph *)GetGraph();
+/* HZ *
+	if (GetNodeType()==Code::UCD_ACTOR_NODE)
+		node = new CBActor(g);
+	else if (GetNodeType()==Code::CBD_CLASS_NODE)
+		node = new CBClassNode(g);
+* HZ */
+	if (GetNodeType()==Code::CBD_OBJECT_NODE)	//HZ
+		node = new SQObjectNode(g);
+	else if (GetNodeType()==Code::NOTE)
+		node = new Note(g);
+	else if (GetNodeType()==Code::COMMENT)
+		node = new Comment(g);
+	else
+		error( "%s, line %d: impl error: unknown node type\n",
+			__FILE__, __LINE__);
+	return node;
+}
+
+Edge *SQDiagram::CreateEdge(Subject *subj1, Subject* subj2){
+std::cout << " Edge *SQDiagram::CreateEdge(" << subj1->GetId()
+	<< " --> " << subj2->GetId() << ")" << std::endl << std::flush;
+	if (!CheckEdgeConstraints(subj1, subj2))
+		return 0;
+	Edge* edge = 0;
+	SQGraph *g = (SQGraph *)GetGraph();
+
+/* HZ *
+//	if (GetEdgeType() == Code::CBD_CLASS_LINK_EDGE)
+//		edge = new CBClassLinkEdge(g, subj1, subj2);
+//	else if (GetEdgeType() == Code::CBD_OBJECT_LINK_EDGE)
+//		edge = new CBObjectLinkEdge(g, subj1, subj2);
+//	else if (GetEdgeType()==Code::COMMENT_LINK)
+* HZ */
+	if (GetEdgeType() == Code::CBD_OBJECT_LINK_EDGE)
+		edge = new SQAnchorLinkEdge(g, subj1, subj2);
+	else if (GetEdgeType()==Code::COMMENT_LINK)
+		edge = new CommentLink(g, subj1, subj2);
+	else {
+		GetMainWindow()->SetStatus(
+			"aborted: Anchor point link must be selected");
+			(new MessageDialog(GetMainWindow()->GetWidget(),
+			MessageDialog::ERROR))->
+			  Show("Error",
+			  "It is not possible to create an anchor point link\n"
+			  "using a Focus of Control Box");
+		return 0;
+	}
+
+	return edge;
+}
+
+NodeShape *SQDiagram::CreateNodeShape(Node* node, int x, int y) {
+std::cout << " NodeShape *SQDiagram::CreateNodeShape(" <<  GetNodeShapeType()
+<< " @[" << x << " ," << y << "] )" << std::endl << std::flush; 
+	NodeShape* shape = 0;
+	Grafport *g = GetDiagramViewer()->GetGrafport();
+	ShapeView *v = GetDiagramViewer()->GetCurView();
+
+
+
+/* HZ *
+	if (GetNodeShapeType() == Code::STICKMAN)
+		shape = new StickMan(v, g, x, y);
+
+//HZ TMP
+	else if (GetNodeShapeType() == Code::CE_START_NODE) {
+		SetNodeShapeType(Code::STICKMAN);	//reset
+		shape = new StickMan(v, g, x, y);
+		shape->GetName()->SetUnderlined(True);
+	}
+
+	else if (GetNodeShapeType() == Code::CE_FINAL_NODE) {
+		SetNodeShapeType(Code::UCD_SINGLE_CLASS_BOX);	//reset
+		shape = new UCDSingleClassBox(v, g, x, y);
+		shape->GetName()->SetUnderlined(True);
+	}
+
+
+
+//HZ TMP
+
+
+
+	else if (GetNodeShapeType() == Code::SSD_SINGLE_OBJECT_BOX)
+		shape = new SSDSingleObjectBox(v, g, x, y); 
+	else if (GetNodeShapeType() == Code::CBD_SINGLE_CLASS_BOX)
+			shape = new CBSingleClassBox(v, g, x, y);
+	else if (GetNodeShapeType() == Code::SSD_SINGLE_CLASS_BOX)
+//HZ		shape = new CBSingleClassBox(v, g, x, y);
+			shape = new SSDSingleClassBox(v, g, x, y);
+
+	else if (GetNodeShapeType() == Code::UCD_SINGLE_CLASS_BOX)
+		shape = new UCDSingleClassBox(v, g, x, y);
+	else 
+* HZ */	
+	
+	if (GetNodeShapeType() == Code::SSD_SINGLE_OBJECT_BOX)
+//		shape = new SQObjectBoxLifeLine(v, g, x, y); 
+		shape = new LifeLine(v, g, x, y); 
+
+	else if (GetNodeShapeType() == Code::NOTE_BOX)
+		shape = new NoteBox(v, g, x, y);
+	else if (GetNodeShapeType() == Code::TEXT_BOX)
+		shape = new TextBox(v, g, x, y);
+
+	else
+		error( "%s, line %d: impl error: "
+			"node shape type doesn't exist\n", __FILE__, __LINE__);
+
+//std::cout << "A" << std::endl << std::flush; 
+	if (check(shape)) {
+//std::cout << "B" << std::endl << std::flush; 
+		shape->SetSubject(node);
+//std::cout << "C" << std::endl << std::flush; 
+		shape->SetTextShape();
+//std::cout << "D" << std::endl << std::flush; 
+	}
+//std::cout << "E" << std::endl << std::flush; 
+	return shape;
+}
+
+Line *SQDiagram::CreateLine(Edge* edge, GShape *from, GShape *to, List<Point*> *l) {
+	Grafport *g = GetDiagramViewer()->GetGrafport();
+	ShapeView *v = GetDiagramViewer()->GetCurView();
+	Line* line = 0;
+
+
+/* HZ *
+	if (GetLineType()== Code::T4_TLIST_LINE)
+		line = new C2R2MListLine(v, g, from, to, l, IsCurve());
+//HZ		line = new T4TListLine(v, g, from, to, l, IsCurve());
+//HZ		line = new Line(v, g, from, to, l, IsCurve());
+	else if (GetLineType()==Code::C2R2_MLIST_LINE)
+		line = new C2R2MListLine(v, g, from, to, l, IsCurve());
+
+	else 
+	
+* HZ */	
+	if (GetLineType()== Code::LINE)
+{
+std::cout << " create a LINE " << std::endl << std::flush; 
+		line = new Line(v, g, from, to, l, IsCurve());
+}
+	else if (GetLineType()== Code::T4_LINE)
+{
+std::cout << " create a T4_LINE " << std::endl << std::flush; 
+		line = new APLine(v, g, from, to, l, IsCurve());
+}
+	else
+		error( "%s, line %d: impl error: "
+			"edge shape type does not exist\n", __FILE__, __LINE__);
+	
+	if (check(line)) {
+std::cout << " GOING 2 SET	line->SetSubject(edge);" << std::endl << std::flush; 
+		line->SetSubject(edge);
+
+		line->SetTextShape();
+		line->SetEnd1(GetLineEnd1());
+		line->SetEnd2(GetLineEnd2());
+
+//std::cout << "setting underline here : " << edge->GetClassType() << std::endl << std::flush; 
+
+		if (edge->GetClassType()==Code::CBD_CLASS_LINK_EDGE) {
+std::cout << " unsetting name underlining... " << std::endl << std::flush; 
+			line->GetName()->SetUnderlined(False);
+		}
+
+		if (edge->GetClassType()==Code::CBD_OBJECT_LINK_EDGE) {
+std::cout << " Setting Anchors... " << std::endl << std::flush; 
+			line->SetAnchors();
+		}
+	}
+	return line;
+}
+
+void SQDiagram::UpdateNodeType(int num) {
+	((DiagramWindow *)GetMainWindow())->SetNodeName(num);
+	switch (num) {
+//	case 1: SetNodeType(Code::UCD_ACTOR_NODE);
+//		SetNodeShapeType(Code::STICKMAN);
+	case 1: SetNodeType(Code::CBD_OBJECT_NODE);			//HZ
+		SetNodeShapeType(Code::SSD_SINGLE_OBJECT_BOX);	//HZ
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+	case 2: SetNodeType(Code::NOTE);
+		SetNodeShapeType(Code::NOTE_BOX);
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+
+/*
+	case 2: SetNodeType(Code::UCD_ACTOR_NODE);
+		SetNodeShapeType(Code::UCD_SINGLE_CLASS_BOX);
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+	case 3: SetNodeType(Code::CBD_CLASS_NODE);
+		SetNodeShapeType(Code::SSD_SINGLE_CLASS_BOX);
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+	case 4: SetNodeType(Code::UCD_ACTOR_NODE);
+		SetNodeShapeType(Code::STICKMAN);
+		SetNodeShapeType(Code::CE_START_NODE);		//HZ TMP
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+	case 6: SetNodeType(Code::UCD_ACTOR_NODE);
+		SetNodeShapeType(Code::UCD_SINGLE_CLASS_BOX);
+		SetNodeShapeType(Code::CE_FINAL_NODE);		//HZ TMP
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+*/
+
+	case 3: SetNodeType(Code::CBD_OBJECT_NODE);			//HZ
+		SetNodeShapeType(Code::SSD_SINGLE_OBJECT_BOX);	//HZ
+		SetNodeLineStyle(LineStyle::SOLID);
+		break;
+
+	case 4: SetNodeType(Code::COMMENT);
+		SetNodeShapeType(Code::TEXT_BOX);
+		SetNodeLineStyle(LineStyle::INVISIBLE);
+		break;
+
+	default:
+		error("%s, line %d: impl error: "
+			"unknown node type selected\n", __FILE__,__LINE__);
+	}
+}
+
+
+void SQDiagram::UpdateEdgeType(int num) {
+	((DiagramWindow *)GetMainWindow())->SetEdgeName(num);
+	switch(num) {
+	case 1: SetEdgeType(Code::CBD_OBJECT_LINK_EDGE);
+		SetLineType(Code::T4_LINE);
+		SetEdgeLineStyle(LineStyle::SOLID);
+		SetLineEnd1(LineEnd::EMPTY);
+		SetLineEnd2(LineEnd::FILLED_ARROW);
+std::cout << " VB DEselected " << std::endl << std::flush; 
+		((SQViewer *)GetDiagramViewer())->SetInFOCmode(False);
+		break;
+	case 2: SetEdgeType(Code::COMMENT_LINK);
+		SetLineType(Code::LINE);
+		SetEdgeLineStyle(LineStyle::WIDE_DOTTED);
+		SetLineEnd1(LineEnd::EMPTY);
+		SetLineEnd2(LineEnd::EMPTY);
+
+std::cout << " VB DEselected " << std::endl << std::flush; 
+		((SQViewer *)GetDiagramViewer())->SetInFOCmode(False);
+		break;
+
+	case 3: SetEdgeType(Code::EMPTY_EDGE);
+		SetLineType(Code::LINE);
+		SetEdgeLineStyle(LineStyle::INVISIBLE);
+		SetLineEnd1(LineEnd::EMPTY);
+		SetLineEnd2(LineEnd::EMPTY);
+
+std::cout << " VB selected " << std::endl << std::flush; 
+		((SQViewer *)GetDiagramViewer())->SetInFOCmode(True);
+		break;
+
+
+/*	
+	case 3: SetEdgeType(Code::CBD_OBJECT_LINK_EDGE);
+		SetLineType(Code::T4_TLIST_LINE);
+		SetEdgeLineStyle(LineStyle::SOLID);
+		SetLineEnd1(LineEnd::EMPTY);
+		SetLineEnd2(LineEnd::EMPTY);
+		break;
+*/	default:
+		error("%s, line %d: impl error: "
+			"unknown edge type selected\n", __FILE__,__LINE__);
+	}
+}
+
+
+/* HZ *
+bool SQDiagram::SetText(TextShape *t, const string *s) {
+
+//std::cout << "void SQDiagram::SetText() {" << std::endl << std::flush;
+
+
+	const string *d = t->GetDescription();
+	Subject *subj = t->GetParent()->GetSubject();
+
+//std::cout << "desc=[" << d->getstr() << "] str=[" << s->getstr() << "] subj=" 
+//	<< subj->GetClassType() 
+//	<< std::endl << std::flush;
+
+	if (*d == "Stereotype" && subj->GetClassType()==Code::CBD_CLASS_NODE)
+		return SetStereotype((CBClassNode*)subj, s);
+	else if (*d == "Properties" && subj->GetClassType()==Code::CBD_CLASS_NODE)
+		return SetProperties((CBClassNode*)subj, s);
+	else if (*d == "Message")
+		return SetMessage(subj, s, t->GetSequence());
+	else
+		return ERDiagram::SetText(t, s);
+}
+* HZ */
+
+
+
+void SQDiagram::CheckDocument() {
+	chkbuf = "";
+	unsigned total = 0;
+	// Check that object classes are named.
+	total += sqChecks->CheckNamelessNodes(Code::CBD_OBJECT_NODE, chkbuf);
+
+	ReportCheck(total, &chkbuf);
+}
diff -urN tcm-2.20/src/sd/dv/sqdiagram.h tcm-2.20+TSQD.orig/src/sd/dv/sqdiagram.h
--- tcm-2.20/src/sd/dv/sqdiagram.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqdiagram.h	2001-09-10 10:31:18.000000000 +0200
@@ -0,0 +1,65 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQDIAGRAM_H
+#define _SQDIAGRAM_H
+
+#include "erdiagram.h"
+class SQViewer;
+class SQWindow;
+class SQGraph;
+class SQChecks;
+class SQClassNode;
+
+/// UML sequence diagram class.
+class SQDiagram : public ERDiagram {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQDiagram(Config *, SQWindow *, SQViewer *, SQGraph *);
+	///
+	virtual ~SQDiagram();
+	///
+	Node *CreateNode();
+	///
+	Edge *CreateEdge(Subject *n1, Subject *n2);
+	///
+	NodeShape *CreateNodeShape(Node *node, int x, int y);
+	///
+	Line *CreateLine(Edge *edge, GShape *fromShape, 
+		GShape *toShape, List<Point *> *line);
+	///
+	void UpdateNodeType(int n);
+	///
+	void UpdateEdgeType(int n);
+
+	/// check the soft constraints on a SQD.
+	void CheckDocument();
+
+protected:
+	///
+	Thing *CreateThing(int classNr);
+	///
+	SQChecks *GetSQChecks() {return sqChecks;}
+private:
+	///
+	SQChecks *sqChecks;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqeditor.c tcm-2.20+TSQD.orig/src/sd/dv/sqeditor.c
--- tcm-2.20/src/sd/dv/sqeditor.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqeditor.c	2001-09-10 10:49:25.000000000 +0200
@@ -0,0 +1,26 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+
+#include "application.h"
+#include "sqwindow.h"
+
+Application *app = new Application(Toolkit::TOOLKIT_NAME);
+MainWindow *mw = new SQWindow(Toolkit::TOOLKIT_NAME);
diff -urN tcm-2.20/src/sd/dv/sqgraph.c tcm-2.20+TSQD.orig/src/sd/dv/sqgraph.c
--- tcm-2.20/src/sd/dv/sqgraph.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqgraph.c	2001-09-10 13:48:09.000000000 +0200
@@ -0,0 +1,78 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqgraph.h"
+#include "code.h"
+ 
+SQGraph::SQGraph(): ERGraph() {
+	int i=0;
+	int j=0;
+	nodeTypes[i++] = Code::UCD_ACTOR_NODE;
+	nodeTypes[i++] = Code::SSD_CLASS_NODE;
+	nodeTypes[i++] = Code::SSD_OBJECT_NODE;
+	nodeTypes[i++] = Code::CBD_OBJECT_NODE;
+	nodeTypes[i++] = Code::COMMENT;
+	nodeTypes[i++] = Code::NOTE;
+	nodeTypes[i++] = 0;
+
+	edgeTypes[j++] = Code::CBD_OBJECT_LINK_EDGE;
+	edgeTypes[j++] = Code::BINARY_RELATIONSHIP;
+	edgeTypes[j++] = Code::COMMENT_LINK;
+	edgeTypes[j++] = 0;
+}
+
+void SQGraph::InitConnections() {
+	int ACT = Code::GetIndex(Code::UCD_ACTOR_NODE, nodeTypes);
+	int _CLS = Code::GetIndex(Code::SSD_CLASS_NODE, nodeTypes);
+	int _OBJ = Code::GetIndex(Code::SSD_OBJECT_NODE, nodeTypes);
+	int CLS = Code::GetIndex(Code::CBD_CLASS_NODE, nodeTypes);
+	int OBJ = Code::GetIndex(Code::CBD_OBJECT_NODE, nodeTypes);
+	int NOT = Code::GetIndex(Code::NOTE, nodeTypes);
+
+	int CLN = Code::GetIndex(Code::CBD_CLASS_LINK_EDGE, edgeTypes);
+	int OLN = Code::GetIndex(Code::CBD_OBJECT_LINK_EDGE, edgeTypes);
+	int NBL = Code::GetIndex(Code::COMMENT_LINK, edgeTypes);
+ 
+	connections[ACT][CLS][CLN] = True;
+	connections[CLS][ACT][CLN] = True;
+	connections[ACT][OBJ][CLN] = True;
+	connections[OBJ][ACT][CLN] = True;
+	connections[CLS][OBJ][CLN] = True;
+	connections[OBJ][CLS][CLN] = True;
+
+	connections[CLS][CLS][CLN] = True;
+
+	connections[ACT][CLS][OLN] = True;
+	connections[CLS][ACT][OLN] = True;
+	connections[ACT][OBJ][OLN] = True;
+	connections[OBJ][ACT][OLN] = True;
+
+	connections[OBJ][OBJ][OLN] = True;
+
+			connections[OBJ][OBJ][CLN] = True;
+
+
+	connections[ACT][NOT][NBL] = True;
+	connections[NOT][ACT][NBL] = True;
+	connections[OBJ][NOT][NBL] = True;
+	connections[NOT][CLS][NBL] = True;
+	connections[CLS][NOT][NBL] = True;
+	connections[NOT][OBJ][NBL] = True;
+}
diff -urN tcm-2.20/src/sd/dv/sqgraph.h tcm-2.20+TSQD.orig/src/sd/dv/sqgraph.h
--- tcm-2.20/src/sd/dv/sqgraph.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqgraph.h	2001-09-10 10:39:34.000000000 +0200
@@ -0,0 +1,36 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+
+#ifndef _SQGRAPH_H
+#define _SQGRAPH_H
+
+#include "ergraph.h"
+
+/// UML collaboration graph class
+class SQGraph : public ERGraph {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQGraph();
+	///
+	void InitConnections();
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqobjectboxlifeline.c tcm-2.20+TSQD.orig/src/sd/dv/sqobjectboxlifeline.c
--- tcm-2.20/src/sd/dv/sqobjectboxlifeline.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqobjectboxlifeline.c	2001-09-10 12:02:42.000000000 +0200
@@ -0,0 +1,40 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, Universiteit Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+
+#include "lifeline.h"
+
+const int LifeLine::LIFELINE_WIDTH = 80;
+const int LifeLine::LIFELINE_HEIGHT = 40;
+
+const ShapeType Box::bxType(Code::BOX, BOX_WIDTH, BOX_HEIGHT, 0.0, 0.0,
+	&Polygon::Box, &Polygon::Box1, &PolyPoint::Index, &PolyPoint::Dupli,
+	&PolyPoint::Multi, &Polygon::Box);
+
+Box::Box(ShapeView *v, Grafport *g, double x, double y)
+	:NodeShape(v, g, x, y, &bxType)
+{
+}
+
+Box::Box(const NodeShape &c)
+	:NodeShape(c, &bxType)
+{
+}
diff -urN tcm-2.20/src/sd/dv/sqobjectboxlifeline.h tcm-2.20+TSQD.orig/src/sd/dv/sqobjectboxlifeline.h
--- tcm-2.20/src/sd/dv/sqobjectboxlifeline.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqobjectboxlifeline.h	2001-09-10 12:02:01.000000000 +0200
@@ -0,0 +1,44 @@
+//------------------------------------------------------------------------------
+// 
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, Universiteit Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _LIFELINE_H
+#define _LIFELINE_H
+
+#include "nodeshape.h"
+
+/// LifeLine shape class.
+class LifeLine: public NodeShape {
+/*@Doc: {\large {\bf scope:} diagram} */
+public:
+	static const int LIFELINE_WIDTH;
+	static const int LIFELINE_HEIGHT;
+	///
+	LifeLine(ShapeView *v, Grafport *g, double x, double y);
+	///
+	LifeLine(const NodeShape &c);
+	///
+	Shape *Clone() {return new LifeLine(*this);}
+protected:
+
+private:
+	static const ShapeType bxType;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqobjectnode.c tcm-2.20+TSQD.orig/src/sd/dv/sqobjectnode.c
--- tcm-2.20/src/sd/dv/sqobjectnode.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqobjectnode.c	2004-07-17 15:51:00.000000000 +0200
@@ -0,0 +1,252 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or 
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+////////////////////////////////////////////////////////////////////////////////
+#include "sqobjectnode.h"
+#include "sqgraph.h"
+#include "inputfile.h"
+#include "outputfile.h"
+#include "lstring.h"
+#include <limits.h>
+
+
+SQObjectNode::SQObjectNode(SQGraph *g): Node (g) {
+	stereotype = "<< - >>";
+	properties = "{ - }";
+	anchors = new List<Point *>;
+	std::cout << "{ Stereotype [" << stereotype << "]" << std::endl << std::flush; 
+	std::cout << "{ Properties [" << properties << "]" << std::endl << std::flush; 
+}
+
+SQObjectNode::SQObjectNode(const SQObjectNode &s): Node(s) {
+	stereotype = s.stereotype;
+	properties = s.properties;
+	anchors = new List<Point *>;
+	for (s.anchors->first(); !s.anchors->done(); s.anchors->next()) {
+		Point *a = s.anchors->cur();
+		Point *b = new Point(*a);
+		anchors->add(b);
+	}                   
+}
+
+SQObjectNode::~SQObjectNode() {
+	anchors->clear();
+	delete anchors;
+} 
+
+
+
+bool SQObjectNode::SetStereotype(const string *s) {
+	if (*s != "" && s->letters()==0)
+		return False;
+	stereotype = *s;
+	return True;
+}
+
+bool SQObjectNode::SetProperties(const string *s) {
+	if (*s != "" && s->letters()==0)
+		return False;
+	properties = *s;
+	return True;
+}
+
+void SQObjectNode::AddAnchor(int ypos, int atype) {
+std::cout << " void SQObjectNode::AddAnchor(" << ypos << ", " << atype << ") {"
+<< std::endl << std::flush;
+
+
+	std::cout<<"=====(((())))====="<<anchors<<std::endl<<std::flush;
+
+
+		anchors->add(new Point(ypos, atype));
+}
+
+
+void SQObjectNode::InsertAnchor(int ypos, int atype) {
+std::cout << " void SQObjectNode::InsertAnchor(" << ypos << ", " << atype << ") {"
+<< std::endl << std::flush;
+
+
+	unsigned idx = 0; 	//init
+	bool posFound = False;
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "B4 *ap=" << *ap << std::endl << std::flush;
+
+		if (!posFound && (ap->x > ypos)) {
+std::cout << " going 2 insert [" << ypos << "] b4 [" << ap->x << "]" << std::endl << std::flush;
+			posFound = True;
+			anchors->insert(new Point(ypos, atype), idx);
+std::cout << " IDXIDXIDXIDXIDXIDX insert ===> " << idx << std::endl << std::flush;
+		}
+		idx++;
+	}
+	if (!posFound) {
+std::cout << "IDXIDXIDXIDXIDXIDX going 2 add [" << ypos << "] @end " << std::endl << std::flush;
+		anchors->add(new Point(ypos, atype));
+	}
+
+for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "NA *ap=" << *ap << std::endl << std::flush;
+	}
+
+}
+
+
+
+void SQObjectNode::RemoveAnchor(int ypos, int atype) {
+std::cout << " void SQObjectNode::RemoveAnchor(" << ypos << ", " << atype << ") {"
+<< std::endl << std::flush;
+
+	unsigned idx = 0; 	//init
+	bool posFound = False;
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "SCANNING *ap=" << *ap << std::endl << std::flush;
+
+		if (!posFound &&  (ap->x == ypos) && (ap->y == atype) ) {
+std::cout << " Found: " << *ap << std::endl << std::flush;
+			posFound = True;
+			anchors->removei(idx);
+std::cout << " IDXIDXIDXIDXIDXIDX remove ===> " << idx << std::endl << std::flush;
+
+		}
+		idx++;
+	}
+
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "NA *ap=" << *ap << std::endl << std::flush;
+	}
+
+	if (!posFound) {
+std::cout << " anchor NOT found!" << std::endl << std::flush;
+	}
+}
+
+
+
+
+
+
+void SQObjectNode::SortAnchors() {
+std::cout << " void SQObjectNode::SortAnchors() {"
+<< std::endl << std::flush;
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "B4 *ap=" << *ap << std::endl << std::flush;
+	}
+		anchors->sort(CompareAnchor);
+
+
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "NA *ap=" << *ap << std::endl << std::flush;
+	}
+
+}
+
+
+int SQObjectNode::GetMinAnchor() {
+std::cout << " int SQObjectNode::GetMinAnchor() {" << std::endl << std::flush;
+	int minA = INT_MAX; 	//init
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "scanning *ap=" << *ap << std::endl << std::flush;
+
+		if (ap->x < minA) {
+std::cout << " new minA found " << minA << " --> " << ap->x <<  std::endl << std::flush;
+			minA = ap->x;
+		}
+	}
+std::cout << "==> int SQObjectNode::GetMinAnchor() --> " << minA << std::endl << std::flush;
+	return minA;
+}
+
+
+int SQObjectNode::GetMaxAnchor() {
+std::cout << " int SQObjectNode::GetMaxAnchor() {" << std::endl << std::flush;
+	int maxA = 0; 	//init
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "scanning *ap=" << *ap << std::endl << std::flush;
+
+		if (ap->x > maxA) {
+std::cout << " new maxA found " << maxA << " --> " << ap->x <<  std::endl << std::flush;
+			maxA = ap->x;
+		}
+	}
+std::cout << "==> int SQObjectNode::GetMaxAnchor() --> " << maxA << std::endl << std::flush;
+	return maxA;
+}
+
+
+bool SQObjectNode::ReadMembers(InputFile *ifile, double format) {
+	if (!Node::ReadMembers(ifile, format))
+		return False;
+	stereotype = "<< - >>";
+	if (!ifile->ReadStringAttribute("Stereotype", &stereotype))
+		return False;
+	properties = "{ - }";
+	if (!ifile->ReadStringAttribute("Properties", &properties))
+		return False;
+
+std::cout << "A" << std::endl << std::flush;
+std::cout << "B" << std::endl << std::flush;
+	string val;
+	if (!ifile->ReadAttribute("Anchors", &val)) {
+std::cout << "C" << std::endl << std::flush;
+		return False;
+	}
+std::cout << "D" << std::endl << std::flush;
+	unsigned numAnchors = val.toint();
+
+std::cout << "Nr Anchors: " << val << " == " << numAnchors << std::endl << std::flush;
+
+
+	string val1, val2;
+	for (unsigned i=0; i<numAnchors; i++) {
+		if (!ifile->ReadAttribute2("Anchor", &val1, &val2)) {
+std::cout << "Wrong anchor: " << val1 << ", " << val2 << std::endl << std::flush;
+			return False;
+		}
+std::cout << "Got anchor " << i << " : " << val1 << ", " << val2 << std::endl << std::flush;
+
+//HZ	anchors->add(new Anchorpoint(val1, val2));
+		anchors->add(new Point(val1.toint(), val2.toint()));
+
+	}
+
+	return True;
+}
+
+void SQObjectNode::WriteMembers(OutputFile *ofile) {
+	Node::WriteMembers(ofile);
+	(*ofile) << "\t{ Stereotype " << '"' << stereotype << '"' << " }\n";
+	(*ofile) << "\t{ Properties " << '"' << properties << '"' << " }\n";
+
+	(*ofile) << "\t{ Anchors " << anchors->count() << " }\n";
+	for(anchors->first(); !anchors->done(); anchors->next()) {
+		Point *ap = anchors->cur();
+std::cout << "*ap=" << *ap << std::endl << std::flush;
+		(*ofile) << "\t{ Anchor " << *ap << " }\n";
+	}     
+}
diff -urN tcm-2.20/src/sd/dv/sqobjectnode.h tcm-2.20+TSQD.orig/src/sd/dv/sqobjectnode.h
--- tcm-2.20/src/sd/dv/sqobjectnode.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqobjectnode.h	2004-03-25 14:30:36.000000000 +0100
@@ -0,0 +1,82 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+// 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQOBJECTNODE_H
+#define _SQOBJECTNODE_H
+
+#include "node.h"
+#include "anchorpoint.h"
+#include "point.h"
+class SQGraph;
+
+/// object class (TSQD) node class.
+class SQObjectNode: public Node {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQObjectNode(SQGraph *g);
+	///
+	SQObjectNode(const SQObjectNode &s);
+	///
+	~SQObjectNode();
+	///
+	Subject *Clone() {return new SQObjectNode(*this);}
+	///
+	int GetClassType() const {return Code::CBD_OBJECT_NODE;}	//HZ
+	///
+	bool  SetStereotype(const string *s);
+	///
+	bool SetProperties(const string *s); 
+	///
+	const string *GetStereotype() {return &stereotype;}
+	///
+	const string *GetProperties() const {return &properties;}
+	///
+	void AddAnchor(int ypos, int atype);
+	///
+	void InsertAnchor(int ypos, int atype);
+	///
+	void RemoveAnchor(int ypos, int atype);
+	///
+	int GetMinAnchor();
+	///
+	int GetMaxAnchor();
+	///
+	void SortAnchors();
+	///
+	void WriteMembers(OutputFile *f);
+	///
+	bool ReadMembers(InputFile *f, double format);
+	///
+	unsigned NrAnchors() {return anchors->count();}
+	///
+	List<Point *> *GetAnchors() {return anchors;}
+	///
+	friend int CompareAnchor(Point *p1, Point *p2) {std::cout << " p1->x=" << p1->x << "  p2->x=" << p2->x << std::endl << std::flush; return p1->x <= p2->x;}
+private:
+	///
+	string stereotype;
+	///
+	string properties;
+	///
+	List<Point *> *anchors;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqstubs.c tcm-2.20+TSQD.orig/src/sd/dv/sqstubs.c
--- tcm-2.20/src/sd/dv/sqstubs.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqstubs.c	2004-05-05 16:47:30.000000000 +0200
@@ -0,0 +1,50 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqstubs.h"
+#include "sqviewer.h"
+
+
+void SQStubs::AddFOCCB(Widget, XtPointer cd, XtPointer) {
+	((SQViewer *)cd)->UpdateShowStereotypes(True);
+}
+
+void SQStubs::DeleteFOCCB(Widget, XtPointer cd, XtPointer) {
+	//((SQViewer *)cd)->UpdateShowStereotypes(True);
+	((SQViewer *)cd)->DeleteFOC();
+}
+
+
+void SQStubs::ShowStereotypeCB(Widget, XtPointer cd, XtPointer) {
+	((SQViewer *)cd)->UpdateShowStereotypes(True);
+}
+
+void SQStubs::HideStereotypeCB(Widget, XtPointer cd, XtPointer) {
+	((SQViewer *)cd)->UpdateShowStereotypes(False);
+}
+
+void SQStubs::ShowPropertiesCB(Widget, XtPointer cd, XtPointer) {
+	((SQViewer *)cd)->UpdateShowProperties(True);
+}
+
+void SQStubs::HidePropertiesCB(Widget, XtPointer cd, XtPointer) {
+	((SQViewer *)cd)->UpdateShowProperties(False);
+}
+
diff -urN tcm-2.20/src/sd/dv/sqstubs.h tcm-2.20+TSQD.orig/src/sd/dv/sqstubs.h
--- tcm-2.20/src/sd/dv/sqstubs.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqstubs.h	2002-02-27 10:41:07.000000000 +0100
@@ -0,0 +1,44 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQSTUBS_H
+#define _SQSTUBS_H
+
+#include "erstubs.h"
+
+/// Specific stubs for a TSQD. 
+class SQStubs: public ERStubs {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+
+	///
+	static void AddFOCCB(Widget, XtPointer, XtPointer);
+	///
+	static void DeleteFOCCB(Widget, XtPointer, XtPointer);
+	///
+	static void ShowStereotypeCB(Widget, XtPointer, XtPointer);
+	///
+	static void HideStereotypeCB(Widget, XtPointer, XtPointer);
+	///
+	static void ShowPropertiesCB(Widget, XtPointer, XtPointer);
+	///
+	static void HidePropertiesCB(Widget, XtPointer, XtPointer);
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqviewer.c tcm-2.20+TSQD.orig/src/sd/dv/sqviewer.c
--- tcm-2.20/src/sd/dv/sqviewer.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqviewer.c	2004-07-07 22:44:30.000000000 +0200
@@ -0,0 +1,645 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqviewer.h"
+#include "sqwindow.h"
+#include "cbupdateactortypecmd.h"
+#include "subject.h"
+//X #include "ssdsingleclassbox.h"
+//X #include "ucdsingleclassbox.h"
+#include "ssddoubleclassbox.h"		// compatibility
+#include "ssdtripleclassbox.h"		// compatibility
+#include "ssdupdateclassboxpropertycmd.h"
+
+#include "diagram.h"
+#include "diagramviewer.h"
+#include "apline.h"
+#include "lifeline.h"
+#include "createfoccmd.h"
+#include "pullfoccmd.h"
+#include "pullshapecmd.h"
+#include "sqobjectnode.h"
+#include "shapeview.h"
+#include "createedgecmd.h"
+#include "createl2ledgecmd.h"
+#include "sqanchorlinkedge.h"
+
+
+SQViewer::SQViewer(Config *c, SQWindow *w): ERViewer(c, w) { }
+
+void SQViewer::Select(int x, int y) {
+std::cout << " void SQViewer::Select(" <<  x << ", " <<  y << ") {" << std::endl << std::flush;
+	SetInConnectMessage(False);		//init
+
+	SetInvalidConnect(False);		//init
+	// Begin Aleister2 Begin
+
+	x = int(0.5 + ScaleCorrect(x));
+	y = int(0.5 + ScaleCorrect(y));
+
+	GShape *shape;
+	// look for nodes shapes.
+	if ((shape = GetCurView()->HitNodeShape(x, y))) {
+	//xtra check here
+		LifeLine *l = (LifeLine *) shape;
+		int lStart = 0;
+		int lEnd = 0;
+//		if ( (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd))
+		bool b = (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd));
+
+		if (b) {
+
+			selectedFOC = true;
+			posSelectedFOC = Point(x, y);
+			inFOCmode = true;
+			return;
+		} else {
+			selectedFOC = false;
+			inFOCmode = false;
+		}
+	}
+
+	// End Aleister2 End
+	ERViewer::Select(x, y);
+}
+
+
+Command *SQViewer::Drag(int x, int y) {
+std::cout << " Command *SQViewer::Drag(" << x << "," << y << ") {" << std::endl << std::flush;
+	SetInConnectMode(False);		//init
+	SetInConnectMessage(False);		//init
+
+	SetInvalidConnect(False);		//init
+	TextShape *textShape;
+	x = int(0.5 + ScaleCorrect(x));
+	y = int(0.5 + ScaleCorrect(y));
+	// do note allow moving messages
+std::cout << " A-1 " << std::endl << std::flush;
+std::cout << " GNT=" << GetDefaultNodeType() << std::endl << std::flush;
+std::cout << " GNsT=" << GetDefaultNodeShapeType() << std::endl << std::flush;
+
+std::cout << " inFOCmode=" << inFOCmode << std::endl << std::flush;
+std::cout << " inFOCblock=" << inFOCblock << std::endl << std::flush;
+std::cout << " inConnectMode=" << inConnectMode << std::endl << std::flush;
+std::cout << " invalidConnect=" << invalidConnect << std::endl << std::flush;
+
+
+	if ((textShape = GetCurView()->HitTextShape(x, y, False))) {
+std::cout << " B-2 " << std::endl << std::flush;
+		Subject *subj = textShape->GetParent()->GetSubject();
+
+		if ((*textShape->GetDescription() == "Message") &&
+		    ((subj->GetClassType() == Code::CBD_CLASS_LINK_EDGE) ||
+			 (subj->GetClassType() == Code::CBD_OBJECT_LINK_EDGE))) {
+			SetStatus("aborted: message can not be dragged");
+			return 0;
+		}
+	}
+
+
+/* dragging @ LifeLine End? */
+
+	GShape *shape;
+	int w;
+	// look for nodes shapes.
+	if ((shape = GetCurView()->HitNodeShape(x, y))) {
+lastPosition = *shape->GetPosition();//Aleister
+std::cout << "shape->Sj()= " << shape->GetSubject() << std::endl << std::flush;
+std::cout << "shape->Sj()->GetId()= " << shape->GetSubject()->GetId() << std::endl << std::flush;
+std::cout << "shape->Sj()->GetCt()= " << shape->GetSubject()->GetClassType() << std::endl << std::flush;
+
+		if (shape->IsSelected() &&
+			(shape->GetSubject()->GetClassType()  == Code::CBD_OBJECT_NODE) &&
+		    (w = shape->HitHandles(x, y)) == 5) {
+
+
+
+			LifeLine *l = (LifeLine *) shape;
+			int yy = l->GetEndPositionY();
+std::cout << " WE ARE AT LifeLine End? w=" << w << " @end:" << yy << std::endl << std::flush;
+
+			return new PullShapeCmd(shape, w);
+		}
+
+//xtra check here
+
+		LifeLine *l = (LifeLine *) shape;
+		int lStart = 0;
+		int lEnd = 0;
+//		if ( (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd))
+		bool b = (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd));
+std::cout << "=Drag=>  l->PtInFOCblock(" << l->GetPosition()->x << ", " << y << ", "
+<< lStart << "," << lEnd << ")); --> " << b << std::endl << std::flush;
+
+
+		if (b) {
+std::cout << "*** Drag FOC End (" << b << ") x, y: " << x << ", " << y << std::endl << std::flush;
+			//Begin Aleister3
+			if(y - lStart <= 7) {
+				y = lStart;
+				return new CreateFOCCmd(shape, y, lStart, lEnd, true);
+			} else {
+				if(lEnd - y <= 7) {
+					y = lEnd;
+					return new CreateFOCCmd(shape, y, lStart, lEnd, true);
+				}
+			}
+			//End Aleister3
+
+		}
+
+
+//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
+
+//???????????????????????????????????????????????????????????????????????????????????????????
+std::cout<<"CCCCCCCCCCC"<<std::endl<<std::flush;
+int w;
+		if(GetCurView()->HitLineHandle(x, y, w))	{
+
+			SetInConnectMessage(True);
+			//SetInConnectMode(True);
+			lastPosition.Set((l-> GetPosition()->x), y);
+					std::cout<<"DDDDDDDDDD"<<std::endl<<std::flush;
+			/*List<Point *> *appoints;
+			appoints = ((SQObjectNode *)(l->GetSubject()))->GetAnchors();
+
+			for(appoints->first(); !appoints->done(); appoints->next()) {
+
+				Point p = *appoints->cur();
+				if(p.y == 4 || p.y == 5) {
+					//if(abs(p.x-y)< 5) {
+					if(p.x-y< 5 || y-p.x < 5) {
+						lastPosition = Point(x, p.x);
+						spotLine=p.y;
+					}
+				}
+
+			}*/
+
+
+
+		}
+
+
+//???????????????????????????????????????????????????????????????????????????????????????????
+
+
+
+//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
+
+
+
+	}
+	lastPosition.Set(x, y);
+
+std::cout << " GOING 2 	return ERViewer::Drag(" << x << ", " << y << ");" << std::endl << std::flush;
+//	SetInConnectMode(True);
+	return ERViewer::Drag(x,y);
+
+/* ************ *
+	if (!inFOCblock) {
+std::cout << " GOING 2 	return ERViewer::Drag(" << x << ", " << y << ");" << std::endl << std::flush;
+		return ERViewer::Drag(x,y);
+	}
+	else {
+std::cout << " GOING 2 	Drag FOC (" << x << ", " << y << ");" << std::endl << std::flush;
+
+		LifeLine *l = (LifeLine *) shape;
+		int lStart = 0;
+		int lEnd = 0;
+//		if ( (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd))
+		bool b = (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd));
+std::cout << "=====>  l->PtInFOCblock(" << l->GetPosition()->x << ", " << y << ", "
+<< lStart << "," << lEnd << ")); --> " << b << std::endl << std::flush;
+		return new CreateFOCCmd(shape, y, lStart, lEnd);
+	}
+* ************ */
+}
+
+
+
+
+void SQViewer::UpdateNodeShapeType(int actorType) {
+	SetStatus("action: Update actor type");
+	List<int *> t;
+	t.add(new int(Code::UCD_SINGLE_CLASS_BOX));
+	t.add(new int(Code::STICKMAN));
+	if (GetCurView()->NrSelected() > 0) {
+		NewCommand(new CBUpdateActorTypeCmd(
+				GetCurView(), &t, actorType));
+		ExecuteCommand();
+	}
+	else
+		EmptySelectionMessage();
+	t.clear();
+}
+
+
+void SQViewer::UpdateShowStereotypes(bool b) {
+	if (b)
+		SetStatus("action: show stereotypes");
+	else
+		SetStatus("action: hide stereotypes");
+	if (GetCurView()->NrSelected() > 0) {
+		NewCommand(new SSDUpdateClassBoxPropertyCmd(
+				GetCurView(),
+				SSDUpdateClassBoxPropertyCmd::STEREOTYPE, b));
+		ExecuteCommand();
+	}
+	else
+		EmptySelectionMessage();
+}
+
+
+void SQViewer::UpdateShowProperties(bool b) {
+	if (b)
+		SetStatus("action: show properties");
+	else
+		SetStatus("action: hide properties");
+	if (GetCurView()->NrSelected() > 0) {
+		NewCommand(new SSDUpdateClassBoxPropertyCmd(
+				GetCurView(),
+				SSDUpdateClassBoxPropertyCmd::PROPERTIES, b));
+		ExecuteCommand();
+	}
+	else
+		EmptySelectionMessage();
+}
+
+
+void SQViewer::Snap(Point *p) {
+std::cout << " +++++++++++++++  void SQViewer::Snap(" << *p << ") {" << std::endl << std::flush;
+	GetGrid()->Snap(p);
+
+std::cout << " ++after Snap+++  --> Snap(" << *p << ") {" << std::endl << std::flush;
+std::cout << " ++after Snap+++  --> p->x,y =" << p->x << ", " << p->y  << std::endl << std::flush;
+
+std::cout << " GetCurView()->NrOfShapes() == " << GetCurView()->NrOfShapes() << std::endl << std::flush;
+std::cout << " GetCurView()->NrSelected() == " << GetCurView()->NrSelected() << std::endl << std::flush;
+
+	GShape *shape;
+
+	if ((shape = GetCurView()->HitNodeShape(lastPosition.x, lastPosition.y))) {//Aleister
+
+std::cout << "t_Shape->=Sel " << shape->IsSelected() << std::endl << std::flush;
+std::cout << "t_Shape->Sj()->GetId()= " << shape->GetSubject()->GetId() << std::endl << std::flush;
+std::cout << "t_Shape->Sj()->GetCt()= " << shape->GetSubject()->GetClassType() << std::endl << std::flush;
+
+std::cout << "t_Shape->GetPos()->x = " << shape->GetPosition()->x << std::endl << std::flush;
+std::cout << "t_Shape->GetPos()->y = " << shape->GetPosition()->y << std::endl << std::flush;
+std::cout << "t_Shape->GetHeight() = " << shape->GetHeight() << std::endl << std::flush;
+
+
+		if (shape->GetSubject()->GetClassType()  == Code::CBD_OBJECT_NODE) {
+
+			LifeLine *l = (LifeLine *) shape;
+			int minPos = l->GetEndPositionY();	//init: at EOL
+
+			if ( ((SQObjectNode *)shape->GetSubject())->NrAnchors() ) {
+				minPos = min(minPos, ((SQObjectNode *)shape->GetSubject())->GetMinAnchor());
+			}
+
+//????????????????????????????????????????????????????????????????????????????????????????????
+
+
+
+
+
+			if(inConnectMessage){
+//std::cout <<"&&&&&&&&&&&&&&&&&&&&&&&&"<<"t_Shape->GetPos()->x = " <<std::endl << std::flush;
+//std::cout<<(char)7<<std::endl<<std::flush;
+//std::cout<<(char)7<<std::endl<<std::flush;
+//std::cout<<(char)7<<std::endl<<std::flush;
+				if( ! (p->y> ( (l-> GetPosition()->y) + shape->GetHeight()/2 )  && p->y <  ( l->GetEndPositionY() )) ) {
+
+					*p=lastPosition;
+					return;
+
+				}
+				else {
+
+
+
+					lastPosition.Set((l-> GetPosition()->x), p->y);
+					return;
+
+
+				}
+			}
+/*
+			} else {*/
+				if(!inConnectMode) {
+				if ((((GetCurView()->Snap(p->y) + shape->GetHeight()/2) > minPos) ) || (((GetCurView()->Snap(p->y) + shape->GetHeight()/2) > ( l->GetEndPositionY() )-7) )) {
+
+
+					*p = *shape->GetPosition();
+					return;
+				} else {
+					std::cout << "t_Shape valid pos: SQViewer::Snap Returning: " << *p << std::endl << std::flush;
+				}
+				}
+
+
+
+
+
+
+		}//if (shape->GetSubject()->GetClassType()  == Code::CBD_OBJECT_NODE) {
+
+	}
+
+}
+//????????????????????????????????????????????????????????????????????????????????????????????
+/*  REEMPLAZADO
+std::cout << "t_Shape GetCurView()->Snap(p->y) = " << GetCurView()->Snap(p->y) << std::endl << std::flush;
+std::cout << "t_Shape: minPos = " << minPos << std::endl << std::flush;
+std::cout << "t_Shape: INVALID_CONNECT = " << invalidConnect << std::endl << std::flush;
+
+
+			if ( ((GetCurView()->Snap(p->y) + shape->GetHeight()/2) > minPos) &&
+				 !inConnectMode ) {
+std::cout << "t_Shape INVALID position!!! (!inConnectMode)"
+<< (GetCurView()->Snap(p->y) + shape->GetHeight()/2) << " >>> "
+<< minPos << std::endl << std::flush;
+std::cout << "t_Shape->GetPosition() = " << shape->GetPosition() << std::endl << std::flush;
+
+				//restore oldPosition; thus aborting the drag operation
+				*p = *shape->GetPosition();
+std::cout << "t_Shape INVALID pos: SQViewer::Snap Returning: " << *p << std::endl << std::flush;
+				return;
+			} else
+std::cout << "t_Shape valid pos: SQViewer::Snap Returning: " << *p << std::endl << std::flush;
+
+		}
+
+	}
+
+} REEMPLAZADO */
+
+
+Command *SQViewer::Connect(int x, int y) {
+	GShape *shape;
+	SetInConnectMode(False);		//init
+	SetInConnectMessage(False);		//init
+
+	SetInvalidConnect(False);		//init
+	x = int(0.5 + ScaleCorrect(x));
+	y = int(0.5 + ScaleCorrect(y));
+	int w = 0;
+
+std::cout << "C: inFOCmode=" << inFOCmode << std::endl << std::flush;
+std::cout << "C: inFOCblock=" << inFOCblock << std::endl << std::flush;
+std::cout << "C: inConnectMode=" << inConnectMode << std::endl << std::flush;
+std::cout << "C: invalidConnect=" << invalidConnect << std::endl << std::flush;
+
+
+bool tHitted = False;
+bool tSelected = False;
+if ((shape = GetCurView()->HitNodeShape(x, y))) {
+		tHitted = True;
+		tSelected = shape->IsSelected();
+		w = shape->HitHandles(x, y);
+}
+
+
+std::cout << " Command *SQViewer::Connect(" <<  x << "," <<  y << ") : HNs="
+	<< tHitted  << " isSel=" << tSelected << "  HitH=" << w
+	<<  " isSel&&HHs=" << (tSelected && (w >= 0))
+	<< "} " << std::endl << std::flush;
+
+
+	if (tHitted) {
+		//Mod Aleister if (inFOCmode) {
+			//Begin Aleister6
+			LifeLine *l = (LifeLine *) shape;
+			int lStart = 0;
+			int lEnd = 0;
+	//		if ( (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd))
+			bool b = (l->PtInFOCblock(l->GetPosition()->x, y, &lStart, &lEnd));
+
+			if (b) {
+				if(y - lStart <= 7) {
+					y = lStart;
+					return new CreateFOCCmd(shape, y, lStart, lEnd);
+				} else {
+					if(lEnd - y <= 7) {
+						y = lEnd;
+						return new CreateFOCCmd(shape, y, lStart, lEnd);
+					}
+				}
+			} else {
+				if(inFOCmode) {
+					std::cout << "SQViewer::Connect(): inFOCmode: CREATE FOC here @ " << y << std::endl << std::flush;
+		//JZ		shape->UndrawShape();
+		//JZ		shape->DrawShape();
+
+					return new CreateFOCCmd(shape, y, y, y);
+				}
+			}
+			//End Aleister6
+		//Mod Aleister} else {	//starting in FOC area?
+			//LifeLine *l = (LifeLine *) shape;
+			if (l->PtInFOCarea(x, y)) {
+std::cout << " Pt In FOC AREA OK " << std::endl << std::flush;
+				SetInConnectMode(True);
+
+				return ERViewer::Connect(x, y);
+/* *** BYE *
+				if (shape->IsSelected() && (w = shape->HitHandles(x, y)) >= 0) {
+std::cout << "======= GOING 3:  return new SizeShapeBorderCmd(shape, w);" << std::endl << std::flush;
+					return new SizeShapeBorderCmd(shape, w);
+				} else {
+//std::cout << "======= GOING 3:  return new CreateL2LEdgeCmd(shape);" << std::endl << std::flush;
+//HZ					return new CreateL2LEdgeCmd(shape);
+std::cout << "======= GOING 3:  return new CreateEdgeCmd(shape);" << std::endl << std::flush;
+					return new CreateEdgeCmd(shape);
+				}
+* *** BYE */
+
+			} else {
+std::cout << " Pt In FOC AREA FALSE " << std::endl << std::flush;
+				return 0;
+			}
+		//Mod Aleister]
+	}
+	else {
+std::cout << " Not in NodeShape: IGNORED " << std::endl << std::flush;
+	return 0;
+	}
+}
+
+
+
+void SQViewer::DeleteFOC() {
+//Begin Aleister2 Begin
+	if(selectedFOC) {
+		GShape *shape;
+
+		if ((shape = GetCurView()->HitNodeShape(posSelectedFOC.x, posSelectedFOC.y))) {
+			LifeLine *l = (LifeLine*)shape;
+
+			int startFOC;
+			int endFOC;
+
+			l->PtInFOCblock(posSelectedFOC.x, posSelectedFOC.y,
+			       &startFOC, &endFOC);
+			l->Undraw();
+
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(startFOC, 2);
+			((SQObjectNode *)shape->GetSubject())->RemoveAnchor(endFOC, 3);
+
+			l->Draw();
+
+	//	shape->UpdateSize(int(0.5 + oldWidth), int(0.5 + oldHeight));
+		shape->GetView()->GetViewer()->ShapePositionUpdate(shape);
+		}
+		return;
+	}
+//End Aleister2 End
+
+
+}
+/*
+
+void SQViewer::DeleteSubjects() {
+std::cout << " void SQViewer::DeleteSubjects() {" << std::endl << std::flush;
+
+	if (GetCurView()->NrSelected() > 0) {
+		int i = 0;
+
+		List<GShape *> *selection = GetCurView()->GetSelection();
+		for (selection->first(); !selection->done(); selection->next()) {
+		std::cout<<"=========(((((((("<<i++<<")))))========="<<std::flush<<std::endl;
+			GShape *shape = selection->cur();
+
+			if (shape->GetClassType()==Code::T4_LINE) {
+std::cout << "!!! GOT a T4_LINE: " << shape->GetClassType() << std::endl << std::flush;*/
+//				Point from = *(((APLine *)shape)->GetFromShape()->GetPosition());
+/*
+
+std::cout << "shape->Sj()->GetId()= " << shape->GetSubject()->GetId() << std::endl << std::flush;
+				Subject *subj = shape->GetSubject();
+std::cout << "subj->GetId()= " << subj->GetId() << std::endl << std::flush;
+
+
+				GShape *from = ((APLine *)shape)->GetFromShape();
+				GShape *to = ((APLine *)shape)->GetToShape();
+
+std::cout << " Leading from " << from->GetId() << " --> " << to->GetId() << std::endl << std::flush;
+
+
+				SQAnchorLinkEdge *obj = (SQAnchorLinkEdge *)shape->GetSubject();
+*/
+
+
+				/*SQObjectNode *fromON = (SQObjectNode *) obj->GetSubject1();
+				SQObjectNode *toON = (SQObjectNode *) obj->GetSubject2();*/
+
+//				Point ap1 = *obj->GetAnchor1();
+//				Point ap2 = *obj->GetAnchor2();
+
+//std::cout << " #ap=" << ((SQObjectNode *)shape->GetSubject())->NrAnchors() << std::endl << std::flush;
+//std::cout << " ap1=" << ap1 << "  ap1.x=" << ap1.x << std::endl << std::flush;
+//std::cout << " ap2=" << ap2 << "  ap2.x=" << ap2.x << std::endl << std::flush;
+
+				//if ( ((SQObjectNode *)shape->GetSubject())->NrAnchors() ) {
+
+
+
+ //((SQObjectNode *)from->GetSubject())->RemoveAnchor(ap1.x, 2);
+ //((SQObjectNode *)to->GetSubject())->RemoveAnchor(ap2.x, 3);
+/*
+ DiagramViewer::DeleteSubjects();
+ std::cout<<ap1<<std::endl<<std::flush;
+ std::cout<<ap2<<std::endl<<std::flush;
+((SQObjectNode *)from->GetSubject())->RemoveAnchor(ap1.x, ap1.y);
+ ((SQObjectNode *)to->GetSubject())->RemoveAnchor(ap2.x, ap2.y);
+return;
+
+				//}
+			}
+
+		}
+
+
+		DiagramViewer::DeleteSubjects();
+		SetStatus("SQVIEWR action: delete Subjects");
+
+	}
+	else
+		EmptySelectionMessage();
+
+}*/
+
+
+
+void SQViewer::DeleteSubjects() {
+std::cout << " void SQViewer::DeleteSubjects() {" << std::endl <<
+std::flush;
+
+	List<Subject *> *edges;
+	edges = new List<Subject *>;
+
+	if (GetCurView()->NrSelected() > 0) {
+
+		List<GShape *> *selection = GetCurView()->GetSelection();
+
+		for (selection->first(); !selection->done(); selection->next()) {
+
+			GShape *shape = selection->cur();
+
+			if
+((shape->GetSubject())->GetClassType()==Code::CBD_OBJECT_LINK_EDGE) {
+				if (edges->find(shape->GetSubject()) == -1)
+					edges->add(shape->GetSubject());
+			} else {
+				if((shape->GetSubject())->GetClassType() == Code::CBD_OBJECT_NODE)
+					GetDiagram()->CompleteSubject(edges, shape->GetSubject());
+				
+			}
+
+		}
+
+		DiagramViewer::DeleteSubjects();
+
+		for(edges->first(); !edges->done(); edges->next()) {
+
+			Subject *edge = edges->cur();
+	
+			if (edge->GetClassType()==Code::CBD_OBJECT_LINK_EDGE) {
+
+				SQAnchorLinkEdge *obj = (SQAnchorLinkEdge *)edge;
+				SQObjectNode *from = (SQObjectNode *) obj->GetSubject1();
+				SQObjectNode *to = (SQObjectNode *) obj->GetSubject2();
+				Point ap1 = *obj->GetAnchor1();
+				Point ap2 = *obj->GetAnchor2();
+				from->RemoveAnchor(ap1.x, ap1.y);
+ 				to->RemoveAnchor(ap2.x, ap2.y);
+
+			}
+		}
+	}
+	else
+		EmptySelectionMessage();
+}
+
+
+
+
diff -urN tcm-2.20/src/sd/dv/sqviewer.h tcm-2.20+TSQD.orig/src/sd/dv/sqviewer.h
--- tcm-2.20/src/sd/dv/sqviewer.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqviewer.h	2004-05-21 00:43:08.000000000 +0200
@@ -0,0 +1,104 @@
+
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQVIEWER_H
+#define _SQVIEWER_H
+
+#include "erviewer.h"
+class SQWindow;
+
+/// class-relationship viewer class.
+class SQViewer: public ERViewer {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQViewer(Config *c, SQWindow * w);
+
+	/// Perform the function of the 1st button function of the mouse 
+	void Select(int x, int y);		//resetting inConnectMode
+	///
+	Command *Drag(int x, int y);
+
+	/// create an edge between nodes.
+	Command *Connect(int x, int y); 
+
+	/// change actor type of selected object types.
+	void UpdateNodeShapeType(int);
+
+	/// update show stereotypes type of selected object types.
+	void UpdateShowStereotypes(bool);
+
+	/// update show properties type of selected object types.
+	void UpdateShowProperties(bool);
+
+
+	//GGGGGGG
+	void DeleteFOC();
+
+
+	///
+	void DeleteSubjects();
+
+	///
+	void Snap(Point *p);
+
+	///
+	bool IsInFOCmode() {return inFOCmode;}
+	///
+	bool IsInFOCblock() {return inFOCblock;}
+	///
+	bool IsInConnectMode() {return inConnectMode;}
+	///
+	bool IsInvalidConnect() {return invalidConnect;}
+
+	/// set/reset in FOC mode
+	void SetInFOCmode(bool set) {std::cout << "SetInFOCmode:" << inFOCmode << "->" << set << std::endl << std::flush; inFOCmode = set;}
+	/// set/reset in FOC block
+	void SetInFOCblock(bool set) {std::cout << "SetInFOCblock:" << inFOCblock << "->" << set << std::endl << std::flush; inFOCblock = set;}
+	/// set/reset in Connect Mode
+	void SetInConnectMode(bool set) {std::cout << "SetInConnectMode:" << inConnectMode << "->" << set << std::endl << std::flush; inConnectMode = set;}
+	/// set/reset invalid Connect
+	void SetInvalidConnect(bool set) {std::cout << "SetInvalidConnect:" << invalidConnect << "->" << set << std::endl << std::flush; invalidConnect = set;}
+
+
+
+
+	void SetInConnectMessage(bool set) {std::cout << "SetInConnectMessage:" << inConnectMessage << "->" << set << std::endl << std::flush; inConnectMessage = set;}
+
+private:
+	/// in Focus Of Control mode
+	bool inFOCmode;
+	/// in Focus Of Control block
+	bool inFOCblock;
+	/// in Connecting Lifelines Mode
+	bool inConnectMode;
+	/// invalid Connect
+	bool invalidConnect;
+	//Aleister1
+	Point lastPosition;
+	//Aleister2
+	bool selectedFOC;
+	//Aleister2
+	Point posSelectedFOC;
+
+	bool inConnectMessage;
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/sqwindow.c tcm-2.20+TSQD.orig/src/sd/dv/sqwindow.c
--- tcm-2.20/src/sd/dv/sqwindow.c	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqwindow.c	2004-06-28 23:07:55.000000000 +0200
@@ -0,0 +1,219 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#include "sqdiagram.h"
+#include "sqviewer.h"
+#include "sqgraph.h"
+#include "sqstubs.h"
+#include "sqwindow.h"
+#include "menu.h"
+#include "diagramstubs.h"
+
+// X bitmap data for the tiled buttons
+#include "Arrow.xbm"
+#include "Comment.xbm"
+#include "DottedLine.xbm"
+#include "NoteBox.xbm"
+#include "ActorBox.xbm"
+#include "ActorObjectBox.xbm"
+#include "Box.xbm"
+#include "ObjectBox.xbm"
+#include "R2Line.xbm"
+#include "StickMan.xbm"
+#include "StickManObject.xbm"
+#include "FOCBox.xbm"
+
+const char *SQWindow::SQ_NODE_NAMES[] =
+	{"LifeLine (StickMan)",
+	 "Note",
+	 "LifeLine (ObjectBox)",
+	 "Comment"};
+const Bitmap SQWindow::SQ_NODE_ICONS[] =
+	{{StickMan_width, StickMan_height, StickMan_bits},
+	 {NoteBox_width, NoteBox_height, NoteBox_bits},
+	 {ObjectBox_width, ObjectBox_height, ObjectBox_bits},
+	 {Comment_width, Comment_height, Comment_bits}};
+
+const char* SQWindow::SQ_EDGE_NAMES[] =
+	{"AnchorPoint link",
+	 "Note connector",
+	 "Focus Of Control Box"};
+
+const Bitmap SQWindow::SQ_EDGE_ICONS [] =
+	{{Arrow_width, Arrow_height, Arrow_bits},
+	 {DottedLine_width, DottedLine_height, DottedLine_bits},
+	 {FOCBox_width, FOCBox_height, FOCBox_bits}};
+
+SQWindow::SQWindow(const char *n) : ERWindow(n) {
+	diagramSQActorItems = 0;
+	diagramSQClassStereotypeItems = 0;
+	diagramSQClassPropertiesItems = 0;
+}
+
+SQWindow::~SQWindow() {
+	if (diagramSQActorItems) {
+		delete diagramSQActorItems;
+		delete diagramSQClassStereotypeItems;
+		delete diagramSQClassPropertiesItems;
+	}
+}
+
+DiagramViewer *SQWindow::CreateViewer(Config *cfg) {
+	return new SQViewer(cfg, this);
+}
+
+Graph *SQWindow::CreateGraph() {
+	return new SQGraph();
+}
+
+Diagram *SQWindow::CreateDiagram(Config *c, DiagramViewer *v, Graph *g) {
+	 return new SQDiagram(c, this, (SQViewer *)v, (SQGraph *)g);
+}
+
+void SQWindow::DetermineIcons() {
+	 nodeNames = SQ_NODE_NAMES;
+	 nodeIcons = SQ_NODE_ICONS;
+	 edgeNames = SQ_EDGE_NAMES;
+	 edgeIcons = SQ_EDGE_ICONS;
+	 nrNodes = XtNumber(SQ_NODE_NAMES);
+	 nrEdges = XtNumber(SQ_EDGE_NAMES);
+}
+
+void SQWindow::InitMenuItems() {
+	ERWindow::InitMenuItems();
+	int i = 0;
+
+	diagramSQActorItems = new MenuItem[10]; i=0;
+	diagramSQActorItems[i] = MenuItem(
+		"to Actor Box", MenuItem::PUSHBUTTON, 'B', 0, 0,
+		DiagramStubs::UpdateNodeShapeTypeCB,
+		(XtPointer)GetDiagramViewer(),
+		(XtPointer)Code::UCD_SINGLE_CLASS_BOX, 0, 1); i++;
+	diagramSQActorItems[i] = MenuItem(
+		"to StickMan", MenuItem::PUSHBUTTON, 'S', 0, 0,
+		DiagramStubs::UpdateNodeShapeTypeCB,
+		(XtPointer)GetDiagramViewer(),
+		(XtPointer)Code::STICKMAN, 0, 1); i++;
+	diagramSQActorItems[i] = MenuItem::NUL;
+
+	diagramSQClassStereotypeItems = new MenuItem[10]; i=0;
+	diagramSQClassStereotypeItems[i] = MenuItem(
+		"Show Stereotype", MenuItem::PUSHBUTTON, 'S', 0, 0,
+		SQStubs::ShowStereotypeCB, (XtPointer)GetDiagramViewer(),
+		0, 0, 1); i++;
+	diagramSQClassStereotypeItems[i] = MenuItem(
+		"Hide Stereotype", MenuItem::PUSHBUTTON, 'H', 0, 0,
+		SQStubs::HideStereotypeCB, (XtPointer)GetDiagramViewer(),
+		0, 0, 1); i++;
+	diagramSQClassStereotypeItems[i] = MenuItem::NUL;
+
+	diagramSQClassPropertiesItems = new MenuItem[10]; i=0;
+	diagramSQClassPropertiesItems[i] = MenuItem(
+		"Show Properties", MenuItem::PUSHBUTTON, 'S', 0, 0,
+		SQStubs::ShowPropertiesCB, (XtPointer)GetDiagramViewer(),
+		0, 0, 1); i++;
+	diagramSQClassPropertiesItems[i] = MenuItem(
+		"Hide Properties", MenuItem::PUSHBUTTON, 'H', 0, 0,
+		SQStubs::HidePropertiesCB, (XtPointer)GetDiagramViewer(),
+		0, 0, 1); i++;
+	diagramSQClassPropertiesItems[i] = MenuItem::NUL;
+
+	// delete last menu item: hide value types.
+	int n = 0;
+	while (viewItems[n++].label != 0)
+		;
+	viewItems[n-2] = MenuItem::NUL;
+
+	int j = 0;
+	while (editItems[j++].label != 0)
+		;
+std::cout << " j===================" << j << std::endl << std::flush;
+	editItems[--j] = MenuItem("", MenuItem::SEPARATOR); j++;
+
+	/*editItems[j] = MenuItem(
+		"Add Focus Of Control", MenuItem::PUSHBUTTON, 'F', 0, 0,
+		SQStubs::AddFOCCB, (XtPointer)GetDiagramViewer(), 0, 0, 1); j++;*/
+	/*editItems[j] = MenuItem(
+		"Delete Focus Of Control", MenuItem::PUSHBUTTON, 'G', 0, 0,
+		SQStubs::DeleteFOCCB, (XtPointer)GetDiagramViewer(), 0, 0, 1); j++;*/
+
+	//editItems[j] = MenuItem::NUL;		// TMP
+
+
+
+	//editItems[j] = MenuItem("", MenuItem::SEPARATOR); j++;
+
+/*	editItems[j] = MenuItem(
+		"Change Actor Type", MenuItem::SUBMENU, 'C', 0, 0,
+		0, 0, 0, diagramSQActorItems, 1); j++;
+	editItems[j] = MenuItem("", MenuItem::SEPARATOR); j++;*/
+	editItems[j] = MenuItem(
+		"Change Stereotype", MenuItem::SUBMENU, 'h', 0, 0,
+		0, 0, 0, diagramSQClassStereotypeItems, 1); j++;
+	editItems[j] = MenuItem(
+		"Change Properties", MenuItem::SUBMENU, 'a', 0, 0,
+		0, 0, 0, diagramSQClassPropertiesItems, 1); j++;
+	editItems[j] = MenuItem("", MenuItem::SEPARATOR); j++;
+	editItems[j] = MenuItem(
+		"Change Read Direction", MenuItem::SUBMENU, 'R', 0, 0,
+		0, 0, 0, ERReadDirectionItems, 1); j++;
+	editItems[j] = MenuItem::NUL;
+
+//std::cout << " j===================" << j << std::endl << std::flush;
+	int k = 0;
+	 while (popupEditItems[k++].label != 0)
+		;
+	popupEditItems[--k] = MenuItem("", MenuItem::SEPARATOR); k++;
+
+
+
+/*	popupEditItems[k] = MenuItem(
+		"Add Focus Of Control", MenuItem::PUSHBUTTON, 'F', 0, 0,
+		SQStubs::AddFOCCB, (XtPointer)GetDiagramViewer(), 0, 0, 1); k++;*/
+
+
+	popupEditItems[k] = MenuItem(
+		"Delete Focus Of Control", MenuItem::PUSHBUTTON, 'G', 0, 0,
+		SQStubs::DeleteFOCCB, (XtPointer)GetDiagramViewer(), 0, 0, 1); k++;
+	//popupEditItems[k] = MenuItem("", MenuItem::SEPARATOR); k++;
+
+/*
+	popupEditItems[k] = MenuItem(
+		"Change Actor Type", MenuItem::SUBMENU, '\0', 0, 0,
+		0, 0, 0, diagramSQActorItems, 1); k++;
+
+*/
+
+	popupEditItems[k] = MenuItem("", MenuItem::SEPARATOR); k++;
+	popupEditItems[k] = MenuItem(
+		"Change Stereotype", MenuItem::SUBMENU, '\0', 0, 0,
+		0, 0, 0, diagramSQClassStereotypeItems, 1); k++;
+
+	popupEditItems[k] = MenuItem(
+		"Change Properties", MenuItem::SUBMENU, '\0', 0, 0,
+		0, 0, 0, diagramSQClassPropertiesItems, 1); k++;
+	popupEditItems[k] = MenuItem("", MenuItem::SEPARATOR); k++;
+//popupEditItems[k] = MenuItem::NUL;
+
+	popupEditItems[k] = MenuItem(
+		"Change Read Direction", MenuItem::SUBMENU, '\0', 0, 0,
+		0, 0, 0, ERReadDirectionItems, 1); k++;
+//	popupEditItems[k] = MenuItem::NUL;
+}
diff -urN tcm-2.20/src/sd/dv/sqwindow.h tcm-2.20+TSQD.orig/src/sd/dv/sqwindow.h
--- tcm-2.20/src/sd/dv/sqwindow.h	1970-01-01 01:00:00.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/dv/sqwindow.h	2002-02-27 12:02:04.000000000 +0100
@@ -0,0 +1,62 @@
+//------------------------------------------------------------------------------
+//
+// This file is part of Toolkit for Conceptual Modeling (TCM).
+// (c) copyright 2001, University of Twente.
+// Author: Henk van de Zandschulp (henkz@cs.utwente.nl).
+//
+// TCM is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// TCM is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with TCM; if not, write to the Free Software Foundation, Inc.,
+// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//-----------------------------------------------------------------------------
+#ifndef _SQWINDOW_H
+#define _SQWINDOW_H
+
+#include "erwindow.h"
+
+/// class-relationship edit window class.
+class SQWindow: public ERWindow {
+/*@Doc: {\large {\bf scope:} TSQD} */
+public:
+	///
+	SQWindow(const char *name);
+	///
+	virtual ~SQWindow();
+private:
+	///
+	int GetTool() {return Toolkit::SQD;}
+	///
+	DiagramViewer *CreateViewer(Config *config);
+	///
+	Graph *CreateGraph();
+	///
+	Diagram *CreateDiagram(Config *c, DiagramViewer *v, Graph *g);
+	///
+	void DetermineIcons();
+	///
+	MenuItem *diagramSQActorItems;
+	///
+	MenuItem *diagramSQClassStereotypeItems;
+	///
+	MenuItem *diagramSQClassPropertiesItems;
+	///
+	void InitMenuItems();
+	///
+	static const char *SQ_NODE_NAMES[];
+	///
+	static const Bitmap SQ_NODE_ICONS[];
+	///
+	static const char *SQ_EDGE_NAMES[];
+	///
+	static const Bitmap SQ_EDGE_ICONS[];
+};
+#endif
diff -urN tcm-2.20/src/sd/dv/tcmdv.c tcm-2.20+TSQD.orig/src/sd/dv/tcmdv.c
--- tcm-2.20/src/sd/dv/tcmdv.c	2002-05-28 10:32:55.000000000 +0200
+++ tcm-2.20+TSQD.orig/src/sd/dv/tcmdv.c	2004-07-21 21:04:42.000000000 +0200
@@ -27,6 +27,7 @@
 #include "ucwindow.h"
 #include "esdwindow.h"
 #include "cbwindow.h"
+#include "sqwindow.h"
 #include <stdlib.h>
 
 int main (int argc, char **argv) {
@@ -52,11 +53,13 @@
 		new UCWindow(Toolkit::TOOLKIT_NAME);
 	else if (equal(prog, "tcbd"))
 		new CBWindow(Toolkit::TOOLKIT_NAME);
+	else if (equal(prog, "tsqd"))
+		new SQWindow(Toolkit::TOOLKIT_NAME);
 	else {
 		error("%s: unknown tool\n", prog);
 		exit(1);
 	}
-	// Make sure the programmer has remembered to 
+	// Make sure the programmer has remembered to
 	// instantiate an Application object
 	if (!check (theApplication))
 		return 1;
diff -urN tcm-2.20/src/sd/gd/tcmd.c tcm-2.20+TSQD.orig/src/sd/gd/tcmd.c
--- tcm-2.20/src/sd/gd/tcmd.c	2003-01-09 15:52:54.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/gd/tcmd.c	2004-07-21 22:51:02.000000000 +0200
@@ -29,6 +29,7 @@
 #include "../dv/ucwindow.h"
 #include "../dv/cbwindow.h"
 #include "../dv/esdwindow.h"
+#include "../dv/sqwindow.h"
 #include "../bv/stwindow.h"
 #include "../bv/atwindow.h"
 #include "../bv/pswindow.h"
@@ -93,6 +94,8 @@
 		new CBWindow(Toolkit::TOOLKIT_NAME);
 	else if (equal(prog, "tscd"))
 		new SCWindow(Toolkit::TOOLKIT_NAME);
+	else if (equal(prog, "tsqd"))
+		new SQWindow(Toolkit::TOOLKIT_NAME);
 	else {
 		error("%s: unknown tool\n", prog);
 		exit(1);
diff -urN tcm-2.20/src/sd/Makefile tcm-2.20+TSQD.orig/src/sd/Makefile
--- tcm-2.20/src/sd/Makefile	2003-01-20 13:32:37.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/sd/Makefile	2004-07-21 20:55:00.000000000 +0200
@@ -15,7 +15,7 @@
 tcmtr$(EXEEXTENSION) tgtt$(EXEEXTENSION) tfrt$(EXEEXTENSION):   
 	( cd ./tr ; $(MAKE) $@)
 
-tcmdv$(EXEEXTENSION) terd$(EXEEXTENSION) tesd$(EXEEXTENSION) tcrd$(EXEEXTENSION) tssd$(EXEEXTENSION) tucd$(EXEEXTENSION) tcbd$(EXEEXTENSION):
+tcmdv$(EXEEXTENSION) terd$(EXEEXTENSION) tesd$(EXEEXTENSION) tcrd$(EXEEXTENSION) tssd$(EXEEXTENSION) tucd$(EXEEXTENSION) tcbd$(EXEEXTENSION) tsqd$(EXEEXTENSION):
 	( cd ./dv ; $(MAKE) $@)
 
 tcmbv$(EXEEXTENSION) tscd$(EXEEXTENSION) tstd$(EXEEXTENSION) trpg$(EXEEXTENSION) tpsd$(EXEEXTENSION) tatd$(EXEEXTENSION):   
diff -urN tcm-2.20/src/ui/xresources.c tcm-2.20+TSQD.orig/src/ui/xresources.c
--- tcm-2.20/src/ui/xresources.c	2003-01-09 15:52:55.000000000 +0100
+++ tcm-2.20+TSQD.orig/src/ui/xresources.c	2004-07-21 21:17:16.000000000 +0200
@@ -82,7 +82,7 @@
 "*StartupWindow*TATD.Background:light blue",
 "*StartupWindow*TSCD.Background:light blue",
 "*StartupWindow*TCBD.Background:light blue",
-"*StartupWindow*TSQD.Background:light gray",
+"*StartupWindow*TSQD.Background:light blue",
 "*StartupWindow*TCPD.Background:light blue",
 "*StartupWindow*TDPD.Background:light blue",
 "*StartupWindow*TERD.Background:light pink",
@@ -162,7 +162,7 @@
 "*StartupWindow*TATD.Background:light blue",
 "*StartupWindow*TSCD.Background:light blue",
 "*StartupWindow*TCBD.Background:light blue",
-"*StartupWindow*TSQD.Background:light gray",
+"*StartupWindow*TSQD.Background:light blue",
 "*StartupWindow*TCPD.Background:light blue",
 "*StartupWindow*TDPD.Background:light blue",
 "*StartupWindow*TERD.Background:light pink",
diff -urN tcm-2.20/tcm-dynmotif-2.20.spec tcm-2.20+TSQD.orig/tcm-dynmotif-2.20.spec
--- tcm-2.20/tcm-dynmotif-2.20.spec	2003-01-17 16:34:30.000000000 +0100
+++ tcm-2.20+TSQD.orig/tcm-dynmotif-2.20.spec	2004-07-21 21:19:05.000000000 +0200
@@ -115,6 +115,7 @@
 /opt/tcm/bin/tscd
 /opt/tcm/bin/tsnd
 /opt/tcm/bin/tssd
+/opt/tcm/bin/tsqd
 /opt/tcm/bin/tstd
 /opt/tcm/bin/ttdt
 /opt/tcm/bin/ttut
diff -urN tcm-2.20/tcm-statmotif-2.20.spec tcm-2.20+TSQD.orig/tcm-statmotif-2.20.spec
--- tcm-2.20/tcm-statmotif-2.20.spec	2003-01-17 16:35:58.000000000 +0100
+++ tcm-2.20+TSQD.orig/tcm-statmotif-2.20.spec	2004-07-21 21:19:52.000000000 +0200
@@ -115,6 +115,7 @@
 /opt/tcm/bin/tscd
 /opt/tcm/bin/tsnd
 /opt/tcm/bin/tssd
+/opt/tcm/bin/tsqd
 /opt/tcm/bin/tstd
 /opt/tcm/bin/ttdt
 /opt/tcm/bin/ttut
